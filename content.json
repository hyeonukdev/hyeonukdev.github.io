{"pages":[],"posts":[{"title":"빅데이터(Big Data) 분석의 중요성","text":"데이터로부터 얼마나 많은 부가가치를 얻을 수 있나? 과학 기술 경쟁이 치열 침단 과학기술이 사용자의 요구를 충족시켰을때 부가가치 창출(아마존 마케팅, 애플 등) 미래 사용자의 필요 예측이 매우 중요 기술분야에서 앞으로 중시될 세가지 영역 데이터 마이닝, 기계학습, 인공지능, 자연어처리 Business Intelligence, 경쟁정보전략 분석, 통계 빅데이터의 시대적 변화 o 1990년대 중반 ~ 2000년대 중반 고객정보 유통사 상품 구매정보 상품/서비스 구매정보 교통정보 리서치 정보 o 2000년대 중반 ~ 2010년대 중반 Data의 통합 관리를 통한 소비자의 입체적 이해 o 2010년대 중반 이후 고객정보 모바일 SNS 이종 데이터 간의 결합 Cloud Computing 데이터 마켓의 출현 빅데이터 활용 개념도 빅데이터 산업 분류 빅데이터 활용사례 공공빅데이터 구글트렌드 빅데이터 활용 프로세스 데이터수집 및 관리 정형데이터 - 고객수 - 판매량 - 키워드빈도 비정형데이터 - 로그 - SNS 텍스트 - 사진 데이터분석 기초통계분석 - 집계 - 통계치 - 회귀분석 데이터마이닝/기계학습/AI/딥러닝 - 군집,연관 - 시계열, 추천 - 텍스트마이닝 - 커뮤니티분석 데이터활용 시각화 신제품전략 마케팅전략 니즈발견 리스크경감 데이터분석에 필요한 기술들 Mathematics Expertise 통계 선형대수 미분/적분 Business/Strategy Acumen 도메인 지식/경험 문제 영역 Technology, Hacking Skills 컴퓨터 프로그래밍 데이터베이스 인프라 시스템 빅데이터 인프라 : 하둡 하둡은 오픈소스 분산처리 기술 하둡 분산 파일 시스템 HDFS(Hadoop Distributed File System) 간단한 서버들을 이용하여 가상화된 HDFS을 구성하고 여기에 존재하는 거대한 데이터를 간편하게 다루는 MapReduce 프레임워크를 구현하여 제공 빅데이터 관련 이슈 개인정보 이슈 인력양성 빅데이터의 지도화 자료의 품질관리 중요성 수학 및 통계, IT, 언어학, 비즈니스 등의 다양한 영역의 융합교육 필요 인프라 또는 IT기술 뿐만 아니라, 분석과 시각화 및 해석의 중요성 부각 장기적인 관점에서의 데이터 분석 및 관리 필요","link":"/2020/04/15/DataScience/%EB%B9%85%EB%8D%B0%EC%9D%B4%ED%84%B0(Big%20Data)%EB%B6%84%EC%84%9D%EC%9D%98%EC%A4%91%EC%9A%94%EC%84%B1/"},{"title":"데이터 자료형","text":"python 자료형 자료형 저장 모델 변경 가능성 접근방법 수치형 int, float, complex Literal Immutable Direct 문자열 str Container Immutable Sequence 튜플 tuple Container Immutable Sequence 리스트 list Container Mutable Sequence 사전 dict Container Mutable Mapping 집합 set Container Mutable set 저장 모델 Literal : 단일 종류 Container : 종류에 무관 변경 가능성 Immutable : 변경 불가 Mutable : 변경 가능 접근 방법 Direct : 직접 할당 Sequence : 순서 중시 Mapping : 순서 무관 Set : 중복 불가 튜플은 최초에 입력한 데이터 변경이 불가 리스트는 최초에 입력한 데이터 변경 가능 사전은 순서에는 상관 없지만 중복 가능 집합은 중복 불가능 C자료형 자료형 메모리크기 데이터 범위 정수형 char 1바이트 -128 ~ +127 정수형 short 2바이트 -32768 ~ +32767 정수형 int 4바이트 -2147483648 ~ +2147483647 정수형 long 4바이트 -2147483648 ~ + 2147483647 실수형 float 4바이트 3.4x10^-37 ~ +3.4x10^+38 실수형 double 8바이트 1.7x10^-307 ~ 1.7x10^+308 실수형 long double 8바이트 이상 -","link":"/2020/04/21/DataScience/%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%9E%90%EB%A3%8C%ED%98%95/"},{"title":"엑셀 수식 사용 - 1강. 수식과 함수","text":"1.수식의 이해 Cell의 자료형식 숫자형식 : 0 ~ 9 숫자의 정밀도는 앞에서 15자리, -9.9E+307~9.9E+307 범위 문자형식 : A ~ Z, a ~ z, 가나다라, 특수문자 수학형식 : = 으로 시작 날짜/시간 형식 수식 - 연산자(수식연산자, 논리연산자) 수식연산자(Mathematical operators) | 연산자 | 설명 | | — | — | | + | 더하기 | | - | 빼기 | | * | 곱하기 | | / | 나누기 | | ^ | 지수| | &amp; | 문자열조합| 논리연산자(Logical operators) | 연산자 | 설명 | | — | — | | = | 같음 | | &gt; | 보다 큼 | | &lt; | 보다 작음 | | &gt;= | 보다 크거나 같음 | | &lt;= | 보다 작거나 같음 | | &lt;&gt; | 같지 않음 | 연산자 우선 순위(Operator precedence) 기호 연산자 연산순위 ^ 지수승 1 * , / 곱하기,나누기 2 + , - 더하기,빼기 3 &amp; 문자열 결합 4 = , &lt;,&gt; 같음,작음,큼 5 예시","link":"/2020/04/16/DataScience/%EC%97%91%EC%85%80%EC%88%98%EC%8B%9D%EC%82%AC%EC%9A%A9-1%EA%B0%95%EC%88%98%EC%8B%9D%EA%B3%BC%ED%95%A8%EC%88%98/"},{"title":"빅데이터(Big Data)의 이해","text":"빅데이터 등장 배경 디지털 기술 발전에 따른 대규모 데이터 생성 데이터 생성 규모(Volume)확대 생성주기(Velocity)가 짧아짐 기존 수치 위주에서 문자, 이미지, 영상 등 다양한 형태(Variety)로 발생 빅데이터의 정의 명확히 합의된 정의가 없음 - 데이터 수집, 저장, 관리, 분석을 처리하는 통상의 용량을 넘어서는 Dataset 규모로, 그 정의는 주관적이며 앞으로도 기술발전에 따라 정의는 변화될 것이다. - 가장 많이 쓰이는 정의 3V + Value - 엑셀로 처리하기에 적합하지 않는 데이터 - SPSS, SAS와 같은 통계 패키지 등에 적합한 자료의 의미 3V + Value 빅데이터의 분류 및 처리과정 데이터 마이닝(Data Mining) 데이터베이스 내에서 어떠한 방법에 의해 관심 있는 지식을 찾아내는 과정 - 대용량의 데이터 속에서 유용한 정보를 발견하는 과정이며 이러한 기술을 의미 - 데이터 베이스 마케팅 분야 - 순차패턴, 유사성을 활용 정의 - 복잡한 통계적인 분석이나 모형구축 기법을 통해 대용량의 데이터 내에 이전에는 알려지지 않았던 패턴이나 규칙 등을 탐색하고 모형화 하여 유용한 지식을 추출하는 일련의 과정 - 통계적 관점 : 대용량의 데이터에 대한 탐색적 데이터 분석(Exploratory Data Analysis) 빅데이터 환경의 특징 구분 기존 빅데이터 환경 데이터 정형화된 수치자료 중심 -비정형의 다양한 데이터 - 문자 데이터 - 영상 데이터 - 위치 데이터 하드웨어 고가의 저장장치 데이터베이스 데이터웨어하우스 - 클라우드 컴퓨팅 등 비용 효율적인 장비 활용 가능 소프트웨어/분석 방법 관계형 데이터베이스 통계패키지 데이터마이닝 머신러닝 - 오픈소스 형태의 무료 소프트웨어 - Hadoop, NoSQL - 오픈소스 통계솔루션® - 텍스트 마이닝 - 온라인 버즈 분석 -감성 분석 일반데이터와 빅데이터의 차이 빅데이터 IT 핵심 기술","link":"/2020/04/15/DataScience/%EB%B9%85%EB%8D%B0%EC%9D%B4%ED%84%B0(Big%20Data)%EC%9D%98%EC%9D%B4%ED%95%B4/"},{"title":"통계의 목적과 엑셀 데이터 기초","text":"통계학의 정의 통계학(statistics)은 수량적인 비교를 기초로 사실을 관찰하고 분석하는 방법을 연구하는 학문 일반적으로 수집되는 데이터가 조사자, 시기, 방법, 목적 등에 따라 다르게 나타나는 불균형적인 데이터이지만, 통계학은 이 안에서 의미를 찾아내고 실생활에서 적용가능한 유용성을 찾아내 이를 수치로 표현할 수 있다. 기술통계(descriptive statistics): 표본에 대한 분석 결과의 각종 수치들을 활용하여 집단의 특성을 설명 추론통계(inference statistics): 표본을 활용하여 모집단의 특성을 나타내는 것 통계학의 목적 의사결정 많은 정보를 지각하고 평가하여 하나를 선택 정보와 반응 사잉의 다대일 대응으로 나타남 여러가지 대안 가운데 하나를 선택할 때 사용 불확실성의해소 의사결정을 하게 되면 그 결과가 정확한 것이라 할 수 있는가의 문제 빅데이터의 개념을 들여와 불확실성을 해소 정보수집이 어려움 시장의 변화와 대응의 어려움에대한 극복 필요 요약 다양한 데이터를 신속히 이해할 수 있도록 다양한 형태로 표현 불확실성의 감소를 위해 사용 반복되어 생산되는 데이터를 정리된 보고서로 표현하여 불확실성이 낮은 상황의 의사결정이 가능하도록 함 연관성 파악 요약된 보고서에서 주요한 항목들 간의 연관성을 파악한 경쟁우위의 확보 의사결정권자에게 항목 간 연관성을 제시해 미래의 계획을 지원 다양한 자료는 의사결정에 있어 세부적 판도에 기여 예측 인과관계 파악을 통해 패턴을 찾아내고 이러한 패턴을 통해 추세를 판단 다양한 변수의 대입과 삭제를 통해 예측 가능 통계분석의 과정 통계분석은 표본을 통해 의미 있는 자료를 추출하고, 이를 기반으로 의사결정, 불확실성의 해소요약, 연관성 파악, 예측 등의 결과로 이어지도록하는 일련의 과정이다 수집 -&gt; 정제 -&gt; 추정 -&gt; 검정 수집 조사과정에서 자연스럽게 수집 조사자가 특정 목적에 맞는 자료를 얻기 위해 설계한 수집 도구를 이용 보통 자료가 많을 수록 통계분석에서 더 좋은 결과를 얻을 것이라고 생각하지만 조사의 목적에 맞는 적절한 자료를 수집해서 최적의 통계방법으로 분석한 결과가 가장 정확도가 높음 정제 분석에 적합한 자료를 선별 적합하지 않은 자료는 삭제 추정 통계 분석을 진행하는 것 -&gt; 모수를 추정하는 것 표본의 특성을 설명하는 통계량을 통해 모집단의 모수를 추정하게 됨 검정 통계조사의 목적 -&gt; 주장이 믿어지는 사실이 실제로 옳은지 아닌지를 확인 수립된 가설이 유의미하고 타당성을 가지는지 통계적으로 확인하는 과정 확인을 통해 가설의 기각와 채택여부를 판단 통계분석의 한계 확률이 없으면 무의미 - 통계분석의 결과는 항상 확률과 연관되어 표현 항상 틀릴 가능성 내포 - 신뢰수준 100% -&gt; 신뢰구간에 해당하는 값 (-무한 ~ + 무한) - 결과의 범위가 줄수록 신뢰구간은 100%에서 멀어짐","link":"/2020/04/15/DataScience/%ED%86%B5%EA%B3%84%EC%9D%98%EB%AA%A9%EC%A0%81%EA%B3%BC%EC%97%91%EC%85%80%EB%8D%B0%EC%9D%B4%ED%84%B0%EA%B8%B0%EC%B4%88/"},{"title":"순열과 조합","text":"순열(Permutation) -&gt; PERMUT(number, number_chosen) 서로 다른 n개의 원소에서 r개를 중복없이 골라 순서에 상관 있게 나열하는 것으로 n개에서 r개를 택하는 순열이라고 함 nPr=n∗(n−1)∗(n−2)∗...∗(n−r+1)=n!/(n−r)!nPr = n * (n-1) * (n-2) * ... * (n - r + 1) = n! / (n-r)! nPr=n∗(n−1)∗(n−2)∗...∗(n−r+1)=n!/(n−r)! 순열의 종류 순열 중복순열 : n개에서 r개를 순서에 상관 있게 뽑는데 중복가능 등차순열 : n에서 r개를 뽑는데, n개 중에서 똑같은 것이 섞인 경우 원순열 : n개를 원형으로 나열하는 경우 조합(Combination) -&gt; COMBIN(number, number_chosen) 서로 다른 n개의 원소에서 순서에 상관없이 r개를 뽑을 때, 이때 n개에서 r개를 택하는 조합 nCr=nPr/r!=n!/(n−r)!r!nCr = nPr / r! = n!/ (n-r)!r! nCr=nPr/r!=n!/(n−r)!r! 조합의 종류 조합 중복조합 : n개에서 r개를 순서에 상관없이 뽑는데 중복을 허락하는 경우","link":"/2020/04/18/DataScience/%EC%88%9C%EC%97%B4%EC%A1%B0%ED%95%A9/"},{"title":"name 'WordCloud' is not defined","text":"설치 1pip install wordcloud import 하기 1from wordcloud import WordCloud 참조 : https://lovit.github.io/nlp/2018/04/17/word_cloud/","link":"/2020/05/04/Error/WordCloud/"},{"title":"No module named 'konlpy'","text":"윈도우에 설치 ava 1.7+이 설치되어 있나요? JAVA_HOME 설정하기 JPype1 (&gt;=0.5.7)을 다운로드 받고 설치. 다운 받은 .whl 파일을 설치하기 위해서는 pip 을 업그레이드 해야할 수 있습니다. 123&gt; pip install --upgrade pip&gt; pip install JPype1-0.5.7-cp27-none-win_amd64.whl&gt; pip install konlpy 참조 https://konlpy-ko.readthedocs.io/ko/v0.4.3/install/#id2 JPypel 받을 때 cp27은 파이썬 버전 python -v 를 통해 본인 파이썬 버전확인 후 받기","link":"/2020/05/03/Error/konlpy/"},{"title":"단어가어떤순서로쓰였는가","text":"2.3 단어가 어떤 순서로 쓰였는가 2.3.1 통계 기반 언어 모델 언어 모델 ** language model**이란 단어 시퀀스에 확률을 부여하는 모델이다. 단어의 등장 순서를 무시하는 백오브워즈와 달리 언어 모델은 시퀀스 정보를 명시적으로 학습한다. 단어가 n개 주어진 상황이라면 언어 모델은 n개 단어가 동시에 나타날 확률, 즉 P라는 것을 반환한다. 통계 기반의 언어 모델은 말뭉치에서 해당 단어 시퀀스가 얼마나 자주 등장하는지 빈도를 세어 학습한다. 이렇게 되면 주어진 단어 시퀀스 다음 단어는 무엇이 오는게 자연스러운지 알 수 있다. n-gram이란 n개 단어를 뜻하는 용어이다. 난폭,운전 눈, 뜨다 등은 2-gram 또는 bigram이라는 말을 쓴다. 누명, 을, 쓰다 는 3-gram 혹은 trigram이라고 쓴다. 경우에 따라서 n-gram은 n-gram에 기반한 언어 모델을 의미하기도 한다. 말뭉치 내 단어들을 n개씩 묶어서 그 빈도를 학습했다는 뜻이다. 예컨데 내, 내 마음 말뭉치는 빈도가 많지만 내 마음 속에 영원히 기억될 최고의 명작이다 라는 말뭉치가 한 번도 없을 수 있다. 이럴 때에는 말뭉치로 학습한 언어 모델은 해당 표현이 나타날 확률을 0으로 부여하게 된다. 문법적으로나 의미적으로 결함이 없는 훌륭한 한국어 문장임에도 해당 표현을 말이 되지 않는 문장으로 취급할 수 있다는 것이다. 내 마음 속에 영원히 기억될 최고의 라는 표현 다음에 명작이다라는 단어가 나타날 확률은 조건부확률 ** conditional probability**의 정의를 활용해 최대우도추정법 으로 유도한다. P(명작이다∣내,마음,속에,영원히,기억될,최고의)=Freq(내,마음,속에,영원히,기억될,최고의,명작이다)Freq(내,마음,속에,영원히,기억될,최고의)P(명작이다|내, 마음, 속에, 영원히, 기억될, 최고의) = { Freq(내, 마음, 속에, 영원히, 기억될, 최고의, 명작이다) \\over Freq(내, 마음, 속에, 영원히, 기억될, 최고의)} P(명작이다∣내,마음,속에,영원히,기억될,최고의)=Freq(내,마음,속에,영원히,기억될,최고의)Freq(내,마음,속에,영원히,기억될,최고의,명작이다)​ 그러나 우변의 분자가 0이라서 전체 값은 0이된다. 앞에서 배운 n-gram을 사용해보자. 직전 n-1개 단어의 등장 확률로 전체 단어 시퀀스 등장 확률을 근사하는 것이다. 이말을 다시 해석하면 한 상태** state**의 확률은 그 직전 상태에만 영향을 받는 것이다. 마코프 가정 Markov assumption에 기반한 것이다. P(명작이다∣내,마음,속에,영원히,기억될,최고의)≈P(명작이다∣최고의)=Freq(최고의,명작이다)Freq(최고의)P(명작이다|내, 마음, 속에, 영원히, 기억될, 최고의) ≈ P(명작이다|최고의)={ Freq(최고의, 명작이다) \\over Freq(최고의)} P(명작이다∣내,마음,속에,영원히,기억될,최고의)≈P(명작이다∣최고의)=Freq(최고의)Freq(최고의,명작이다)​ 처럼 전 상황에 대해서만 영향을 주는 것이다. 다시말해 명작이다 라는 직전의 1개 단어만 보고 전체 단어 시퀀스 등장 확률을 근사한 것이다. 좀 더 늘려서 끝까지 계산하게 되면 다음과 같다. P(내,마음,속에,영원히,기억될,최고의,명작이다)≈P(내)∗P(마음∣내)∗P(속에∣마음)∗P(영원히∣속에)∗P(기억될∣영원히)∗P(최고의∣기억될)∗P(명작이다∣최고의)P(내, 마음, 속에, 영원히, 기억될, 최고의, 명작이다) ≈ P(내)*P(마음|내)*P(속에|마음)*P(영원히|속에)*P(기억될|영원히)*P(최고의|기억될)*P(명작이다|최고의) P(내,마음,속에,영원히,기억될,최고의,명작이다)≈P(내)∗P(마음∣내)∗P(속에∣마음)∗P(영원히∣속에)∗P(기억될∣영원히)∗P(최고의∣기억될)∗P(명작이다∣최고의) 일반화를 시킨다면 다음과 같다. 바이그램모델에서는 1개만 참고하지만 일반화를 시키면 전체 단어 시퀀스 등장 확률 계산시 직전 n-1개 단어의 히스토리를 본다 P(Wn∣W(n−1)=Freq(W(n−1,W(n))Freq(W(n−1))P(Wn|W(n-1) = { Freq(W(n-1,W(n)) \\over Freq(W(n-1))} P(Wn∣W(n−1)=Freq(W(n−1))Freq(W(n−1,W(n))​ 그러나 데이터에 한 번도 등장하지 않는 n-gram이 존재할 때 예측 문제가 발생할 수 있다. 처음 보는 단어를 본다면 그 확률은 0으로 보기 때문이다. 이를 위해서 백오프** back-off**, 스무딩 ** smoothing**등의 방식이 제안된다. 백오프란 n-gram등장 빈도를 n보다 작은 범위의 단어 시퀀스 빈도로 근사하는 방식인데, n을 크게 하면 할 수록 등장하지 않은 케이스가 많아질 가능성이 높기 때문이다. 내 마음 속에 영원히 기억될 최고의 명작이다는 7-gram에서는 0이지만 N을 4로 내린다면 달라진다. 스무딩이란 등장 빈도 표에 모두 K만큼 더하는 것이다. 높은 빈도를 가진 문자열 등장 확률을 일부 깎고 학습 데이터에 전혀 등장하지 않은 케이스들에는 일부 확률을 부여하게 된다. 2.3.2 뉴럴 네트워크 기반 언어 모델 뉴럴 네트워크는 입력과 출력 사이의 관계를 유연하게 포착해낼 수 있고, 그 자체로 확률 모델로 기능이 가능하기 때문에 뉴럴 네트워크로 사용한다. 1발 없는 말이 -&gt; [언어모델] -&gt; 천리 뉴럴 네트워크 기반 언어 모델은 위 그림처럼 단어 시퀀스를 가지고 다음 단어를 맞추는 과정에서 학습된다. 학습이 완료되면 이들 모델의 중간 혹은 말단 계산 결과물을 단어나 문장의 임베딩으로 활용한다. 대표적인 모델은 다음과 같다. ELMo GPT 마스크 언어 모델 ** masked language model**은 언어 모델 기반 기법과 큰 틀에서 유사하지만 디테일에서 차이가 잇다. 문장 중간에 '마스크’를 씌워 놓고 해당 위치에 어떤 단어가 올지 예측하는 과정을 학습한다. 대게 언어 모델 기반 기법은 단어를 순차적으로 입력받아 다음 단어를 맞춰야하기 때문에 태생적으로 일방향 ** uni-directional이다. 하지만 마스크 언어 모델 기반 기법은 문장 전체를 보고 중간을 예측하기 때문에 양방향 ** bi-directional학습이 가능하다. 대표적인 모델은 다음과 같다. BERT","link":"/2020/04/02/KoreanEmbedding/%EB%8B%A8%EC%96%B4%EA%B0%80%EC%96%B4%EB%96%A4%EC%88%9C%EC%84%9C%EB%A1%9C%EC%93%B0%EC%98%80%EB%8A%94%EA%B0%80/"},{"title":"1장정리","text":"1.6 1장의 요약 임베딩이란 자연어를 기계가 이해할 수 있는 숫자의 나열인 벡터로 바꾼 결과 혹은 그 일련의 과정 전체를 가리킴 임베딩을 사용하면 단어/문장 간 관련도를 계산할 수 있음 임베딩에는 믜미적/문법적 정보가 함축돼 있음 임베딩은 다른 딥러닝 모델의 입력값으로 쓰일 수 있음 임베딩 기법은 (1) 통계 기반에서 뉴럴 네트워크 기반으로 (2) 단어 수준에서 문장 수준으로 (3) 엔드투엔드에서 프리트레인/파인 튜닝 방식으로 발전해옴 임베딩 기법은 크게 행렬 분해 모델, 에측 기반 방법, 토픽 기반 기법 등으로 나눠짐 이 책이 다루는 데이터의 최소 단위는 토큰임. 문장은 토큰의 집합, 문서는 문장의 집합, 말뭉치는 문서의 집합을 가리킴. 말뭉치 &gt; 문서 &gt; 문장 &gt; 토큰. 어휘 집합은 말뭉치에 있는 모든 문서를 문장으로 나누고 여기에 토크나이즈를 실시한 후 중복을 제거한 토큰들의 집합임","link":"/2020/03/31/KoreanEmbedding/1%EC%9E%A5%EC%A0%95%EB%A6%AC/"},{"title":"2장요약","text":"2.5 2장 요약 벡터가 어떻게 의미를 가지게 되는가 임베딩에 자연어의 통계적 패턴 정보를 주면 자연어의 의미를 함축할 수 있다. 백오브워즈 가정에서는 어떤 단어의 등장 여부 혹은 그 빈도 정보를 중시한다. 백오브워즈 가정의 대척점에는 언어 모델이 있다. 언어 모델은 단어의 등장 순서를 학습해 주어진 단어 스퀀스가 얼마나 자연스러운지 확률을 부여한다. 분포 가정에서는 문장에서 어떤 단어가 같이 쓰였는지를 중요하게 따진다. 말뭉치의 통계적 패턴을 서로 다른 각도에서 분석하는 것이며 상호 보완적이다.","link":"/2020/04/02/KoreanEmbedding/2%EC%9E%A5%EC%9A%94%EC%95%BD/"},{"title":"어떤단어가같이쓰였는가","text":"2.4 어떤 단어가 같이 쓰였느가 2.4.1 분포 가정 자연어 처리에서 분포 distribution란 특정 범위, 즉 윈도우 내에 동시에 등장하는 이웃 단어 또는 문맥의 집합을 가리킨다. 개별 단어의 분포는 그 단어가 문장 내에서 주로 어느 위치에 나타나는지, 이웃한 위치에 어떤 단어가 자주 나타나는지에 따라 달라진다. 어떤 쌍이 비슷한 문맥 환경에서 자주 등장한다면 그 의미 도한 유사할 것이라는 게 분포 가정 ** distributional hypothesis**의 전제다. 예컨데 한국어의 빨래, 세탁이라는 단어의 의미를 전혀 모른다고 하자. 두 단어의 의미를 파악하기 위해서는 이들 단어가 실제 어떻게 쓰이고 있는지 관찰을 해야한다. 두 단어는 타깃 단어 ** target word**이고 청소, 물 등은 그 주위에 등장한 문맥 단어가 된다 특기는 자칭 청소와 빨래지만 요리는 절망적 재를 우려낸 물로 빨래 할 때 나 찬 물로 옷을 세탁한다. 세탁, 청소, 요리와 기사는 이웃한 단어들이 서로 비슷하기 때문이다. 빨래가 청소 물 과 같이 등장하는 경향을 미루어 짐작해볼 때 이들끼리도 직간접적으로 관계를 지닐 가능성이 낮아보이지는 않는다. 그럼에도 개별 단어의 분포 정보와 그 의미 사이에는 논리적으로 직접적인 연관성은 사실 낮다. 다시 말해 분포 정보가 곧 의미라는 분포 가정에 의문접이 발생한다. 2.4.2 분포와 의미(1) : 형태소 형태소** morpheme란 의미를 가지는 최소 단위를 말한다. 더 쪼개면 의미를 잃어버리는 것이다. 예를 들어 철수가 밥을 먹었다 라고 한다면 형태소 후보는 철수, 밥, 이다. 조금 더 깊게 분석해보자. 계열관계 ** paradigmatic relation가 있다. 계열 관계는 해당 형태소 자리에 다른 형태소가 '대치’되어 쓰일 수 있는 가를 따지는 것이다. 예컨데 철수 대신에 영희가 올 수 있고 밥대신 빵을 쓸 수 있다. 이를 근거로 형태소 자격을 부여한다. 특정 타깃 단어 주변의 문맥 정보를 바탕으로 형태소를 확인한다는 이야기와 일맥상통한다. 말뭉치의 분포 정보와 형태소가 밀접한 관계를 이루고 있다. 2.4.3 분포와 의미(2) : 품사 품사란 단어를 문법적 성질의 공통성에 따라 언어학자들이 몇 갈래로 묶어 놓은 것이다. 기능 의미 형식 위 세가지를 기준으로 분류한다. 기능 한 단어가 문장 가운데서 다른 단어와 맺는 관계를 가르킨다. 깊이 높이는 문장에서 주어로 쓰이고 깊다 높다는 서술어로 사용되고 있다. 의미 단어의 형식적 의미를 나타낸다. ``깊이높이를 하나로 묶고깊다높다`를 같은 군집으로 넣을 수 있다. 품사에서는 어휘적 의미보다 형식적 의미가 중요하다. 다시말해 어떤 단어가 사물의 이름을 나타내는가, 그렇지 않으면 움직임이나 성실, 상태를 나타내느냐 하는 것이다. 형식 단어의 형태적 특징을 의미한다. 깊이 높이는 변화하지 않는다. 깊었다 높았다 깊겠다 높겠따 따위와 같이 어미가 붙어 여러 가지 모습으로 변화를 일으킬 수 있다. 그러나 예외가 있다. 공부 공부하다 두 개를 분류하려면 공부는 명사이지만 우리는 동작이라는 여지를 알고 있다. 품사 분류에서 가장 중요한 기준은 기능이다. 해당 단어가 문장 내에서 점하는 역할에 초점을 맞춰 품사를 분류한다는 것이다. 형태소의 경계를 정하거나 품사를 나누는 것과 같은 다양한 언어학적 문제는 말뭉치의 분포 정보와 깊은 관계를 갖고 있다. 이로인하여 분포 정보를 함축한다면 해당 벡터에 해당 단어의 의미를 자연스레 내재시킬 수 있는 것이다. 2.4.4 점별 상호 정보량 점별 상호 정보량은 두 확률변수사이의 상관성을 계량화하는 단위다. 두 확률변수가 완전히 독립인 경우 그 값이 0이 된다. 독립이라고 하면 A가 나타나는 것이 단어 B의 등장할 확률에 전혀 영향을 주지 않고, 단어 B등장이 단어 A에 영향을 주지 않는 경우를 가리킨다. 두 단어의 등장이 독립일 때 대비해 얼마나 자주 같이 등장하는지를 수치화한 것이다 PMI(A,B)=logP(A,B)P(A)∗P(B)PMI(A,B) = log{P(A,B) \\over P(A)*P(B)} PMI(A,B)=logP(A)∗P(B)P(A,B)​ PMI 행렬의 행 벡터 자체를 해당 단어의 임베딩으로 사용할 수도 있다.","link":"/2020/04/02/KoreanEmbedding/%EC%96%B4%EB%96%A4%EB%8B%A8%EC%96%B4%EA%B0%80%EA%B0%99%EC%9D%B4%EC%93%B0%EC%98%80%EB%8A%94%EA%B0%80/"},{"title":"데이터와주요용어","text":"1.5 이 책이 다루는 데이터와 주요 용어 텍스트(text) 말뭉치(corpus) : 텍스트 데이터 표본(Sample) : 특정한 목적을 가지고 수집한 말뭉치 컬렉션(collection) : 말뭉치에 속한 각각의 집합 문장(sentence) : 이 책에서 다루는 데이터의 기본 단위, 마침표나 느낌표, 물음표와 같은 기호로 구분된 문자열 문서(document), 단락(paragraph)의 집합 : 생각이나, 감정, 정보를 공유하는 문장의 집합, 줄바꿈(\\n) 문자로 구분된 문자열 토큰(token), 단어(word), 형태소(morpheme), 서브워드(subword) : 이 책에서 다루는 가장 작은 단위 토크나이즈(tokenize) : 문장을 토큰 시쿼스로 분석하는 과정, 토큰 시퀀스는 문장을 토큰으로 나누는 것, 토큰 구분자는 쉼표를 주로 사용 어휘 집합(vocabulary) : 말뭉치에 있는 모든 문서를 문장으로 나누고 여기에 토크나이즈를 실시한 후 중복을 제거한 토큰들의 집합 미등록 단어(unknown word) : 어휘 집합에 없는 토큰","link":"/2020/03/31/KoreanEmbedding/%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%99%80%EC%A3%BC%EC%9A%94%EC%9A%A9%EC%96%B4/"},{"title":"어떤단어가많이쓰였는가","text":"2.2 어떤 단어가 많이 쓰였는가 2.2.1 백오브워즈 가정 수학에서 백이란 중복 원소를 허용한 집합 multiset을 뜻한다. 원소의 순서는 고려하지 않는다. 어쩌면 중복 집합과 같다. 자연어 처리 분야에서는 백오브워즈 bag of words란 단어의 등장 순서에 관계없이 문서 내 단어의 등장 빈도를 임베딩으로 쓰는 기법 문장을 단어들로 나누고 이들을 중복집합에 넣어 임베딩으로 활용하는 것 저자가 생각한 주제가 문서에서의 단어 사용에 녹아 있을 것 주제가 비슷한 문서라면 단어 빈도 또는 단어 등장 역시 비슷하 것 빈도를 그대로 백오브워즈로 쓴다면 많이 쓰인 단어가 주제와 더 강한 관련을 맺고 있을 것 위 처럼 문장을 단어로 쪼개고 임의의 주머니에 넣고 뽑았을 때 등장하면 1 아니면 0을 반영한 것이다. 백오브워즈 임베딩은 단순하지만 정보 검색 ** Information Retrieval분야에서 많이 쓰인다. 사용자의 질의 ** query에 가장 적절한 문서를 보여줄 때 질의를 백오브워즈 임베딩으로 변환하고 질의와 검색 대상 문서 임베딩 간 코사인 유사도를 구해 유사도가 가장 높은 문서를 사용자에게 노출한다. 2.2.2 TF-IDF 단어 빈도 또는 등장 여부를 그대로 임베딩으로 쓰는 것에는 단점이 있다. 해당 단어가 많이 나왔다고 하더라도 문서의 주제를 가늠하기 어렵다. 이유는 다음과 같다. ‘을/를’, ‘이/가’ 같은 조사들이 한국어 문서에 등장한다. 이 것으로 문서의 주제를 추측하기 어렵다. 이런 단점을 보완하기 위해서 Term Frequency-Inverse Document Frequency이다. 단어-문서 행렬에 가중치를 계산해 행렬 원소를 바꾼다. 이 또한 단어 등장 순서는 고려하지 않는다. 위 수식을 자세히 알아보자 TF는 어떤 단어가 특정 문서에 얼마나 많이 쓰였는지 빈도를 나타낸다. A라는 단어가 문서1에 10번, 문서2에 5번 쓰였다면 문서1 - 단어A의 TF는 10, 문서2 - 단어A의 TF는 5 DF란 특정 단어가 나타난 문서의 수를 뜻한다. 문서1과 문서2에만 A가 등장했으므로 DF는 2D DF가 클수록 다수 문서에 쓰이는 범용적 단어이다 IDF는 전체 문서 수를 해당 단어의 DF로 나눈 뒤 로그를 취한 값이다. 그 값이 클수록 특이한 단어이다. 주제 예측 능력과 직결된다 결국 TF-IDF는 어떤 단어의 주제 예측 능력이 강할 수록 가중치가 커지고 그 반대의 경우 작아진다 어떤 단어의 TF가 높으면 TF-IDF 값 역시 커진다 단어 사용 빈도는 저자가 상정한 주제와 관련을 맺고 있을 거라는 가정에 기초한 것이다 2.2.3 Deep Averaging Network Deep Averaging Network는 백오브워즈 가정의 뉴럴 네트워크 버전이다. 예를 들어 애비는 종이었다 라는 문장이 있다면 {애비, 종, 이, 었, 다}에 속한 단어의 임베딩을 평균을 취해 만든다. 문장 내에 어떤 단어가 쓰였는지, 쓰였다면 얼마나 많이 쓰였는지 그 빈도만을 고려한다. 문장 임베딩을 입력받아 해당 문서가 어떤 범주인지 분류 classifiation 한다.","link":"/2020/03/31/KoreanEmbedding/%EC%96%B4%EB%96%A4%EB%8B%A8%EC%96%B4%EA%B0%80%EB%A7%8E%EC%9D%B4%EC%93%B0%EC%98%80%EB%8A%94%EA%B0%80/"},{"title":"엑셀 수식 사용 - 2강. 함수 사용법","text":"2.함수 사용법 함수 함수의 형태 함수명() 괄호 내부에는 변수(or 인자) 사용 변수 변수에는 상수, 주소, 범위, 이름, 함수 등 사용 변수 없는 함수 존재 ex) TODAY(), PI() 함수는 수식의 일부분 엑셀에는 400개 이상의 함수 존재 직접만들기도 가능 함수 입력방법 수동 입력 방식 ‘=’ 과 함수명 입력 후 괄호열기 입력 함수명 입력 중 아래 리스트에서 선택 후 탭 키 입력 빠른 함수 입력 [수식] 리본메뉴 - ‘함수라이브러리’ [홈] 리본메뉴 - [자동합계] FX 메뉴 OR Shift-F3 입력 함수마법사 함수 구문 이해 변수 구분 굵은 글씨 : 현재 입력 중인 변수 위치 대괄호[] : 필수가 아닌 옵션 “…” : 변수를 더 사용 가능 자주 쓰는 변수 표기 number : 숫자 range : 범위 crieria : 조건문 lookup_value : 찾을값 lookup_array : 찾을 범위 logical_test : 논리비교 text : 문자열 num_chars : 글자수 셀 참조(references) 상대참조 기본 참조방식 수식을 복사하면, 수식 내 셀 주소가 행과 열 방향으로 이동한 만큼 셀 주소가 변함 절대참조 행과 열 주소 앞에 “$” 문자 표시 절대 참조는 수식에 복사되어도 참조 위치는 변화 없음 혼합참조 행과 열 주소 둘 중 한 군데 앞에 “$” 표시 상대참조와 절대참조가 혼합 “F4” 상대참조 -&gt; 절대참조 -&gt; 혼합참조(행) -&gt; 혼합참조(열) -&gt; 상대참조 함수 에러 메시지 DIV/0! 수식에 0으로 나누는 내용이 있음, 대게 분모 값에 빈셀이 지정됨 NAME? : 수식 엑셀에 인식할 수 없는 이름이 사용됨, 대게 이름이 지워지거나 텍스트 입력시 큰따옴표 오류 N/A : 수식에 사용할 수 없는 데이터가 지정된 경우, 일부함수에서 오류 NULL! : 수식이 교집합이 없는 두 범위의 교집합을 설정함 NUM! : 값 에러, 양이 되어야하는 값에 음의 값이 입력될 때 REF! : 수식이 참조할수 없는 셀을 지정할 때, 워크시트 내에 삭제된 셀이 사용될 때 VALUE! : 수식에 잘못된 형태의 변수나 숫자가 포함되어 있을 때","link":"/2020/04/16/DataScience/%EC%97%91%EC%85%80%EC%88%98%EC%8B%9D%EC%82%AC%EC%9A%A9-2%EA%B0%95%ED%95%A8%EC%88%98/"},{"title":"임베딩기법의역사와종류","text":"1.3 임베딩 기법의 역사와 종류 1.3.1 통계 기반에서 뉴럴 네트워크 기반으로 초기 임베딩 기법은 대부분 말뭉칭의 통계량을 직접 활용했다. 대표적으로 잠재 의미 분석 ** Latent Semantic Analysis**이다. 잠재 의미 분석 잠재 의미 분석이란 단어 사용 빈도 등 말뭉치의 통계량 정보가 들어 있는 커다란 행렬 ** Matrix에 특이값 분해 ** Singular Value Decomposition등 수학적 기법을 적용해 행렬에 속한 벡터들의 차원을 축소하는 방법 단어-문서 행렬에 잠재 의미 분석을 적용했다고 가정하자. 그런데 단어-문서 행렬을 행의 개수가 매우 많다. 어휘 수는 대개 10~20만 개일 것이다. 행렬의 대부분 요소 값은 0이다. 문서 하나에 모든 어휘가 쓰이는 경우는 매우 드물다. 이렇게 대부분의 요소 값이 0인 행렬을 희소 행렬 ** sparse matrix**이라고 한다. 이런 희소 행렬을 다른 모델의 입력값으로 쓰게 되면 계산량도 메모리 소비량도 쓸데없이 커진다. 그래서 원래 행렬의 차원을 축소해 사용한다. 단어와 문서를 기준으로 줄인다. 잠재 의미 분석 행렬 수행 대상 행렬은 여러 종류가 될 수 있다. TF-IDF 행렬 단어-문맥 행렬 점별 상호 정보량 행렬 최근에는 뉴럴 네트워크 기반의 임베딩 기법들이 주목받고 있다. 이전 단어들이 주어졌을 때 다음 단어가 뭐가 될지 예측하거나 문장 내 일부분에 구멍을 뚫어 놓고 해당 단어가 무엇일지 맞추는 과정에서 학습된다. 1.3.2 단어 수준에서 문장 수준으로 2017년 이전의 임베딩 기법들은 대게 단어 수준 모델이었다. NPLM, Word2Vec, Glove, FastText, Swivel 등이 있다. 단어 수준 임베딩 기법의 단점은 동음이의어 ** homonym을 구분하기 어렵다. 단어 형태가 같다면 동일한 단어로 보고, 문맥 정보를 해당 단어 벡터에 전달하기 때문이다. 다행히도 ELMoEmbeddings from Language Modles**가 발표된 후 문장 수준 임베딩 기법이 주목받았다. 1.3.3 룰 -&gt; 엔드투엔드 -&gt; 프리트레인/파인 튜닝 1990년 : 사람이 피처를 직접 뽑음 2000년 중반 : 딥러닝 모델 주목, 입출력의 관계를 사람의 개입 없이 모델 스스로 처음부터 끝까지 이해하도록 유도 2018년 : 말뭉치로 임베딩을 만듬, 구체적 문제에 맞는 소규모 데이터에 맞게 임베딩을 포함한 모델 전체를 업데이트함 다운스트림 태스크 ** Downstream task** 품사판별 ** Part-of Speech tagging** 개체명 인식 ** Named Entity Recognition** 의미역 분석 ** Semantic Role Labeling** ######예시 품사 판별 : 나는 네가 지난 여름에 한 [일]을 알고 있다. → 일: 명사(Noun) 문장 성분 분석 : 나는 [네가 지난 여름에 한 일]을 알고 있다. → 네가 지난 여름에 한 일 : 명사구(Noun Phrase) 의존 관계 분석 : [자연어 처리는] 늘 그렇듯이 [재미있다]. → 자언어 처리는, 재미있다 : 주격명사구(Nsub) 의미역 분석 : 나는 [네가 지난 여름에 한 일]을 알고 있다. → 네가 지난 여름에 한 일 : 피행위주역(Patient) 상호 참조 해결 : 나는 어제 [성빈이]를 만났다. [그]는 스웨터를 입고 있었다. → 그=성빈이 업스트림 태스크 ** Upstream task** 단어/문장 임베딩을 프리트레인하는 작업 1.3.4 임베딩의 종류와 성능 임베딩 기법 행렬 분해 예측 토픽 기반 행렬 분해 기반 방법 말뭉치 정보가 들어 있는 원래 행렬을 두 개 이상의 작은 행렬로 쪼개는 방식의 임베딩 기법 분해한 이후에 둘 중 하나의 행렬만 쓰거나 둘을 add 하거나 concatenate 임베딩으로 사용 예측 기반 방법 어떤 단어 주변에 특정 단어가 나타날지 예측하거나, 이전 단어들이 주어졌을 때 다음 단어가 무엇일지 예측하거나, 문장 내 일부 단어를 지우고 해당 단어가 무엇일지 맞추는 과정에서 학습 토픽 기반 방법 주어진 문서에 잠재된 주제를 추론** inference**하는 방식으로 임베딩을 수행 모델은 학습이 완료되면 각 문서가 어떤 주제 분포를 갖는지 확률 벡터 형태로 반환 하기 때문에 가능 임베딩 성능 평가 성능 측정 대상 다운스트림 태스크는 형태소 분석, 문장 성분 분석, 의존 관계 분석, 의미역 분석, 상호 참조 해결 등이다. 안타깝겓게도 한국어는 공개된 데이터가 많지 않아 높은 품질 측정을 기대하긴 어렵다.","link":"/2020/03/30/KoreanEmbedding/%EC%9E%84%EB%B2%A0%EB%94%A9%EA%B8%B0%EB%B2%95%EC%9D%98%EC%97%AD%EC%82%AC%EC%99%80%EC%A2%85%EB%A5%98/"},{"title":"한국어임베딩-임베딩의역할","text":"1.2 임베딩의 역할 임베딩은 다음 역할을 수행할 수 있다 단어/문장 간 관련도 계산 의미적/문법적 정보 함축 전이 학습 1.2.1 단어/문장 간 관련도 계산 현업에서는 2013년 구글 연구 팀이 발표한 Word2Vec이라는 기법이 대표적이다. 단어들을 벡터로 바꾸는 방법이다. 한국어 위키백과, KorQuAD, 네이버 영화 리뷰 말뭉치 등은 은전한닢으로 형태소 분석을 한 뒤 100차원으로 학습한 Word2Vec 임베딩 중 희망 이라는 단어의 벡터는 다음과 같다 [-0.00209 -0.03918 0.02419 … 0.01715 -0.04975 0.009300] 위 수식의 숫자들은 모두 100개이다. 100차원으로 임베딩을 했기 때문이다. 단어를 벡터로 임베딩하는 순간 단어 벡터들 사이의 유사도 similarity를 계산하는 일이 가능해진다. 각 쿼리 단어별로 벡터 간 유사도 측정 기법의 일종인 코사인 유사도 cosine similarity 기준 상위 4개 희망 절망 학교 학생 소망 체념 초등 대학생 희망찬 절망감 중학교 대학원생 꿈 상실감 야학교 교직원 열망 번민 중학 학부모 희망과 코사인 유사도가 가장 높은 것은 소망이다. 자연어일 때는 불가능했던 코사인 유사도 계산이 임베딩 덕분에 가능해 졌다. 다음은 Word2Vec 임베딩을 통해서 단어 쌍 간 코사인 유사도를 시각화 한 것이다. 검정색일 수록 코사인 유사도가 높다 입베딩을 수행하면 벡터 공간을 기하학적으로 나타낸 시각화 역시 가능하다 1.2.2 의미/문법 정보 함축 입베딩은 벡터인 만큼 사칙연산이 가능하다. 단어 벡터간 덧셈/뺄셈을 통해 단어들 사이의 의미적, 문법적 관계를 도출해낼 수 있다. 단어 유추 평가 word analogy test 단어1 - 단어2 + 단어3 연산을 수행한 벡터와 코사인 유사도가 가장 높은 단어4를 배열한다 단어1 단어2 단어3 단어4 아들 딸 소년 소녀 아들 딸 아빠 엄마 아들 딸 남성 여성 남동생 여동생 소년 소녀 남동생 여동생 아빠 엄마 1.2.3 전이학습 임베딩은 다른 딥러닝 모델의 입력값으로 자주 쓰인다. 문서 분류를 위한 딥러닝 모델을 만든다. 예컨데 품질 좋은 임베딩을 쓰면 문서 분류 정확도와 학습 속도가 올라간다. 이렇게 임베딩을 다른 딥러닝 모델의 입력값으로 쓰는 기법을 전이 학습 transfer learning 이라고 한다. 전이학습 전이 학습 모델은 제로부터 시작하지 않는다. 대규모 말뭉치를 활용해 임베딩을 미리 만들어 놓는다. 임베딩에는 의미적, 문법적 정보 등이 있다. 문장의 극성을 예측하는 모델 양방향 LSTM에 어텐션 메커니즘을 적용 bidirectional Long Short-Term Memory, Attention 이 딥러닝의 모델의 입력값은 FastText 임베딩(100차원)을 사용했다. FastText 임베딩은 Word2Vec의 개선된 버전이며 59만 건에 이르는 한국어 문서를 미리 학습한 모델 학습 데이터는 다음과 같다 이 영화 꿀잼 + 긍정 positive 이 영화 노잼 + 부정 negative 전이 학습 모델은 문장을 입력받으면 해당 문장이 긍정인지 부정인지를 출력한다. 문장을 형태소 분석한 뒤 각각의 형태소에 해당하는 FastText 단어 임베딩이 모델의 입력값이 된다. 위의 그래프로 처음 부터 하는 것 보다 FastText 임베딩을 사용한 모델의 성능이 좋다. 즉, 임베딩의 품질이 좋으면 수행하려는 Task의 성능 역시 올라간다. 왜 임베딩이 중요한지 깨달았다","link":"/2020/03/29/KoreanEmbedding/%EC%9E%84%EB%B2%A0%EB%94%A9%EC%9D%98%EC%97%AD%ED%95%A0/"},{"title":"환경소개","text":"1.4.1 환경소개 Ubuntu 16.04.5 Python 3.5.2 Tensorflow 1.12.0 도커 구성하기 본인은 Synology NAS를 사용하고 있으므로 NAS에서 docker 환경을 구성하는 방법을 포스팅하려고 한다. 혹 NAS가 없는 경우 책에는 AWS로 하는 방법을 소개했으니 참고하자. 도커이미지 123$ uname -a #ubuntu 환경 확인$ pwd #위치 확인$ cd /home #home으로 이동 1234root@docker-NLG:/# apt upgrade root@docker-NLG:/# apt update root@docker-NLG:/# apt install python3.5.2root@docker-NLG:/# apt install python3-pip pip3 라고 command에 쳤을 때 뭐라뭐라 길게 나오면 성공! 더 정확하게 확인하려면 12root@docker-NLG:/# pip3 --version pip 9.0.1 from /usr/lib/python3/dist-packages (python 3.6) 123root@docker-NLG:/# pip3 install --upgrade piproot@docker-NLG:/# pip --version pip 20.0.2 from /usr/local/lib/python3.6/dist-packages/pip (python 3.6) 도커 다운을 위한 패키지 설치 안된다면 앞에 sudo를 붙여보시길… 1234apt install apt-transport-https apt install ca-certificatesapt install curl apt install software-properties-common apt-transport-https : 패키지 관리자가 https를 통해 데이터 및 패키지에 접근할 수 있도록 한다. ca-certificates : ca-certificate는 certificate authority에서 발행되는 디지털 서명. SSL 인증서의 PEM 파일이 포함되어 있어 SSL 기반 앱이 SSroot@docker-NLG:/# pip3 --version L 연결이 되어있는지 확인할 수 있다. curl : 특정 웹사이트에서 데이터를 다운로드 받을 때 사용 software-properties-common : *PPA를 추가하거나 제거할 때 사용한다. curl 명령어로 도커 다운받기 &amp;&amp; repository에 경로 추가하기 1234root@docker-NLG:/# curl -fsSL https://download.docker.com/linux/ubuntu/gpg | apt-key add - OK root@docker-NLG:/# add-apt-repository &quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu bionic stable&quot; curl 명령어의 옵션 f : HTTP 요청 헤더의 contentType을 multipart/form-data로 보낸다. s : 진행 과정이나 에러 정보를 보여주지 않는다.(–silent) S : SSL 인증과 관련있다고 들었는데, 정확히 아시는 분 있다면 댓글 부탁! L : 서버에서 301, 302 응답이 오면 redirection URL로 따라간다. apt-key : apt가 패키지를 인증할 때 사용하는 키 리스트를 관리한다. 이 키를 사용해 인증된 패키지는 신뢰할 수 있는 것으로 간주한다. add 명령어는 키 리스트에 새로운 키를 추가하겠다는 의미이다. add-apt-repository : PPA 저장소를 추가해준다. apt 리스트에 패키지를 다운로드 받을 수 있는 경로가 추가된다. docker 패키지가 검색되는지 확인 1234root@docker-NLG:/# apt-get update root@docker-NLG:/# apt-cache search docker-ce docker-ce-cli - Docker CLI: the open-source application container engine docker-ce - Docker: the open-source application container engine apt update : 저장소의 패키지 갱신 도커 설치하기 &amp;&amp; ubuntu를 도커그룹으로 입력 123root@docker-NLG:/# apt-get install docker-ceroot@docker-NLG:/# usermod -aG docker $USER Usage: usermod [options] LOGIN nvidia-docker 설치 위의 단계까지 끝내면 일반적인 도커 기능들을 이용하실 수 있습니다. 하지만 NVIDIA의 GPU를 이용하시면서 여러 환경의 CUDA Tookit을 이용하실 경우 nvidia-docker라는 확장 기능을 추가하시면 보다 편리하게 사용하실 수 있습니다. nvidia-docker를 설치하고자 하실 경우 호스트 운영체제에 먼저 NVIDIA 드라이버가 설치되어 있어야 합니다. NVIDIA의 그래픽카드 또는 GPU를 사용하지 않는 경우 이 과정을 진행하고 도커 설치과정을 끝내실 수 있습니다. 우분투에서 NVIDIA 드라이버 설치 방법 12345678910root@docker-NLG:/# curl -s -L https://nvidia.github.io/nvidia-docker/gpgkey|apt-key add - OKroot@docker-NLG:/# distribution=$(. /etc/os-release;echo $ID$VERSION_ID) root@docker-NLG:/# curl -s -L https://nvidia.github.io/nvidia-docker/$distribution/nvidia-docker.list|tee /etc/apt/sources.list.d/nvidia-docker.list deb https://nvidia.github.io/libnvidia-container/ubuntu18.04/$(ARCH) / deb https://nvidia.github.io/nvidia-container-runtime/ubuntu18.04/$(ARCH) / deb https://nvidia.github.io/nvidia-docker/ubuntu18.04/$(ARCH) /root@docker-NLG:/# apt-get update nvidia-docker 실행 우분투에서 nvidia-driver받기 1234root@docker-NLG:/# apt-get install -y nvidia-container-toolkitroot@docker-NLG:/# apt-get install systemdroot@docker-NLG:/# systemctl restart dockerroot@docker-NLG:/# docker run --gpus all nvidia/cuda:9.0-base nvidia-smi 도커실행하기 1root@docker-NLG:/home# git clone https://github.com.rastgo/embedding 참고 링크 오픈소스링크 TensorFlow : https://www.tensorflow.org Gensim : https://radimrehurek.com/gensim FastText : https://fasttext.cc GloVe : https://nlp.stanford.edu/projects/glove Swivel : https://github.com/tensorflow/models/tree/master/research/swivel ELMo : https://allennlp.org/elmo BERT : https://github.com/google-research/bert Scikit-Learn : https://scikit-learn.org KoNLPy : http://konlpy.org/en/latest/ Mecab : http://eunjeon.blogspot.com/ soynlp : https://github.com/lovit/soynlp Khaiii : https://github.com/kakao/khaiii https://tech.kakao.com/2018/12/13/khaiii/ Bokeh : https://docs.bokeh.org/ sentencepiece : https://github.com/google/sentencepiece","link":"/2020/03/30/KoreanEmbedding/%ED%99%98%EA%B2%BD%EC%86%8C%EA%B0%9C/"},{"title":"한국어임베딩-임베딩이란","text":"한국어임베딩github 한국어 임베딩 서적을 공부하며 정리하는 글이 되겠습니다. 1.1 임베딩이란? 기계의 자연어 이해와 생성은 연산 Computation 과 처리 Processing의 영역이다 자연어처리분야에서의 임베딩이란 사람이 쓰는 자연어를 기계가 이해할 수 있는 숫자의 나열인 벡터 vector로 바꾼 결과 혹은 그 일련의 과정 전체를 의미한다. 단어나 문장 각각을 벡테로 변환해 벡터공간 vector space으로 '끼워 넣는다embed 는 의미에서 임베딩이라고 지었다. 단어-문서 행렬 Term-Document Matrix 구분 메밀꽃 필 무렵 운수좋은 날 사랑 손님과 어머니 삼포 가는길 기차 0 2 10 7 막걸리 0 1 0 0 선술집 0 1 0 0 위 와 같은 빈도표를 단어-문서 행렬이라고 부른다. row는 단어, column은 문서(작품)에 대응한다. 운수좋은 날의 문서의 임베딩은 [2,1,1]이다. 막걸리라는 단어의 임베딩은 [0,1,0,0] 이다. 표를 보면 ‘사랑 손님과 어머니’, '삼포 가는 길’이 사용하는 단어 목록이 상대적으로 많이 겹침을 알 수 있다. 일르 바탕으로 '사랑 손님과 어머니’는 ''삼포 가는 길’과 '기차’라는 소재를 공유한다는 점에서 비슷한 작품임을 추정할 수 있다.","link":"/2020/03/29/KoreanEmbedding/%EC%9E%84%EB%B2%A0%EB%94%A9%EC%9D%B4%EB%9E%80/"},{"title":"Background of NLP","text":"Basic Concept of Machine Learning 예를 들어 호랑이와 고양이를 예측하는 인공지능을 만들고 싶다라고 한다면 모델입장에서는 두가지가 필요하다 호랑이이미지 = 호랑이레이블 고양이이미지 = 고양이레이블 이렇게 레이블 정보(With Labels)를 활용해서 학습하는 것을 Supervised Learning 지도학습 이라고 한다 반면, 레이블 정보 없이(No Labels) 이미지만을 활용해서 하는 것을 Unsupervised Learning 비지도학습 이라고 한다 레이블정보가 아니라 입력이미지에 대해서 잘 분류하였으면 +1점, 잘 분류하지 못했으면 -1점 처럼 리워드를 주는 방식(With Rewards)을 Reinforcement Learning 강화학습 이라고 한다 Machine Learning Supervised Learning Regression : 수치형, 회기, 아파트가격/주가예측 Classification : 카테고리컬 variable, 클래스로 예측하는 것, 분류, 남성/여성, 양성/음성 Unsupervise Learning Clustering : 레이블이 없는 입력이미지를 바탕으로 학습할 때 유사하다고 계산이 되는 것을 군집화 하는 것 Dimensionality Reduction : 데이터가 엄청나게 큰 벡터로 표현될 때 적은차원의 벡터로 표현 하는 것, 차원축소의 기법 Reinforcement Learning Decision Process : 의사결정 Game Ai : 게임 ai Process of Machine Learning 데이터 수집 -&gt; 해당 데이터를 전처리(해당 모델에 대해서 잘 이용할 수 있게 작업) -&gt; 모델링 -&gt; 학습한 모델의 성능을 평가 Data Collection Database Server API Preprocessing Not Available : 정형데이터의 경우 변수에 없는 값이 발생할 수 있다 Scaling : 변수 간의 정보 반영이 단위 값에 따라 다를 수 있다 ex) 사람의 키는 cm 몸무게는 kg 인데 남자/여자 판별할 때 영향력이 1cm와 1kg은 다르다 Derived Variables : 파생변수(각 변수를 조합)를 만든다 Modeling ML Model DL Model RL Model Performance Measure Accuracy : 얼마나 잘 분류했는지 Mean Squared Error : 얼마나 잘 예측했는지 오차 계산 Similarity : 얼마나 유사한지 Role of Train, Valid, Test Dataset 잘 활용하기 위해서는 3가지의 Dataset이 필요하다 Train 학습을 하는데 이용한다 학습이 완료되고 예측을 해본다 Using for Training Model Valid 학습을 하지 않고 예측만 진행한다 만약 예측시 valid보다 train이 좋지 않으면 다시 학습한다 모니터링의 역할만 한다 Using for Training Direction Test 모델이 한 번도 보지 못한 것을 평가 Using for Measure Performance 10000의 dataset이 있을 경우 train : 6000, valid : 2000, test : 2000 으로 한다 8 : 1 : 1 도 한다 Process of NLP with Deep Learning 자연어처리 딥러닝을 이해하자 Data Collection Crawling : html에서 데이터를 직접 가져오기 ex) 영화평을 크롤링해서 분석 Preprocessing Tokenizer Make Corpus Representation Modeling ML Model DL Model RL Model Performance Measure Accuracy Mean Squared Error Similarity Make Corpus with Train Dataset Make Number to Input Natural Language into Computer 자연어를 숫자 값으로 변경하기 Make Token to Make a Dictionary 토큰을 만들기 ‘I am a boy’ -&gt; ‘I’, ‘am’, ‘a’, ‘boy’ 띄어쓰기를 바탕으로 단어 분리 ‘I am a girl’ -&gt; ‘I’, ‘am’, ‘a’, girl’ 각 단어는 토큰을 의미 Make a Dictionary out of the Tokens in the Train Dataset 트레인 데이터셋 안에 있는 토큰으로만 단어사전을 만든다 Replace Words with Numbers using a Dictionary 숫자를 붙여주기 ‘I’ : 0, ‘am’ : 1, ‘a’ : 2, ‘boy’ : 3, ‘girl’ : 4 ‘I am a boy’ -&gt; [0,1,2,3] ‘I am a girl’ -&gt; [0,1,2,4] 겹치지 않는다 Representation Vector ‘boy’ : 3 , ‘girl’ : 4 boy and girl have similar roles in sentence 남자와 여자는 문장에서 비슷한 역할을 수행할 것이다 But 3,4 can’t represent their role enough 하지만 3,4만으로는 비슷하다는 것을 나타낼 수 없다 Represent Natural Language with Vectors not scalars 원-핫벡터도 어떠한 인덱스만 1이기 때문에 스칼라로 보자 다양한 숫자로 채워진 벡터로 만들어보자 Word2Vec, Glove, FastTest(Word) Sentence, Document, Sentence Piece 단어 뿐만아니라 문장, 문서 등으로 토큰을 만들 수 있다","link":"/2020/04/25/NLP-BASIC/BackgroundofNLP/"},{"title":"자연어계산과이해","text":"2.1 자연어 계산과 이해 컴퓨터는 자연어를 사람처럼 이해할 수 없다. 그러나 임베딩을 활용하면 컴퓨터가 자연어를 계산하는 것이 가능해진다. 임베딩은 자연어를 컴퓨터가 처리할 수 있는 숫자들의 나열인 벡터로 바꾼 결과이기 때문이다. 컴퓨터는 임베딩을 계산/처리해 사람이 알아들을 수 있는 형태의 자연어로 출력한다. 자연어의 통계적 패턴 ** statistical pattern** 정보를 통째로 임베딩에 넣는다. 임베딩을 만들 때 쓰는 통계 정보는 3가지가 있다. 문장에 어떤 단어가 많이 쓰였는지 단어가 어떤 순서로 등장하는지 문장에 어떤 단어가 같이 나타났는지 구분 백오프워즈 가정 언어 모델 분포가정 내용 어떤 단어가 많이 쓰였는가 단어가 어떤 순으로 쓰였는가 어떤 단어가 같이 쓰였는가 대표 통계량 TF-IDF - PMI 대표 모델 Deep Averaging Network ELMo, GPT Word2Vec 언어 모델에서는 단어의 등장 순서를, 분포 가정에서는 이웃 단어를 우선시한다. 어떤 단어가 문장에서 주로 나타나는 순서는 해당 단어의 주변 문맥과 뗄래야 뗄 수 없는 관계를 가진다. 한편, 분포 가정에서는 어떤 쌍이 얼마나 자주 나타나는지와 관련한 정보를 수치화하기 위해 개별 단어 그리고 단어 쌍의 빈도 정보를 적극 활용한다. 백오브워즈 가정, 언어 모델, 분포 가정은 말뭉치의 통계적 패턴을 서로 다른 각도에서 분석하는 것이며 상호 보완적이다.","link":"/2020/03/31/KoreanEmbedding/%EC%9E%90%EC%97%B0%EC%96%B4%EA%B3%84%EC%82%B0%EA%B3%BC%EC%9D%B4%ED%95%B4/"},{"title":"Machine Translation","text":"Neural Machine Translation 기계번역 Sequence to Sequence Encoder Decoder From English to Korean From German to Korean Speech to Text Text to Speech Process Sequence to Sequence 인코더와 디코더의 구조. 인코더는 이용하고자 하는 대상 즉 소스. 한글에서 영어로 번역하는 태스크 일때, 인코더는 한글데이터 디코더는 영어데이터. 한글문장을 바꾸어보자. 한글 형태소 토크나이저를 이용해 나누기. 그게 x1, x2, x3 … xj가 된다. 그다음 corpus(단어사전)를 만든다. 해당단어를 인덱스로 바꾸어준다. x1은 넘버링이 들어가고 넘버링을 원-핫 벡터로 치환해서 들어간다. 파란색이 임베딩 벡터를 가져옴 RNN input으로 들어감 그전에 weight 매트릭스를 곱하고 바이어스가 더해진 값이 들어간다. Encoder의 output 값이 Decoder의 input 값이 된다. SOS는 Start of Sentence EOS는 End of Sentence y1는 영어딕셔너리에서 뽑힌 값이다. y1은 softmax를 통해서 가장 큰 값을 뽑아준다. with Attention hidden state만으로 y2가 부족하다고 판단할 수 있다. Encoder의 hidden state 값과 y2의 hidden state 값을 전부 내적한다. 어떤 스칼라의 값을 Attention Weight를 계산한다. 전부 0~1사이의 값으로 각각 바뀐다. 총 합이 1이 된다. 그리고 context vector로 만들어준다. 각 hidden state 별로 얼마나 가중있게 보아야하는지 척도를 알 수 있다. Transformer Attention is all you need(Ashishi Vaswani et al, 2017) 기존에는 RNN구조를 이용해서 Seq2Seq을 풀어냈다면 이 논문에서는 Attention 매커니즘만 이용하겠다. 훨씬 더 기계번역이 좋다. Using Only Attention Mechanism for Seq2Seq Basic concept of BERT","link":"/2020/04/26/NLP-BASIC/Machine_Translation/"},{"title":"Sequence_Tagging","text":"Tagging Make Label about the sentences 레이블을 붙이는 과정 This moive is so nice -&gt; Positive This moive is so boring -&gt; Negative Pair of Sentence and Label 문장과 레이블에 대해 쌍관계를 유지하는걸 태깅 It can use other Machine Learning Model’s Input Data 이것을 바탕으로 데이터를 input할 수 수 있음 Sentiment Analysis 감성분석데이터 어떤 문장에 대해서 긍정/부정, 평점등으로 평가하는데 이걸 예측하는 것 Benchmark Dataset 논문에서 많이 이용됨 IMDB (Internet Moive DataBase) Yelp (음식점평) Amazon Review (도서평) Crawling 네이버 영화 평 yes24 도서 평 Question Answering 특정한 문단과 질문을 넣었을 때 딥러닝 모델이 답변을 주는 것 Benchmark Dataset SQuAD.(1.1,2.0) 스탠퍼드 QnA WikiQA CoQA POS Part-of-Speech Tagging 문장에서 해당 단어들이 어떤 역할을 하는지 주어, 목적어, 서술어 등 Benchmark Dataset Penn Treebank UD Process 빨간색 Input 파란색 Output 초록색 RNN, LSTM, GRU 숫자는 시점 빨간색에 문장을 넣으면 파란색에는 Postive RNN hideen state를 바탕으로 태깅 기본 RNN Stack RNN Hidden state 결과를 새로운 input으로 받음 Bidirectional RNN forward backward 같은 시점에는 Concat 진행 CNN Convolutional Neural Networks for Sentence Classification(Yoon Kim et al, 2014) 문장에 대해서 filter size(2,3,4,5)에 대해 합성곱을 하여 진행 스트라이딩을 돌면서 feature maps을 만듬 같은 레벨의 feature map에 max pooling을 진행 문장특징을 뽑음 해당 결과값에 대해 Fully connected layer를 통해 최종 결과를 낸다","link":"/2020/04/26/NLP-BASIC/Sequence_Tagging/"},{"title":"아나콘다설치","text":"아나콘다 가상 환경 구성 아나콘다가 설치 되었다는 가정하에 진행하겠다 파이썬 프로젝트는 파이썬 실행 환경을 독립적으로 가능하게 해주므로 가상 환경을 만들어 보자. conda 명령어를 통해 가상 환경을 생성하자. 12lego7@DESKTOP-UHCO554 MINGW64 ~/Desktop/NaverCloud/hyeonukdev/NLG$ conda create --name pr_tensorflow python=3 conda crate는 가상환경을 생성하는 것을 의미 –naeme 옵션에 pr_tensorflow입력하고 3버전을 입력 123lego7@DESKTOP-UHCO554 MINGW64 ~/Desktop/NaverCloud/hyeonukdev/NLG$ conda activate pr_tensorflow(pr_tensorflow 윈도우 환경에서는 activate로 가상환경을 실행해주면 (pr_tensorflow)가 만들어진다 가상환경이름을 잊어버렸다면 123456lego7@DESKTOP-UHCO554 MINGW64 ~/Desktop/NaverCloud/hyeonukdev/NLG$ conda env list# conda environments:#base C:\\Users\\lego7\\Anaconda3pr_tensorflow * C:\\Users\\lego7\\Anaconda3\\envs\\pr_tensorflow 실습 환경 구성 github링크 123456789101112131415lego7@DESKTOP-UHCO554 MINGW64 ~/Desktop/NaverCloud/hyeonukdev/NLG$ git clone https://github.com/NLP-kr/tensorflow-ml-nlp.gitCloning into 'tensorflow-ml-nlp'...lego7@DESKTOP-UHCO554 MINGW64 ~/Desktop/NaverCloud/hyeonukdev/NLG$ lstensorflow-ml-nlp/(pr_tensorflow)lego7@DESKTOP-UHCO554 MINGW64 ~/Desktop/NaverCloud/hyeonukdev/NLG$ cd tensorflow-ml-nlp(pr_tensorflow)lego7@DESKTOP-UHCO554 MINGW64 ~/Desktop/NaverCloud/hyeonukdev/NLG/tensorflow-ml-nlp (master)$ ls1.Intro/ 3.NLP_INTRO/ 5.TEXT_SIM/ main.png requirements.txt2.NLP_PREP/ 4.TEXT_CLASSIFICATION/ 6.CHATBOT/ README.md(pr_tensorflow) python 3.6 버전을 설치해주자 12lego7@DESKTOP-UHCO554 MINGW64 ~/Desktop/NaverCloud/hyeonukdev/NLG/tensorflow-ml-nlp (master)$ conda install python=3.6 123lego7@DESKTOP-UHCO554 MINGW64 ~/Desktop/NaverCloud/hyeonukdev/NLG/tensorflow-ml-nlp (master)$ pip install -r requirements.txtCollecting tensorflow 주피터노트북 실행 12lego7@DESKTOP-UHCO554 MINGW64 ~/Desktop/NaverCloud/hyeonukdev/NLG/tensorflow-ml-nlp (master)$ jupyter notebook","link":"/2020/04/01/NLG-anaconda/%EC%95%84%EB%82%98%EC%BD%98%EB%8B%A4%EC%84%A4%EC%B9%98/"},{"title":"Recurrent Neural Network","text":"Deep Learning Neural Network with Many Hidden Layers Learning through Back-Propagation from Objective Function (Loss Function) 인간의 뇌와 흡사 Type of RNN 빨간색은 input 초록색은 hidden state 파란색은 output 해석하는 형태도 존재 이어져서 뭔가를 한다고 이해하자 Vanilla RNN xt와 ht-1을 같이 받는다 Wh는 가중치행렬 Need to Refine Long Term Dependency 문장길이가 토큰기준 3개정도인데 만약 길이가 길게 되면 최종적 output값에 대해 발생하는 그레디언트 값이 앞쪽까지 전달되는데 문제가 있다. LSTM (Long Short Term Memory) 12개의 term이 학습이 된다 Cell state가 있다 xt는 현재시점 t-1은 이전시점 ft는 현재시점에 대한 input과 이전시점에대한 ht-1에 각각 가중치행렬을 곱해주고 b를 더함 이것을 시그모드취해준다. tanh는 -1 ~ 1 까지임 -&gt; 현재 위치에서 어느정도 정보를 반영할지에 대한 결과 forget gate : 현재시점 입력값과 이전시점의 hidden state의 결과에 시그모이드를 취한 값을 이용해서 몇퍼센트 기억할건지 하는 역할 input gate : 현재시점 입력값과 이전시점의 hidden state를 tanh를 해서 원소 곱 그리고 forget에서 나온 값과 더한다 -&gt; cell state 업데이트를 함 output gate : 업데이트한 cell state를 정보를 바탕으로 output을 통과한 결과에 cell state를 tanh를 해주고 원소 곱 -&gt; ht 와 yt로 내보내줌 GRU(Gated recurrent unit) lstm의 많은 학습을 9개로 줄인 것","link":"/2020/04/25/NLP-BASIC/RecurrentNeuralNetwork/"},{"title":"챗봇만들기(2) - 데이터분석(1)","text":"챗봇만들기(2) 데이터 분석(1) 데이터 분석 데이터 전처리와 모델 생성 데이터 불러오기 1234567import pandas as pdDATA_IN_PATH = './data_in/'data = pd.read_csv(DATA_IN_PATH + 'ChatBotData.csv', encoding='utf-8')print(data.head()) Q A label 0 12시 땡! 하루가 또 가네요. 1 1지망 학교 떨어졌어 위로해 드립니다. 2 3박4일 놀러가고 싶다 여행은 언제나 좋죠. 3 3박4일 정도 놀러가고 싶다 여행은 언제나 좋죠. 4 PPL 심하네 눈살이 찌푸려지죠. 문장 전체에 대한 분석 데이터 길이를 분석 질문과 답변 모두 길이에 대해 분석하기 위해 두 데이터를 하나의 리스트로 만들기 1sentences = list(data['Q']) + list(data['A']) 세 가지 기준으로 분석을 진행 문자 단위의 길이 분석 (음절) 문자 하나하나를 생각하자 단어 단위의 길이 분석 (어절) 띄어쓰기 단위로 생각하자 형태소 단위의 길이 분석 어절과 음절 사이로 생각하자 최소 단위를 의미 ex) 나는 학생이다. 음절 : “나”, “는”, “학”, “생”, “이”, “다” 어절 : “나는”, “학생이다” 형태소 : “나”, “는”, 학생&quot;, “이다” 토크나이징 KoNLPy 사용 12345678tokenized_sentences = [s.split() for s in sentences]sent_len_by_token = [len(t) for t in tokenized_sentences]sent_len_by_eumjeol = [len(s.replace(' ', '')) for s in sentences]okt = Okt()morph_tokenized_sentences = [okt.morphs(s.replace(' ', '')) for s in sentences]sent_len_by_morph = [len(t) for t in morph_tokenized_sentences] 띄어쓰기 기준으로 문장 분류 -&gt; 어절의 길이 측정 위 값을 붙이기 -&gt; 음절의 길이 KoNLPy에 Okt 형태소 분석기 사용해서 나눈 후 길이 측정 그래프그리기 matplot사용 123456789import matplotlib.pyplot as pltplt.figure(figsize=(12, 5))plt.hist(sent_len_by_token, bins=50, range=[0,50], alpha=0.5, color= 'r', label='eojeol')plt.hist(sent_len_by_morph, bins=50, range=[0,50], alpha=0.5, color='g', label='morph')plt.hist(sent_len_by_eumjeol, bins=50, range=[0,50], alpha=0.5, color='b', label='eumjeol')plt.title('Sentence Length Histogram')plt.xlabel('Sentence Length')plt.ylabel('Number of Sentences') 빨간색 : 어절 단위 히스토그램 초록색 : 형태소 파란색 : 음절 그래프 해석 어절이 가장 낮은 길이 그다음 형태소, 가장 긴 길이는 음절 히스토그램을 통해 각 길이가 어느 쪽으로 치우쳐 있는지 혹은 각 데이터에 이상치는 없는지 확인하자 이 그래프는 직관적으로는 어렵다 y값 분포가 다르기 때문 수정을 해보자 12345678plt.figure(figsize=(12, 5))plt.hist(sent_len_by_token, bins=50, range=[0,50], alpha=0.5, color= 'r', label='eojeol')plt.hist(sent_len_by_morph, bins=50, range=[0,50], alpha=0.5, color='g', label='morph')plt.hist(sent_len_by_eumjeol, bins=50, range=[0,50], alpha=0.5, color='b', label='eumjeol')plt.yscale('log')plt.title('Sentence Length Histogram by Eojeol Token')plt.xlabel('Sentence Length')plt.ylabel('Number of Sentences') plt.yscale(‘log’) 사용 각 그래프가 커지는 y값의 스케일을 조정함으로써 차이가 큰 데이터에서도 함께 비교 가능 꼬리부분의 분포가 보임 어절의 경우 길이가 20인 경우가 이상치 데이터로 존재 형태소는 30, 음절은 45정도 길이에 이상치가 존재 이러한 길이 분포에 대한 분석 내용을 바탕으로 입력 문장의 길이를 어떻게 설정할지 정의하면 됨 통계값출력 정확한 수치 확인을 위해 각 기준별 길이에 대한 여러가지 통곗값 비교 어절 12345678import numpy as npprint('어절 최대길이: {}'.format(np.max(sent_len_by_token)))print('어절 최소길이: {}'.format(np.min(sent_len_by_token)))print('어절 평균길이: {:.2f}'.format(np.mean(sent_len_by_token)))print('어절 길이 표준편차: {:.2f}'.format(np.std(sent_len_by_token)))print('어절 중간길이: {}'.format(np.median(sent_len_by_token)))print('제 1 사분위 길이: {}'.format(np.percentile(sent_len_by_token, 25)))print('제 3 사분위 길이: {}'.format(np.percentile(sent_len_by_token, 75))) 어절 최대길이: 21 어절 최소길이: 1 어절 평균길이: 3.64 어절 길이 표준편차: 1.74 어절 중간길이: 3.0 제 1 사분위 길이: 2.0 제 3 사분위 길이: 5.0 형태소 1234567print('형태소 최대길이: {}'.format(np.max(sent_len_by_morph)))print('형태소 최소길이: {}'.format(np.min(sent_len_by_morph)))print('형태소 평균길이: {:.2f}'.format(np.mean(sent_len_by_morph)))print('형태소 길이 표준편차: {:.2f}'.format(np.std(sent_len_by_morph)))print('형태소 중간길이: {}'.format(np.median(sent_len_by_morph)))print('형태소 1/4 퍼센타일 길이: {}'.format(np.percentile(sent_len_by_morph, 25)))print('형태소 3/4 퍼센타일 길이: {}'.format(np.percentile(sent_len_by_morph, 75))) 형태소 최대길이: 31 형태소 최소길이: 1 형태소 평균길이: 5.41 형태소 길이 표준편차: 2.56 형태소 중간길이: 5.0 형태소 1/4 퍼센타일 길이: 4.0 형태소 3/4 퍼센타일 길이: 7.0 음절 1234567print('음절 최대길이: {}'.format(np.max(sent_len_by_eumjeol)))print('음절 최소길이: {}'.format(np.min(sent_len_by_eumjeol)))print('음절 평균길이: {:.2f}'.format(np.mean(sent_len_by_eumjeol)))print('음절 길이 표준편차: {:.2f}'.format(np.std(sent_len_by_eumjeol)))print('음절 중간길이: {}'.format(np.median(sent_len_by_eumjeol)))print('음절 1/4 퍼센타일 길이: {}'.format(np.percentile(sent_len_by_eumjeol, 25)))print('음절 3/4 퍼센타일 길이: {}'.format(np.percentile(sent_len_by_eumjeol, 75))) 음절 최대길이: 57 음절 최소길이: 1 음절 평균길이: 11.31 음절 길이 표준편차: 4.98 음절 중간길이: 10.0 음절 1/4 퍼센타일 길이: 8.0 음절 3/4 퍼센타일 길이: 14.0 전체 문자 수는 11개 정도의 평균값을 갖고 있음 띄어쓰기로 구분한 어절의 경우 3~4 정도의 평균 형태소로 분석시 6~7 정도의 평균 박스플롯그리기 1234plt.figure(figsize=(12, 5))plt.boxplot([sent_len_by_token, sent_len_by_morph, sent_len_by_eumjeol], labels=['Eojeol', 'Morph', 'Eumjeol'], showmeans=True) 꼬리가 긴 형태로 분포됨 5~15의 길이를 중심으로 분포를 이루고 있음 음절은 어절과 형태소에 비해 분포가 큼","link":"/2020/05/03/NLG-anaconda/%EC%B1%97%EB%B4%87%EB%A7%8C%EB%93%A4%EA%B8%B0_2_%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B6%84%EC%84%9D_1/"},{"title":"챗봇만들기(1) - 데이터소개","text":"챗봇만들기(1) 딥러닝 모델(sequence to sequence)을 활용한 챗봇 만들기 데이터 소개 분류 설명 데이터 이름 Chatbot data 데이터 용도 한국어 챗봇 학습 데이터 권한 MIT 라이선스 데이터 출처 http://github.com/songys/Chatbot_data 총 11,876개의 데이터 데이터 설명 질문과 대답 주제에 대한 라벨값 0 : 일상 대화 1 : 긍정 2 : 부정","link":"/2020/05/03/NLG-anaconda/%EC%B1%97%EB%B4%87%EB%A7%8C%EB%93%A4%EA%B8%B0_1_%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%86%8C%EA%B0%9C/"},{"title":"논문읽는 방법","text":"논문의 구조 논문은 표현의 간결성(conciseness)과 명료성(clarity)이 매우 중요 ​ -영어 논문의 구조 나는 이런 문제를 풀거야 (abstract) 사실 이 문제는 이런 동기에서 연구가 시작된건데 (introduction) 관련해서 이런저런 접근들이 있었지 (related works) 난 이런 새로운 방식으로 접근해보려고 하는데 (method) 정말 이게 잘 먹히는지 실험도 해봤어 (experiment) 이를 통해 이런 사실도 알아냈지만 한계점도 있지 (discussion) 마지막으로 귀찮은 너를 위해 요약 (conclusion) 논문의 핵심은 ‘내가 주어진 문제에서 이러한 기여(contribution)를 했다’ ​ 논문 고르기 구글스칼라 이용 관심있는 키워드를 넣고 논문을 검색 그 분야의 개략적인 연구들을 훑어보려면 관련 키워드와 함께 ‘review’, ‘survey’, ‘tutorial’ 등을 넣고 검색 이들은 특정 문제를 푸는 일반 논문들과 달리, 관련 연구들을 종합하거나 (review), 조사하거나 (survey), 쉽게 설명하고 있다. (tutorial) Abstract 초록읽기 하이라이트 같은 거 개요 -&gt; In this paper -&gt; 방법 -&gt; 결과 순으로 적힘 이 논문이 ‘무슨 문제’를 풀려고 했고, ‘어떠한 새로운 기여’를 담고 있는지 파악 ​ Conclusion 결론 읽기 내가 제대로 이해했는지 확인하기 위해 결론 먼저 읽음 논문이 무슨 문제를 풀려했고, 어떠한 기여를 했는지 아는게 중요 ​ Instroduction 서론 읽기 본론은 지엽적인 문제해결만을 다룸 서론에서는 주요 연구들을 한줄 요약들과 함께 친절히 소개해줌 소개되는 논문들은 꼭 읽어야하는 논문 위주 (1) 내가 어떤 문제를 풀고 있는지 (2) 관련 연구들은 이 문제를 어떻게 풀어왔는지 (3) 마지막으로 나는 그들과 달리 어떤 입장에서 문제를 해결했는지 ​ 표/그림 보기 영어 독해를 쉽게하는 방법 중 하나는 ‘앞에 나올 내용을 예상하며 읽는 것’이다. 이제까지 초록, 결론, 서론을 읽었던 것은 모두 본론에 어떤 내용이 나올지 잘 예측할 수 있기 위해서였다. 여기에 또 한가지 본문 이해에 도움을 주는 소재가 있다면 바로 표와 그림들 ​ Methods &amp; Experiments 이전까지는 무엇을 왜 에 대한 내용 방법 및 실험은 어떻게 에 대한 본연구의 자세한 설명 수식의 역할만 이해한다면 디테일은 일단 패스 중요한건 그 수식이 인풋으로 무엇을 받아 아웃풋으로 무엇을 내놓는지 이해하는 것이다. 그리고 왜 이 수식이 필요한지, 없으면 어떤 일이 벌어지는지를 이해하는 것 역시 중요하다. ​ 중요한건 수식이 아니라 ‘내가 뭘 읽고 있는지’와 ‘내가 왜 읽고 있는지’의 능동적 이해 자세이다. 혼미해지는 정신 꽉 부여잡고 이 논문의 핵심스토리에 집중하자. ​ 출처 http://gradschoolstory.net/terry/readingpapers/ 영어 못해도 논문 잘 읽는 법 ‘그 발번역 정말 못읽겠더라. 차라리 원서 읽어.’ ‘맞아맞아~ 어떻게 한글이 영어보다 어렵니? 원서가 훨씬 쉬운 듯’ 대학생 초년 시절, 영어가 너무 벅찬던 내가 운좋게 번역본이라도 구해 들고 있을지면 친구들은 항상 내게 이런 말을 건냈다. 번역본이 훨씬 어렵지 않냐면서 말이다. ‘당연하지&amp;#82… gradschoolstory.net ​","link":"/2020/04/01/Paper/How_to_read_Paper/"},{"title":"챗봇만들기(3) - 데이터분석(2)","text":"챗봇만들기(3) 데이터 분석(2) 질문, 답변 각각에 대한 문장 길이 분포 분석 형태소를 기준으로 길이 분석 12345678query_sentences = list(data['Q'])answer_sentences = list(data['A'])query_morph_tokenized_sentences = [okt.morphs(s.replace(' ', '')) for s in query_sentences]query_sent_len_by_morph = [len(t) for t in query_morph_tokenized_sentences]answer_morph_tokenized_sentences = [okt.morphs(s.replace(' ', '')) for s in answer_sentences]answer_sent_len_by_morph = [len(t) for t in answer_morph_tokenized_sentences] 질문 열과 답변 열을 각각 리스트로 정의 KoNLpy의 Okt 형태소 분석기를 이용해 토크나이저 구분 구분된 데이터의 길이를 하나의 변수로 만듬 질문 응답 데이터 길이에 대한 히스토그램 질문 문장 길이가 응답 문장 길이보다 상대적으로 짧음 y 값의 크기를 조정 12345678plt.figure(figsize=(12, 5))plt.hist(query_sent_len_by_morph, bins=50, range=[0,50], color='g', label='Query')plt.hist(answer_sent_len_by_morph, bins=50, range=[0,50], color='r', alpha=0.5, label='Answer')plt.legend()plt.yscale('log', nonposy='clip')plt.title('Query Length Log Histogram by Morph Token')plt.xlabel('Query Length')plt.ylabel('Number of Queries') plt.yscale(‘log’, nonposy=‘clip’) 추가 답변 데이터가 질문 데이터 보다 이상치 값이 많음 상대적으로 질문의 경우 평균 주변에 잘 분포 통곗값 확인하기 1234567print('형태소 최대길이: {}'.format(np.max(query_sent_len_by_morph)))print('형태소 최소길이: {}'.format(np.min(query_sent_len_by_morph)))print('형태소 평균길이: {:.2f}'.format(np.mean(query_sent_len_by_morph)))print('형태소 길이 표준편차: {:.2f}'.format(np.std(query_sent_len_by_morph)))print('형태소 중간길이: {}'.format(np.median(query_sent_len_by_morph)))print('형태소 1/4 퍼센타일 길이: {}'.format(np.percentile(query_sent_len_by_morph, 25)))print('형태소 3/4 퍼센타일 길이: {}'.format(np.percentile(query_sent_len_by_morph, 75))) 형태소 최대길이: 20 형태소 최소길이: 1 형태소 평균길이: 4.95 형태소 길이 표준편차: 2.48 형태소 중간길이: 4.0 형태소 1/4 퍼센타일 길이: 3.0 형태소 3/4 퍼센타일 길이: 6.0 1234567print('형태소 최대길이: {}'.format(np.max(answer_sent_len_by_morph)))print('형태소 최소길이: {}'.format(np.min(answer_sent_len_by_morph)))print('형태소 평균길이: {:.2f}'.format(np.mean(answer_sent_len_by_morph)))print('형태소 길이 표준편차: {:.2f}'.format(np.std(answer_sent_len_by_morph)))print('형태소 중간길이: {}'.format(np.median(answer_sent_len_by_morph)))print('형태소 1/4 퍼센타일 길이: {}'.format(np.percentile(answer_sent_len_by_morph, 25)))print('형태소 3/4 퍼센타일 길이: {}'.format(np.percentile(answer_sent_len_by_morph, 75))) 형태소 최대길이: 31 형태소 최소길이: 1 형태소 평균길이: 5.87 형태소 길이 표준편차: 2.55 형태소 중간길이: 5.0 형태소 1/4 퍼센타일 길이: 4.0 형태소 3/4 퍼센타일 길이: 7.0 최댓값의 경우 답변 데이터가 더 큼 평균의 경우 질문 데이터가 좀 더 작음 박스플롯그리기 12plt.figure(figsize=(12, 5))plt.boxplot([query_sent_len_by_morph, answer_sent_len_by_morph], labels=['Query', 'Anser']) 통계값과는 다소 다름 통계값 : 답변 데이터에 대한 평균 길이가 질문 데이터보다 길었음 박스플롯 : 질문 데이터가 더 큼 -&gt; 답변 데이터의 경우 길이가 긴 이상치 데이터가 많아서 평균값이 더욱 크게 측정됨 길이 값을 통해 모델에 적용될 문장의 최대 길이를 결정한다 데이터 어휘 빈도 분석 형태소 단위로 토크나이징한 데이터를 사용해 자주 사용하는 단어 파악 ‘이’, ‘가’ 등의 조사보다는 의미상 중요한 명사, 형용사, 동사를 따로 모은 후 파악 KoNPy의 품사분류 POS-tagging 모듈 12okt.pos('나는학생입니다')okt.pos('지금은5월여름입니다') [(‘나’, ‘Noun’), (‘는’, ‘Josa’), (‘학생’, ‘Noun’), (‘입니다’, ‘Adjective’)] [(‘지금’, ‘Noun’), (‘은’, ‘Josa’), (‘5월’, ‘Number’), (‘여름입니다’, ‘Foreign’)] 문장에서 명사, 형용사, 동사를 제외한 단어를 모두 제거한 문자열 만들기 12345678910111213141516query_NVA_token_sentences = list()answer_NVA_token_sentences = list()for s in query_sentences: for token, tag in okt.pos(s.replace(' ', '')): if tag == 'Noun' or tag == 'Verb' or tag == 'Adjective': query_NVA_token_sentences.append(token)for s in answer_sentences: temp_token_bucket = list() for token, tag in okt.pos(s.replace(' ', '')): if tag == 'Noun' or tag == 'Verb' or tag == 'Adjective': answer_NVA_token_sentences.append(token) query_NVA_token_sentences = ' '.join(query_NVA_token_sentences)answer_NVA_token_sentences = ' '.join(answer_NVA_token_sentences) 워드클라우드 활용해 어휘 빈도 분석 NanumGothic.ttf 한글 폰트 설정 질문 123456from wordcloud import WordCloudquery_wordcloud = WordCloud(font_path= DATA_IN_PATH + 'NanumGothic.ttf').generate(query_NVA_token_sentences)plt.imshow(query_wordcloud, interpolation='bilinear')plt.axis('off')plt.show() 답변 12345query_wordcloud = WordCloud(font_path= DATA_IN_PATH + 'NanumGothic.ttf').generate(answer_NVA_token_sentences)plt.imshow(query_wordcloud, interpolation='bilinear')plt.axis('off')plt.show()","link":"/2020/05/04/NLG-anaconda/%EC%B1%97%EB%B4%87%EB%A7%8C%EB%93%A4%EA%B8%B0_3_%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B6%84%EC%84%9D_2/"},{"title":"클래스란 무엇인가","text":"Class가 무엇인가? # 자동차 1 car_brand1 = &quot;Kia&quot; car_color1 = &quot;Red&quot; car_year1 = 1996 # 자동차 2 car_brand2 = &quot;Hyundai&quot; car_color3 = &quot;Blue&quot; car_year3 = 2009 # 자동차 3 car_brand3 = &quot;BMW&quot; car_color3 = &quot;Black&quot; car_year3 = 2000 브랜드, 색상, 제작년도가 있는 코드 만약 100대, 1000대 이상이 되면 일일이 쓰면 비효율적! → 클래스를 사용하자 class Car: def __init__(self, brand, color, year): self.brand = brand self.color = color self.year = year car1 = Car(&quot;Kia&quot;, &quot;Red&quot;, 1996) car2 = Car(&quot;Hyundai&quot;, &quot;Blue&quot;, 2006) car3 = Car(&quot;BMW&quot;, &quot;Black&quot;, 2000) Car 는 자동차 클래스 car1, car2, car3 객체는 Car 클래스의 ‘인스턴스’ 클래스 : 비슷한 속성을 가진 객체를 묶는 큰 틀 클래스 변수 class Car: honk = &quot;빵빵&quot; print honk # NameError: name 'honk' is not defined honk이라는 변수는 외부에서 호출이 안된다 클래스 안에 있는 변수는 '해당 클래스의 인스턴트’를 통해서 호출 my_car = Car() my_car.honk # '빵빵' Car().honk self는 뭔가요? 클래스 메소드의 첫 번째 인수로 self를 써 줘야지 해당 메소드를 인스턴스의 메소드로 사용 가능 쉽게 : 이 메소드를 부르는 객체가 해당 클래스의 인스턴스 인지 확인하려고 class Car: honk = &quot;빵빵&quot; def set_info(self, color, year): self.color = color self.year = year def get_info(self): print(&quot;color : %s , year: %d&quot; %(self.color, self.year)) my_car1 = Car() my_car1.set_info(&quot;Red&quot;, 2017) my_car1.get_info() #=&gt; color : Red ,year: 2017 init 이란? class Car: honk = &quot;빵빵&quot; def set_info(self, color, year): self.color = color self.year = year def get_info(self): print &quot;color : %s ,year: %d&quot; % (self.color, self.year) my_car = Car() my_car.set_info(&quot;Red&quot;, 2017) my_car.get_info() #=&gt; color:Red, year:2017 new_car = Car()0 new_car.get_info() # AttributeError: Car instance has no attribute 'color' 오류발생! set_info()를 안하고 get_info()를 먼저 불렀다… 클래스의 인스턴트를 생성할 때, 오류를 줄이고 싶다! init 을 사용하자 초기화 메소드, 생성자라고 불림 인스턴스 = 클래스(변수1,변수2…) class Car: honk = &quot;빵빵&quot; def __init__(self, color, year): self.color = color self.year = year print &quot;새로운 Car 인스턴스가 생성되었습니다.&quot; def get_info(self): print &quot;color : %s ,year: %d&quot; % (self.color, self.year) my_car = Car(&quot;Red&quot;, 2017) # 새로운 Car 인스턴스가 생성되었습니다. my_Car.get_info() # color : Red, year: 2017 새로운 인스턴스를 만들고 난 후 “새로운 Car 인스턴스가 생성되었습니다” 출력 즉 , init 메소드가 호출 되었다. 클래스 상속? 상속 : 물려받는다? 유산을 상속하다 부모의 클래스가 존재하고 그 부모 클래스를 '상속’받은 자식 클래스를 만들 수 있다. 자식클래스는 부모가 가진 메소드나 변수를 물려받아 그대로 사용 가능! class Person: def __init__(self, name, age): self.name = name self.age = age def info(self): print(&quot;이름: %s, 나이: %d&quot; %(self.name, self.age)) class Employee(Person): pass em = Employee(&quot;goorm&quot;,20) em.info() #=&gt; 이름: goorm, 나이: 20 Person 클래스는 init 메소드를 통해 이름, 나이를 초기값으로 받는다 info메소드를 통해 이름과 나이를 출력 Employee클래스를 보면 Person을 상속받았다 그래서 info를 동일하게 쓸 수 있다. 만약 메소드를 변형한다면? 메소드 오버라이딩이라고 부른다 class Person: def __init__(self, name, age): self.name =name self.age = age def info(self): print &quot;나는 부모 클래스 입니다.&quot; class Employee(Person): def info(self): print &quot;나는 자식 클래스 입니다.&quot; per = Person(&quot;Python&quot;, 100) per.info() #=&gt; &quot;나는 부모 클래스 입니다.&quot; em = Employee(&quot;goorm&quot;,20) em.info() #=&gt; &quot;나는 자식 클래스 입니다.&quot; 원래는 “나는 부모 클래스 입니다” 이지만 Person을 상속받아 자식클래스, 즉, Employee에서 메소드를 변형, 즉, 오버라이딩했다 따라서 &quot;나는 자식 클래스 입니다&quot;가 출력 예시를 하나 만들어보자 123class 클래스명(상속클래스): def __init__(self, 매개변수): 인스턴스 속성 123456class Klass(object): def __init__(self, name): self.name = name def getName(self): return self.name __init__은 객체 생성 후 초기화 함수이다. 객체가 생성될 때 내부의 이름공간에 속성을 할당하여 초기화 역할만 한다. 이제 객체를 생성해 보자 1k = Klass(\"객체 생성\") 이름을 조회해 보자 1k.name 1결과 '객체 생성' k.name 과 k.getName()은 동일하다 Python의 가장 큰 특징이다. 굳이 getName을 사용하지 않아도 name로만 조회가 가능하다. 객체와 인스턴스의 관계 클래스는 객체를 만드는 도구이다. 클래스로 객체를 생성하고, 객체를 사용해서 특정기능을 처리할 수 있다. 여러개의 객체를 생성해 보자 123k1 = Klass(\"객체 생성1\")k2 = Klass(\"객체 생성2\")k3 = Klass(\"객체 생성3\") 생성관계 isinstance : 클래스와 객체의 생성관계를 확인하는 내장함수 1isinstance(k, Klass) 1결과 : True 1isinstance(k1, Klass) 1결과 : True 즉 k와 k1의 Klass를 통해서 생성된 것이다. 함수와 메소드 구분하기 함수들은 객체가 생성된 다음에 호출하기 때문에 메소드라고한다. 예를 들면 getName()을 쓰려면 Klass에서 만든 인스턴스를 이용해서 호출할 때 사용하는 것이다. 클래스에 어떤 메소드가 있는지 확인해보자 1Klass.__dict__ 1k.__init__ 객체를 호출할 때는 함수가 아니라 메소드로 처리함을 알 수 있다. self에서는 객체에서 자동으로 전달되고 두 번째 인자에만 해당하는 값을 문자열로 전달하면 된다. 12k.__init__(\"메소드로 갱신\")k.name 1결과 : '메소드로 갱신'","link":"/2020/04/01/python/%ED%81%B4%EB%9E%98%EC%8A%A4%EB%9E%80%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80/"},{"title":"Vector for NLP","text":"라이브러리 소개 Representation Vector Background 원-핫 인코딩을 표현한 벡터, 트레인 데이터 셋 안에 전체 문장들의 합을 코퍼스라고 했을 때, 코퍼스 안에서 어떤 토크나이저를 거쳐서 딕셔너리를 만든다 -&gt; v가 된다 Make several tokens from sentences Build a Dictionary of words by indexing each token Make a Vector(Dimension : Number of Words) 1 for the corresponding index with the remaining 0 Orthogonal Vector -&gt; Lose of Context Information Rome Paris는 역할이 비슷하지만 표현할 수 없다 Sparse Vector -&gt; Curse of Dimensionality 벡터를 내적했을 때 값이 크면 유사도가 높지만 원-핫 인코딩 벡터는 1개 빼고 0 이 된다 두 가지 이유로 적합하지 않음 -&gt; 토크나이저를 쓰자 Tokenizer English -&gt; SPACY, NLTK 한국어는 형태소라는 것이 있기 때문에 띄어쓰기로는 애매할 수 있다. 이러한 것을 보완해서 한국어토큰이 별도 있다. Korean -&gt; KoNLPy(Hannanum, Kkma, Komoran, Twitter), MECAB, KHAIII 한국어의 사전에 따라 모델의 성능이 다르기 때문에 중요하다. 넘버링이 되어 있는 단어를 어떻게 표현할 것인지 알아보자 Word2Vec Efficient Estimation of Word Representations in Vector Space(Tomas Mikolov et al, 2013) CBOW 방식 w(t-2) ~ w(t+2)바탕으로 w(t)를 유추할 수 있도록 한다. 주변 단어들을 이용해서 중심단어를 학습한다. w(t-2) : The w(t-1) : quick w(t) : brown -&gt; output w(t+1) : fox w(t+2) : jumps w(t-2)가 들어갔을 때 brown이 나올 수 있도록 학습하는 것. 중심단어를 이용해서 주변 단어를 학습한다. 네모를 window라고 하고 중심단어로부터 주변단어까지의 사이즈를 window size라고한다 Skip-gram 방식 w(t)를 바탕으로 w(t-2) ~ w(t+2)를 유추할 수 있도록 한다. Objective Function : Learn to reflect similarity between two vectors The의 경우 빈도수가 높아서 과적합이 일어날 수 있다. -&gt; Subsampling to get : Regularize 전체 단어에 대한 대상으로 softmax를 계산하는 것이 아닌 window size 안에 있는 단어와 밖에 있는 단어는 샘플링하여 해당되는 내용을 바탕으로 softmax 계산을 한다. -&gt; Negative Sampling to get Speed Up Glove Global Vectors for Word Representation (Jeffrey Pennington et al, 2014) co-occurrence 개념을 제시 window 밖에 있는 단어는 학습이 진행되지 않는 단점을 지적했다. Objective Function : Learn to reflect co-occurrence between two vectors 가정 : 한 문장안에 동시 출연된 단어는 연관성이 있을 것이다. 연관성이 높으면 값이 높을 것이다 FastText Bag of Tricks for Efficient Text Classification (Armand Joulin et al, 2016) Objective Function : Learn to reflect similarity between two vectors 코퍼스를 형성하는 단어를 적게두자. Unigrams Bigrams Trigrams 4-grams","link":"/2020/04/25/NLP-BASIC/VectorforNLP/"},{"title":"소프트스킬(1)","text":"다른 이들과 달리 멋지게 시작하기 사업가처럼 생각하기 나는 어떤 제품이나 서비스를 팔 생각인가? 서비스 개선 방법을 고민하기 고정관념에서 벗어나 사업가처럼 사고하자 목표를 설정하고 미래에 대비하기 성취할 목표를 설정하기 목표를 정확히 이해하기 크거나 구체적인것 보다 방향을 제시해야한다 목표를 주기적으로 살피자 시간을 내서 큰 목표를 최소 하나 이상을 기록하기 큰 목표를 월간, 주간, 일간으로 작은 목표로 나누기 큰 목표를 매일 생각할 수 있도록 잘 보이는 장소에 두기 면접의 달인이 되기 고정관념에서 벗어나 인맥 쌓기 개발자들의 블로그를 찾아 친부 쌓기 기술 수준을 꾸준히 발전시키기 전문성을 갖추기 전문성으로 많은 기회의 문이 열린다 전문성이 높아질수록 잠재적 기회가 줄어드는 반면 기회를 잡을 확률은 점점 높아진다 전문분야는 다음과 같다 - 웹 개발 기술 - 임베디드 시스템 - 특정 운영체제 - 모바일 개발 - 프레임워크 - 소프트웨어 시스템 승진하기 존재감 있게 일하기 주간 보고서를 작성하기 자신의 활동을 매일 기록하기 어떤 문제든 해결책을 제시할 수 있는 사람이 되기 해결책을 실행할 수 있는 사람이 되기 전문가되기 사고방식 전환하기 약속을 지키고 맡은 일을 완수하고 포기하지 않기 맡은 일과 경력을 진지하게 생각하기 좋은 습관 기르기 - 시간 관리 기술 자기 계발하기 첫 제품 만들기 문제 해결을 염두하고 제품을 제작하기 How to Market Yourself as a Software Developer 에릭리스 - 린스타트업 이루고 싶은게 있다면 이미 이룬 것처럼 연기하라 이력서쓰기 온라인 이력서 만들기 개성을 더하기 행동과 결과를 연결하기 교정하기","link":"/2020/04/16/books/%EC%86%8C%ED%94%84%ED%8A%B8%EC%8A%A4%ED%82%AC_1/"},{"title":"애플리케이션테스트케이스설계 - 핵심정리","text":"애플리케이션테스트케이스설계 1. 애플리케이션 테스트 케이스 작성 테스트에 대한 기본 개념 및 테스트의 기법을 파악하고 테스트 케이스 작성 기법 소프트웨어 테스트 기법 분류에서는 소프트웨어 내부 구조 참조 여부에 따른 분류, 테스트 설계의 근원에 따른 분류 테스트 케이스 작성 방법 2. 애플리케이션 테스트 시나리오 작성 테스트 시나리오 개념 및 작성시 유의사항 테스트 환경구축의 개념 및 유의사항 소프트웨어 테스트 관련 국제표준에 의한 테스트 지식 체계","link":"/2020/05/21/Engineer_Information_Processing/ch08_%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98%ED%85%8C%EC%8A%A4%ED%8A%B8%EA%B4%80%EB%A6%AC/%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98%ED%85%8C%EC%8A%A4%ED%8A%B8%EC%BC%80%EC%9D%B4%EC%8A%A4%EC%84%A4%EA%B3%84/%ED%95%B5%EC%8B%AC%EC%A0%95%EB%A6%AC/"},{"title":"애플리케이션테스트케이스설계 - 애플리케이션 테스트 결과 분석","text":"애플리케이션테스트케이스설계 소프트웨어 결함 용어 에러 Error / 오류 결함 Defect 의 원인 사람에 의해 생성된 실수 결함 / 결점 / 버그 Bug 에러 또는 오류가 원인 소프트웨어 제품에 포함되어 있는 결함 제거하지 않을 시 제품 실패 또는 문제가 발생 실패 / 문제 소프트웨어 제품에 포함된 결함이 실행 될 때 발생 테스트 완료 조건 단위 테스트, 통합 테스트, 시스템 테스트, 인수 테스트 등 각 단계별 테스트를 언제 어떤 상황에서 종료할 것인지 결정 완료 조건은 일정, 비용ㅇ, 조직등에 제약이 있으므로 최적의 완료조건을 계획 테스트 결함 관리 각 단계별 테스트 수행 후 발생한 결함의 재발 방지를 위해, 유사 결함 발견시 처리 시간 단축을 위해 결함을 추적하고 관리하는 활동 결함 추적 관리 활동 결함 관리 도구 유형 오픈소스 Bugzilla Trac Mantis 상용도구 QC Clear Quest JIRA 결함 관리 도구 도입 시 고려사항 웹 클라이언트 지원을 하는지 확인이 필요 윈도우, 유닉스 환경 등 이기종 플랫폼의 웹 서버를 지원하는지 확인 프로세스 및 워크플로우 변경이 가능 해야함 결함 간에 연관 관계 정보를 제공 결함 등록 및 상태 변경 시 담당자에게 이벤트 통보 기능 필요 각종 레포트, 차트, 쿼리 구성 및 저장이 가능 결함 상태 변경에 대한 추적 기능 다국어 지원이 가능 다중 프로젝트 지원이 가능","link":"/2020/05/21/Engineer_Information_Processing/ch08_%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98%ED%85%8C%EC%8A%A4%ED%8A%B8%EA%B4%80%EB%A6%AC/%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98%ED%86%B5%ED%95%A9%ED%85%8C%EC%8A%A4%ED%8A%B8/%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98%ED%85%8C%EC%8A%A4%ED%8A%B8%EA%B2%B0%EA%B3%BC%EB%B6%84%EC%84%9D/"},{"title":"애플리케이션테스트케이스설계 - 애플리케이션테스트시나리오작성","text":"애플리케이션테스트케이스설계 테스트 시나리오 개념 테스트 수행을 위한 여러 테스트 케이스의 집합 테스트 케이스의 동작 순서를 기술한 문서이며 테스트를 위한 절차를 명세한 문서 테스트 시나리오 작성시 유의사항 테스트 항목을 하나의 시나리오에 모두 작성하지 않고, 시스템별, 모듈별, 항목별 테스트 시나리오를 분리하여 작성 고객의 요구사항과 설계 문서 등을 토대로 작성 테스트 항목 식별자 번호 순서 번호 테스트 데이터 테스트 케이스 예상 결과 확인 테스트 환경 구축의 개념 개발된 응용 소프트웨어가 실제 운영 시스템에서 정상적으로 작동하는지 테스트 할 수 있또록 하기 위하여 실제 운영 시스템과 동일 또는 유사한 사양의 하드웨어, 소프트웨어, 네트워크 등의 시설을 구축하는 활동 테스트 환경 구축시 유의점 테스트 환경의 분리 개발을 위한 환경과 테스를 위한 환경이 물리적으로 분리되는 것이 좋음 가상 머신 기반의 서버나 클라우드 환경의 이용 별도의 테스트가 어려울시 가상머신 서버나 클라우드 환경을 이용하여 일시적 테스트하는 것도 좋음 네트워크 분할과 공유디스크 관리 물리적 환경 분리가 불가능하면 VLAN과 같은 소프트웨어를 이용하여 논리적으로 분할 연동 시스템의 테스트 환경 다른 시스텤과 연동을 위한 시스템의 경우 연동 시스템에 대한 테스트 환경이 별도 구성 소프퉤어 테스트 관련 국제표준 IS0/IEC 29119 테스트 지식 체계 개념 전체 시리즈에 대한 가이드를 제공해 주는 부분 소프트웨어 테스팅 개념 조직과 프로젝트 관점에서의 소프트웨어 테스팅 소프트웨어 생명 주기 모델에서의 일반적인 테스팅 프로세스 위험 기반 테스팅 테스트 서브 프로세스 테스트 프로세스 조직, 테스트 관리, 동적 테스트의 3가지 수준의 다계층 프로세스 모델을 설명 다계층 프로세스 모델 조직의 테스트 프로세스 테스트 관리 프로세스 동적 테스트 프로세스 테스트 문서화 테스트 프로세스 단계별 산출문의 견본제시 및 작성방법 설명 조직의 테스트 프로세스 문서 테스트 관리 프로세스 문서 동적 테스트 프로세스 문서 키워드 주도 테스팅 사전 정의된 키워드의 모음으로 테스트 케이스를 만드는 것 테스트 단계에서 자연어 대신 키워드를 사용함으로써 테스트 케이스는 이해하기 쉽고 유지보수가 용이","link":"/2020/05/21/Engineer_Information_Processing/ch08_%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98%ED%85%8C%EC%8A%A4%ED%8A%B8%EA%B4%80%EB%A6%AC/%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98%ED%85%8C%EC%8A%A4%ED%8A%B8%EC%BC%80%EC%9D%B4%EC%8A%A4%EC%84%A4%EA%B3%84/%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98%ED%85%8C%EC%8A%A4%ED%8A%B8%EC%8B%9C%EB%82%98%EB%A6%AC%EC%98%A4%EC%9E%91%EC%84%B1/"},{"title":"애플리케이션테스트케이스설계 - 애플리케이션테스트케이스작성","text":"애플리케이션테스트케이스설계 개발하고자 하는 응용 소프트웨어의 특성을 반영한 테스트 방식, 대상과 범위를 결정하여 테스트 케이스를 작성 테스트 방식, 대상과 범위가 적용된 시나리오를 정의 테스트 데이터, 테스트 시작 및 종료 조건 등을 준비 소프트웨어 테스트의 개념 구현된 응용 애플리케이션이나 시스템이 사용자가 요구하는 기능의 동작과 성능, 사용성, 안정성 등을 만족하는지 확인하기 위하여 소프트웨어의 결함을 찾아내는 행동 소프트웨어 테스트의 필요성 오류 발견 관점 프로그램에 잠재된 오류를 발견하고 이를 수정하여 올바른 프로그램을 개발하는 활동 오류 예방 관점 프로그램 실행 전에 코드 리뷰, 동료 검토, 인스펙션 등을 통해 오류를 사전에 발견하는 예방 차원의 활동 품질 향상 관점 사용자의 요구사항 및 기대 수준을 만족하도록 반복적인 테스트를 거쳐 제품의 신뢰도를 향상하는 품질보증활동 소프트웨어 테스트의 기본 원칙 테스팅은 결함이 존재함을 밝히는 활동 완벽한 테스팅은 불가능 개발 초기에 시작 결함 집중 살충제 패러독스 주기적으로 테스트 케이스를 리뷰하고 개선 테스팅은 정황에 의존식 테스트 대상에 따라 테스트를 다르게 수행 오류-부재의 궤변 사용자 요구사항을 만족하지 못하는 결함을 찾고 수정하는 것은 무의미 소프트웨어 테스트의 프로세스 테스트 프로세스 유형은 테스트 계획 수립 단계와 수행 단계, 결과 보고 단계에 따라 테스트 프로세스 유형이 다름 소프트웨어 테스트 산출물 테스트 계획서 목적과 범위 정의 대상 시스템 구조 파악 테스트 수행 절차 테스트 일정 조직의 역할 및 책임 정의 종료 조건 정의 테스트 케이스 설계 산출물 명세서 입력값 실행 조건 기대 결과 테스트 시나리오 테스트 케이스의 집합 절차를 명세한 문서 테스트 결과서 테스트 프로세스를 리뷰 테스트 결과물 평가하고 리포팅하는 문서 소프트웨어테스트 분류 정적 테스트 : 프로그램 실행 없이 테스트 코드를 실행하지 않고 여러 참가자가 모여 소프트웨어 개발 중에 생성되는 모든 명세나 코드를 검토 정적 테스트 기술적 검토기법 개별 검토 동료 검토 검토 회의 관리적 검토기법 검사 감사 동적 테스트 : 테스트 데이터를 이용해 프로그램 실행 테스트 명세 기반 테스트(블랙박스 테스트) 코드를 열어 오류를 찾지 않고 입력값에 대한 예상값을 정해 놓고 그대로 결과가 나오는지 확인 방법 신택스 동등분할 경계값분석 원인-결과 그래프 의사결정 테이블 페어와이즈 구조 기반 테스트(화이트박스 테스트) 프로그램을 보면서 내부 논리 흐름에 따라 테스트 케이스를 작성하고 확인 방법 구문 기반 결정 기반 조건 기반 조건결정 기반 변경조건 결정 기반 멀티 조건 기반 커버리지 테스트 테스트 케이스 개념 명세 기반 테스트 설계 산출물 특정한 요구사항을 준수하는지 확인하기 위해 설계된 입력 값, 실행 조건, 기대 결과로 구성된 테스트 항목의 명세서 테스트 케이스 작성 절차 테스트 계획 검토 및 자료 확보 시스템 요구사항 기능 명세서 검토 위험평가 및 우선순위 결정 상대적 중요성과 테스트의 초점 결정 테스트 요구사항 정의 시스템 요구사항 테스트 대상 재검토 테스트 할 특성, 조건, 기능 테스트 구조 설계 및 테스트 방법 결정 테스트 절차, 장비, 도구, 문서화 방법 테스트 케이스 정의 테스트 케이스 입력 값 실행 조건 예상 결과 테스트 케이스 타당성 확인 및 유지보수 유용성 검토 테스트 오라클의 개념 테스트의 결과가 참인지 거짓인지를 판단하기 위해서 사전에 정의된 참 값을 입력하여 비교하는 기법 유형 참 오라클 모든 입력 값에 대하여 기대하는 결과를 생성 샘플링 오라클 특정한 몇 개의 입력 값에 대해서 휴리스틱 오라클 특정 입력 값에 대해 올바른 결과를 제공하고 나머지 값들에 대해 추정으로 처리 일관성 검사 애플리케이션 변경이 있을 때, 수행 전과 후의 결과 값이 동일한지 확인 V모델과 테스트 단계 테스트 단계별 기능 검증 사항 단위 테스트 프로그램의 기본 단위인 모듈(함수, 서브루틴, 컴포넌트)의 기능 수행 여부를 판정하고 내부에 논리적 오류 검출 통합 테스트 모듈 간의 인터페이스 연계를 검증 모듈 간의 인터페이스 오류를 확인 상호 작용 및 연계 동작 여부 판정하는 방안 파악 시스템 테스트 시스템 전체가 정상적으로 동작하는지 기능적, 비기능적 명세를 확인 인수 테스트 사용자가 요구분석 명세서에 명시된 사항을 모두 충족하는지 판정 시스템이 예상대로 동작하고 있는지 점검","link":"/2020/05/20/Engineer_Information_Processing/ch08_%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98%ED%85%8C%EC%8A%A4%ED%8A%B8%EA%B4%80%EB%A6%AC/%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98%ED%85%8C%EC%8A%A4%ED%8A%B8%EC%BC%80%EC%9D%B4%EC%8A%A4%EC%84%A4%EA%B3%84/%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98%ED%85%8C%EC%8A%A4%ED%8A%B8%EC%BC%80%EC%9D%B4%EC%8A%A4%EC%9E%91%EC%84%B1/"},{"title":"애플리케이션테스트케이스설계 - 핵심정리","text":"애플리케이션테스트케이스설계 1. 애플리케이션 통합 테스트 수행 통합 테스트에 대한 개념 이해, 통합 테스트 수행 방법 테스트 자동화 도구와 개념 유형 2. 애플리케이션 테스트 결과 분석 소프트웨어 결함관련 용어, 테스트 완료 조건 테스트 결함 관리 개념과 결함 관리 도구","link":"/2020/05/21/Engineer_Information_Processing/ch08_%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98%ED%85%8C%EC%8A%A4%ED%8A%B8%EA%B4%80%EB%A6%AC/%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98%ED%86%B5%ED%95%A9%ED%85%8C%EC%8A%A4%ED%8A%B8/%ED%95%B5%EC%8B%AC%EC%A0%95%EB%A6%AC/"},{"title":"애플리케이션테스트케이스설계 - 애플리케이션 통합 테스트 수행","text":"애플리케이션테스트케이스설계 개발자 통합 테스트 계획에 따라 통합 모듈 및 인터페이스가 요구 사항을 충족하는지에 대한 테스트를 수행 개발자 통합 테스트 수행 결과 발견된 결함에 대한 추이 분석을 통하여 잔존 결함을 추정 테스트의 충분석 여부를 검증하고 발견된 결함에 대한 개선 조치사항을 작성 통합 테스트의 개념 소프트웨어 각 모듈 간의 인터페이스 관련 오류 및 결함을 찾아내기 위한 체계적인 테스트 기법 통합 테스트 수행 방법의 분류 일반적으로 점증적인 방법과 비점증적인 방식으로 나뉨 비점증적 방법 모든 컴포넌트를 사전에 통합하여 전체 프로그램을 한꺼번에 테스트 점증적 방법 상향식 통합 하향식 통합 하향식 통합 Top Down 메인 제어 모듈로부터 아래 방향으로 제어의 경로를 따라 이동하면서 하향식으로 통합하면서 테스트를 진행 메인 제어 모듈은 작성된 프로그램을 사용하고, 아직 작성되지 않은 하위 제어 모듈 및 모든 하위 컴포넌트를 대신하여 더미 모듈인 스텁을 개발 깊이 우선 방식 또는 너비 우선 방식에 따라 하위 모듈인 스텁이 한 번에 하나씩 실제 모듈로 대체 상향식 통합 Bottom Up 애플리케이션 구조에서 최하위 레벨의 모듈 또는 컴포넌트로부터 위쪽 방향으로 제어의 경로를 따라 이동하면서 구축과 테스트 시작 최하위 레벨의 모듈 또는 컴포넌트들이 하위 모듈의 기능을 수행하는 클러스터로 결합 상위의 모듈에서 데이터의 입력과 출력을 확인하기 위한 더미 모듈 인 드라이버를 작성 각 통합된 클러스터 단위를 테스트 테스트가 완료되면 각 클러스터들은 프로그램의 위쪽으로 결합되며, 드라이버는 실제 모듈 또는 컴포넌트로 대체 회귀 테스팅 Regression Testing 통합 테스트 과정에서 오류를 제거하거나 수정한 프로그램이 새로운 형태의 오작동이나 오류를 일으킬 수 있음 회귀 테스트는 모듈이나 컴포넌트의 변화로 인해 의도하지 않은 오류가 생기지 않았음을 보증하기 위해 반복 테스트하는 것 회귀 테스트 케이스 선정 방법 모든 애플리케이션의 기능을 수행할 테스트 케이스의 대표적인 샘플을 도출 변경에 의한 영향도가 가장 높은 애플리케이션 기능에 집중한 추가적인 테스트 케이스를 도출 실제 수정이 발생한 모듈 또는 컴포넌트에서부터 시행하는 테스트 케이스를 도출 테스트 자동화의 개념 테스트 도구를 활용하여 반복적인 테스트 작업을 스크립트 형태로 구현 테스트 시간 단축과 인력 투입 비용을 최소하 운영중인 시스템의 모니터링 또는 UI가 없는 서비스의 경우에도 정밀한 테스트 수행 테스트 자동화의 장점과 단점 장점 반복되는 테스트 데이터 재입력 작업의 자동화 사용자 요구 기능의 일관성 검증에 유리 테스트 결과 값에 대한 객관적인 평가 기준 제공 테스트 결과의 통계 작업과 그래프 등 다양한 표시 형태 제공 UI가 없는 서비스의 경우에도 정밀한 테스트 가능 단점 도구 도입 후 도구 사용 방법에 대한 교육 및 학습이 필요 도구를 프로세스 단계별로 적용하기 위한 시간, 비용, 노력이 필요 사용 도구의 경우 고가, 유지 관리 비용이 높아 추가 투자 필요 정적 분석 도구 Static Analysis Tools 프로그램을 실제로 실행해 보지 않고 분석하는 방법 대부분의 경우 소스 코드에 대한 코딩 표준, 코딩 스타일, 코드 복잡도 및 남은 결함을 발견하기 위해 사용 테스트를 수행하는 사람이 작성된 소스 코드에 대한 이해를 기반한 자동화된 도구 활용한 분석 수행 테스트 실행 도구 Test Execution Tools 테스트를 위해 작성된 스크립트를 실행 데이터 주도 접근 테스트 데이터를 스프레드 시트에 저장하고, 이 데이터를 읽고 실행할 수 있도록 함 다양한 테스트 데이터를 이용하여 동일한 테스트 케이스르 반복 실행 스크립트 언어에 익숙하지 않은 테스터도 미리 작성된 스크립트에 테스트 데이터만 추가하여 쉽게 테스트를 수행 키워드 주도 접근 방식 스프레드시트에 테스트를 수행할 동작을 나타내는 키워드와 테스트 데이터를 저장 키워드를 이용하여 테스트 수행 동작을 정의 테스트 대상 애플리케이션의 특성에 맞추어 키워드에 대해 테일러링을 수행 성능 테스트 도구 Performance Test Tools 애플리케이션의 처리량, 응답 시간, 경과 시간, 자원 사용률에 대해 가상의 사용자를 생성하고 테스트를 수행함으로써 성능 목표를 달성하였는지를 확인하는 도구 테스트 통제 도구 Test Control Tools 테스트 계획 및 관리를 위한 테스트 관리 도구 테스트 수행에 필요한 데이터와 도구를 관리하는 형상 관리 도구 테스트에서 발생한 결함에 대해 관리하거나 협업을 지원하기 위한 결함 추적/관리 도구 조직의 요구사항에 최적화된 형태의 정보를 생성, 관리하기 위하여 &lt;u트스프레드시트 등 다른 도구들과 연계하여 사용 테스트 장치 Test Harness 애플리케이션 컴포넌트 및 모듈을 테스트하는 환경의 일부분으로, 테스트를 지원하기 위한 코드와 데이터를 말하며, 단위 또는 모듈 테스트에 사용하기 위해 코드 개발자가 작성 구성요소 테스트 드라이버 상향식 테스트에 필요 테스트 스텁 하향식 테스트에 필요 테스트 슈트 대상 모듈, 테스트 케이스 집합 테스트 케이스 입력 값, 실행조건, 기대 결과 테스트 스크립트 자동화된 스크립트 실행 절차 목 Mock 오브젝트 행위를 조건부로 사전에 입력 테스트 자동화 도구 소프트웨어 테스트 관리 지원 도구 실행된 테스트와 테스트 활동 관리를 지원하며 테스트 실행 도구나 결함 추적 도구, 요구사항 관리 도구와의 인터페이스 역할 결함이 발견, 분배, 수정, 확인, 종료되는 결함의 생명주기 관리 테스트 진행 상황에 대한 리포트 생성, 발견된 결함의 정량적인 분석을 지원 오픈 소스 결함관리 Mantis, Bugzilla 테스트 케이스 관리 도구 Testlink 형상 관리 도구 CVS, SVN, Git, Bazar 커뮤니케이션 도구 MediaWiki, Dokuwiki 통합프로젝트 지원 도구 Trac, nForge, Gforge 상용 소스 버그 추적 JIRA, TPMS, Test Director 형상 관리 Visual Sourcesafe, IBM, Clear Case 커뮤니케이션 Confluence 소프트웨어 정적 분석 지원 도구 리뷰 프로세스에 관한 정보를 저장, 리뷰 코멘트를 저장 정적 분석 도구는 동적 테스트를 하기 전에 결함을 발견할 수 있도록 지원 코딩 표준을 지킬 것을 강제하고 구조와 의존 관계를 분석 소스 코드의 복잡도를 측정 오픈소스 PMD Valgrind Find Bugs CPPCheck Corbetrua 상용 소스 Coverity IBM Rtional Software PloySpace 소프트웨어 테스트 실행 및 로깅 지원 도구 스크립트 언어의 도움으로 저장된 입력 값과 예상 결과를 이용하여 테스트를 실행하고 결과와 비교 테스트 대상이 실행되는 환경을 시뮬레이션, 테스트 Harness 도구 오픈 소스 테스트 프레임워크 xUnit, TestNG, FIT Jmock, Easymock, Googlemock 지속적인 통합 CruiseControl, hudson, jenkinson 빌드자동화 Ant, Maven, Make 실행자동화 STAF/STAX, Selenium 상용 소스 WinRunner Jtest CodeScroll 소프트웨어 성능 및 모니터링 도구 소프트웨어가 실행도중에만 발생하는 시간 의존성과 메모리 누수와 같은 결함 발견에 활용 소프트웨어 성능/부하/스트레스를 테슽 특정 시스템 리소스의 사용량을 지속적으로 분석하고 확인 오픈 소스 Jmeter OpenSTA allomon 상용 소스 E-load LoadRunner Webload Robot","link":"/2020/05/21/Engineer_Information_Processing/ch08_%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98%ED%85%8C%EC%8A%A4%ED%8A%B8%EA%B4%80%EB%A6%AC/%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98%ED%86%B5%ED%95%A9%ED%85%8C%EC%8A%A4%ED%8A%B8/%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98%ED%86%B5%ED%95%A9%ED%85%8C%EC%8A%A4%ED%8A%B8%EC%88%98%ED%96%89/"},{"title":"인터페이스설계확인 - 오류처리 확인 및 보고서 작성","text":"인터페이스설계확인 사용자 화면에서 오류를 발생 사용자 화면에서 인터페이스 오류를 인지하는 방법은 가장 직관적으로 오류를 인지할 수 있음 인터페이스 오류가 발생하였을 경우 알람 형태로 화면에 표시 주로 즉시적으로 데이터가 인터페이스 되는 경우에 사용 인터페이스 오류 로그 생성 시스템 운영 로그에 인터페이스 오류 시 관련 에러 로그 생성 인터페이스 오류의 자세한 내역을 알기 위해서 사용되며, 시스템 관리자나 운영자가 오류 로그를 확인 인터페이스 관련 테이블에 오류 사항 기록 테이블을 통한 인터페이스 기능을 구현할 경우나 인터페이스 트랜잭션 기록을 별도로 보관하는 경우 테이블로 오류 사항 기록 장점은 이력을 직관적으로 보기 쉬워 운영자가 관리하기 편함 인터페이스 오류 처리 보고서 작성 및 보고 인터페이스 오류 발생시 상황인지 및 조치사항을 시간경과에 따라 작성 조직과 상황에 따른 보고서 양식을 사용 인터페이스에 대한 오류 보고는 조치가 완료된 후에 보고하면이미 시기가 늦은 경우가 많음 시기에 따라 조직에서 정의한 프로세스에 의하여 보고 인터페이스 오류 처리 보고 시기에 따른 보고서 특징","link":"/2020/05/20/Engineer_Information_Processing/ch09_%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4%EA%B5%AC%ED%98%84/%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4%EA%B5%AC%ED%98%84%EA%B2%80%EC%A6%9D/%EC%98%A4%EB%A5%98%EC%B2%98%EB%A6%AC%ED%99%95%EC%9D%B8%EB%B0%8F%EB%B3%B4%EA%B3%A0%EC%84%9C%EC%9E%91%EC%84%B1/"},{"title":"인터페이스설계확인 - 인터페이스 구현 검증","text":"인터페이스설계확인 구현된 인터페이스 명세서를 참조하여 구현 검증에 필요한 검시 및 도구를 준비 인터페이스 구현 검증을 위한 외부 시스템과의 연계 모듈 상태 확인 인터페이스 오류처리 사항을 확인하고 보고서를 작성 인터페이스 구현 검증 도구 인터페이스 단위 기능 및 시나리오에 기반한 통합 테스트 필요 테스트 자동화 도구를 이용하여 단위 및 통합 테스트의 효율성 제고 도구 xUnit STAF FitNesse NTAF Selenium watir 인터페이스 감시 도구 인터페이스의 동작이 잘 진행되는지 확인하기 위해서는 애플리케이션 모니터링툴 APM; Application Performance Management을 사용하여 동작 상태를 감시 데이터베이스, 웹 애플리케이션의 트랜잭션과 변수 값, 호출 함수, 로그, 시스템 부하등 종합적인 정보를 조회하고 분석 인터페이스 명세서 인터페이스 명세서에 정의된 데이터 전송주기, 전송량, 전송 포맷대로 수신 시스템에 데이터가 전송되었는지 확인 인터페이스 단위 및 통합 테스트 설계서 인터페이스 단위 및 통합 테스트 설계서를 활용하여 구현 검증 설계 인터페이스 명세서 기반 구현 검증 기법 구현된 인터페이스 명세서의 세부 기능을 참조하여 구현 검증 및 감시에 필요한 기능을 분석 인터페이스 테스트 설계서 기반 구현 검증 기법 인터페이스 구현 검증을 위하여 외부 시스템과 연계 모듈 상태 확인 인터페이스 테스트 결과 검증 방법 운영DB테이블의 건수를 카운트 하는 방법 실제 테이블이나 파일을 열어서 데이터를 확인하는 방법 파일 생성 위치의 파일 생성 여부와 파일 크기를 확인하는 방법 연계서버에서 제공하는 모니터링 화면의 내용을 확인하는 방법 시스템에 기록하는 로그를 확인하는 방법","link":"/2020/05/20/Engineer_Information_Processing/ch09_%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4%EA%B5%AC%ED%98%84/%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4%EA%B5%AC%ED%98%84%EA%B2%80%EC%A6%9D/%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4%EA%B5%AC%ED%98%84%EA%B2%80%EC%A6%9D/"},{"title":"인터페이스설계확인 - 핵심정리","text":"인터페이스설계확인 1. 인터페이스 구현 검증 인터페이스 구현 검증 도구, 감시도구 인터페이스 구현 검증에 필요한 설계 산출물 인터페이스 명세서 인터페이스 단위 및 통합 테스트 설계서 2. 인터페이스 오류 처리 확인 및 보고서 작성 인터페이스 오류 처리 방법 사용자 화면에서 오류를 발생 인터페이스 오류 로그 생성 인터페이스 관련 테이블에 오류 사항 기록","link":"/2020/05/20/Engineer_Information_Processing/ch09_%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4%EA%B5%AC%ED%98%84/%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4%EA%B5%AC%ED%98%84%EA%B2%80%EC%A6%9D/%ED%95%B5%EC%8B%AC%EC%A0%95%EB%A6%AC/"},{"title":"인터페이스설계확인 - 인터페이스 보안","text":"인터페이스설계확인 개발하고자 하는 응요소프트웨어와 연계 대상 모듈 간의 세부 설계서를 확인하여 일관되고 정형화된 인터페이스 기능 구현을 정의 공통적인 인터페이스 구현 실패 시 예외 처리 방안을 정의 인터페이스 보안 기능 적용 Sniffing 스니핑 데이터 통신 내역을 중간에서 감청하여 기밀성을 훼손할 수 있는 방법 주로 패킷 분석기 같은 툴을 통해서 진행 Secure Coding 시큐어 코딩 대표적인 엡 애플리케이션의 보안 취약점 발표 사례인 OWASP; Open Web Application Security Project 참고 KISA에서 SW보안 약점 가이드 발표 항목 입력 데이터 검증 및 표현 API 이용 보안 특성 시간 및 상태 에러 처리 코드 품질 캡슐화 네트워크 구간 보안 기능 적용 인터페이스 송수신 간 중간자에 의한 데이터 탈취 위/변조를 막기 위해서는 네트워크 트래픽에 대한 암호화 필요 아키텍처에 따라 다양한 방식으로 보안 기능 적용 애플리케이션 보안 기능 적용 애플리케이션 구현 코드상에 보안 취약점을 보안하는 방향으로 애플리케이션 보안 기능을 적용 고려사항 비인가자 접근 권한 관리 악의적 코드 삽입 금지 악의적 시도 시 에러 처리 데이터베이스에 보안 기능 적용 접근 권한 및 동작 개체의 보안 취약점을 보안하기 위해 보안 기능을 적용 민감 데이터는 데이터 자체의 보안 방안도 고려 고려사항 데이터베이스 접근 권한 악의적 코드 삽입 금지 민감 데이터 관리 악의적 시도시 에러 처리 데이터베이스 암호화 알고리즘 대칭 키 해시 비대칭 키 알고리즘 데이터베이스 암호화 기법 애플리케이션에서 암호화를 수행하는 API방식과 데이터베이스에서 아ㅁ호활르 수행하는 Plug-in방식, 이 둘을 혼합한 Hybrid방식","link":"/2020/05/20/Engineer_Information_Processing/ch09_%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4%EA%B5%AC%ED%98%84/%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4%EA%B8%B0%EB%8A%A5%EA%B5%AC%ED%98%84/%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4%EB%B3%B4%EC%95%88/"},{"title":"인터페이스설계확인 - 핵심정리","text":"인터페이스설계확인 1. 인터페이스 보안 인터페이스 보안 취약점에 대한 시큐어 코딩 항목 인터페이스 보안 기능 적용 네트워크 구간 애플리케이션 데이터베이스 데이터베이스 암호화 알고리즘 대칭키 해시 비대칭키 2. 소프트웨어 연계 테스트 내/외부 연계 모듈 구현에서 소프트웨어 연계 테스트는 송신 시스템과 수신 시스템 간에 연계 테스트를 의미 소프트웨어 연계 단위 테스트 소프트웨어 연계 단위 테스트 케이스 작성","link":"/2020/05/20/Engineer_Information_Processing/ch09_%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4%EA%B5%AC%ED%98%84/%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4%EA%B8%B0%EB%8A%A5%EA%B5%AC%ED%98%84/%ED%95%B5%EC%8B%AC%EC%A0%95%EB%A6%AC/"},{"title":"인터페이스설계확인 - 소프트웨어 연계 테스트","text":"인터페이스설계확인 소프트웨어 연계 테스트 내/외부 연계 모듈 구현에서 소프트웨어 연계 테스트는 송신 시스템과 수신 시스템 간에 연계 테스트를 의미 송신 시스템에서 중계 시스템을 거쳐서 수신 시스템까지 연계하였을 경우 데이터의 정합성 및 데이터 전송 여부를 테스트 소프트웨어 연계 테스트 구간 소프트웨어 연계 테스트 구간은 송신 시스템에서 연계 서버 또는 중계 서버를 거치고 수신 시스템까지 데이터가 저달되는지 테스트 소프트웨어 연계 단위 테스트 소프트웨어 연계 단위 테스트는 연계 자체만을 테스트 송신 시스템에서 연계 데이터를 추출 및 생성하고 이를 연계 테이블로 생성 연계 서버 또는 중계 서버가 있는 경우 연계 테이블 간 송수신 연계 서버 또는 중계 서버에서는 수신된 연계 테이블 생성 수신 시스템에서는 연계 테이블에서 연계 데이터를 수신 시스템으로 로드 소프트웨어 연계 통합 테스트 비즈니스 프로세서 흐름에 맞춰 연계 데이터 생성, 전송, 저장까지 보다 큰 통합 기능 테스트의 일부로서 연계 통합 테스트를 수행 인위적인 조작없이 비즈니스 프로세스 흐름에 맞춰 연계기능 점검 최종적으로 수신 시스템의 운영 DB에 반영된 데이터 검색 및 활용 소프트웨어 연계 테스트 케이스 작성 방법 송/수신 시스템에서 확인해야 할 사항을 각각 도출 송/수신 시스템 각각에서 단순 개별 데이터의 유효 값을 체크하는 경우의 수와 데이터 간의 연관관계를 체크하는 경우의 수로 식별하여 작성 단순 개별 데이터의 유효 값은 코드일 경우, 코드 테이블에 등록된 값의 여부 또는 유효 데이터 타입, 길이, 필수 입력 등의 체크 의미 데이터 간의 연관 관계 체크는 연계 서버 또는 중계 서버를 통하여 연관 관계가 주어진 규칙대로 데이터 변환을 시켜 주는지 점검 송신용 연계 응용 프로그램의 단위 테스트 케이스 작성 송신 시스템에서 연계 데이터 추출이 제대로 되었는지, 연계 데이터가 수신 시스템에 맞게 코드 변환이 되었는지를 테스트 연계 통합 테스트 케이스 작성 송신용 연계 응용프로그램과 수신용 연계 응용프로그램의 기능 위주 결함을 확인하는 통합 테스트 케이스로 작성","link":"/2020/05/20/Engineer_Information_Processing/ch09_%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4%EA%B5%AC%ED%98%84/%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4%EA%B8%B0%EB%8A%A5%EA%B5%AC%ED%98%84/%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4%EC%97%B0%EA%B3%84%ED%85%8C%EC%8A%A4%ED%8A%B8/"},{"title":"절차형SQL - DCL","text":"절차형SQL DCL; Data Control Language 정의 무결성, 보안 및 권한 제어, 회복을 위해 데이터베이스에 접근을 제어하는 SQL 명령어 DCL 조작 대상 오브젝트 목적 내용 사용자 권한 접근 통제 사용자를 등록하고, 사용자에게 특정 데이터베이스를 사용할 수 있는 권리를 부여하는 작업 트랜잭션 안전한 거래보장 동시에 다수의 작업을 독립적으로 안전하게 처리하기 위한 상호 작용 단위 DCL 유형과 명령어 트랜잭션 제어를 위한 명령어 TCL TCL; Transaction Control Language TCL과 DCL은 대상이 달라 서로 별개의 개념으로 분류할 수 있으나, 제어 기능의 공통점으로 DCL의 일부료 분류함 명령어 DCL GRANT : 사용자 권한 부여 REVOKE : 사용자 권한 회수 TCL COMMIT : 트랜잭션 확정 ROLLBACK : 트랜잭션 취소 SAVEPOTINT : 복귀지점 설정 사용자 권한 부여 권한은 시스템 권한과 객체 권한으로 분류 시스템 권한 1GRNAT 권한1, 권한2 TO 사용자 계정 객체 권한 1GRNAT 권한1, 권한2 ON 객체명 TO 사용자 계정 시스템 권한과 객체 권한의 종류 시스템 권한 CREATE USER : 계정 생성 권한 DROP USER : 계정 삭제 권한 DROP ANY TABLE : 테이블 삭제 권한 CREATE SESSION : 데이터베이스 접속 권한 CREATE TABLE : 테이블 생성 권한 CREATE VIEW : 뷰 생성 권한 CREATE SEQUENCE : 시퀀스 생성 권한 CREATE PROCEDURE : 프로시저 생성 권한 객체 권한 ALTER : 테이블 변경 권한 INSERT : 데이터 조작 권한 DELETE : 데이터 조작 권한 SELECT : 데이터 조작 권한 UPDATE : 데이터 조작 권한 EXECUTE : PROCEDURE 실행 권한 사용자 권한 회수 GRANT에 대응하는 권한 회수 명령은 REVOKE 시스템 권한 1REVOKE 권한1, 권한2 FROM 사용자계정 객체 권한 1REVOKE 권한1, 권한2 ON 객체명 FROM 사용자계정","link":"/2020/05/18/Engineer_Information_Processing/ch10_SQL%EC%9D%91%EC%9A%A9/%EC%9D%91%EC%9A%A9SQL/DCL/"},{"title":"절차형SQL - 오류처리","text":"절차형SQL 오류처리의 개념 프로그램 코드 상의 구문 오류 또는 프로그램 실행시 상황에 따라 발생하는 오류를 처리하는 과정 오류 처리 방법 오류 복구 예외상황을 파악하고 문제를 해결하여 정상상태로 돌려 놓는것 오류 회피 예외 처리를 자신을 호출한 쪽으로 던져 버림 오류 전환 예외를 메소드 밖으로 던지지만 예외 회피와 달리 적절한 예외로 전환해서 던짐","link":"/2020/05/18/Engineer_Information_Processing/ch10_SQL%EC%9D%91%EC%9A%A9/%EC%9D%91%EC%9A%A9SQL/%EC%98%A4%EB%A5%98%EC%B2%98%EB%A6%AC/"},{"title":"절차형SQL - 집계성DCL작성","text":"절차형SQL 데이터 분석 함수의 정의 관계형 데이터베이스에서는 단일행 기준의 처리가 주로 이루어지나 총합, 평균 등의 데이터 분석은 복수 행 기준의 데이터를 모아서 처리 다중행 처리를 목적으로 하는 다중 행 함수가 존재 데이터 분석 함수의 특성 단일행을 기반으로 산출하지 않고 복수 행을 그룹별로 모아 놓고 그룹당 단일 계산 결과를 반환 GROUP BY 구문을 활용하여 복수행을 그룹핑 데이터 분석 함수의 유형 데이터 튜플 간의 상호 연관 및 계산 분석을 위한 세 가지 집계 함수 그룹 함수 윈도우 함수 집계 함수는 명령어도 상대적으로 단순하며 이를 기본으로 하여 그룹 함수나 윈도우 함수에도 적용 집계 함수는 그룹 함수의 한 부분 집계 함수의 구문 GROUP BY 구문 뒤에 테이블을 구분하는 컬럼을 기재하여 그룹화 HAVING 구문은 WHERE 조건으로 지정된 데이터 집합으로 부터 그룹화 된 집합에 대한 조건 선택 시에 사용 집계함수의 분류 COUNT(입력값) 복수 행의 줄 수 SUM(입력값) 복수 행의 해당 컬럼 간의 합계 AVG(입력값) 복수 행의 해당 컬럼 간의 평균 MAX(입력값) 복수 행의 해당 컬럼 간의 최댓값 MIN(입력값) 복수 행의 해당 컬럼 간의 최솟값 STDDEV(입력값) 복수 행의 해당 컬럼 간의 표준편차 VARIAN(입력값) 복수 행의 해당 컬럼 간의 분산 그룹 함수의 개념 소계 및 총계등을 구하기 위해서 집계 함수만 사용한다면 레벨별 집계를 위한 각 단계별 데이터 질의어를 UNION ALL 등으로 결합하고 표시하는 단계 필요 단일 DQL만으로도 원하는 작업 가능 정렬이 필요한 경우 ORDER BY절에 정렬 컬럼 명시 그룹 함수의 종류 ROLLUP 소계 등 중간 집계 값을 산출 위한 칼럼을 ROLLUP 뒤 기재 지정 칼럼의 수 보다 하나 더 큰 레벨의 중간 집계 값이 생성 SELECT 뒤에 포함되는 칼럼이 GROUP BY 또는 ROLLUP 뒤에 기재되어야 한다는 점 숙지 CUBE 결합 가능한 모든 값에 대해 다차원 집계를 생성하며, 가능한 한 소집계만을 생성하는 ROLLUP과 구별 내부적으로 대상 컬럼의 순서를 변경하여 또 한 번의 쿼리를 수행 지정 컬럼의 순서가 바뀌어도 결과는 같음 GROUPING SETS 원하는 특정 항목에 대한 다양한 소계 집합 계산 가능 집계 대상 칼럼 들에 대한 개별 집계를 구할 수 있고 칼럼 간 순서가 바뀌어도 정렬 순서는 바뀔 수 있으나 결과는 같음 윈도우 함수의 개념 데이터베이스를 사용한 온라인 분석 처리 용도로 사용하기 위해서 표준 SQL에 추가된 기능 온라인 분석 처리는 시장 분석, 통계 작성, 경영 계획 분석 및 수립 등 비즈니스 현장에서 자주 사용되는 분석이 포함 데이터 기반 의사 결정의 증가에 따라 그 중요성이 더욱 증가하는 실정 윈도우 함수의 구분 PARTITION BY는 선택 항목이며 순위를 정할 대상 범위의 컬럼을 설정 OVER문구가 필수적으로 포함되며, ORDER BY 뒤에는 SORT컬럼을 입력 윈도우 함수의 종류 집계함수 SUM MAX MIN AVG COUNT 순위함수 RANK : 레코드의 순위를 계산하며, 동일 순위 레코드 존재 시 후 순위는 넘어감 DENSE_RANK : “”, 동일 순위의 레코드 존재 시에도 후순위를 넘어가지 않음 ROW_NUMBER : “”, 동일 순위의 값이 존재해도 이와 무관하게 연속 번호 부여 그룹 내 비율 함수 RATIO_TO_REPORT PERCENT_RANK CUME_DIST NTILE 행 순서 함수 FIRST_VALUE LAST_VALUE LAG LEAD","link":"/2020/05/18/Engineer_Information_Processing/ch10_SQL%EC%9D%91%EC%9A%A9/%EC%9D%91%EC%9A%A9SQL/%EC%A7%91%EA%B3%84%EC%84%B1SQL/"},{"title":"절차형SQL - 핵심정리","text":"절차형SQL 1. DML 데이터를 조작하는 명령어이며, 여기서 조작은 데이터 관점에서 생명 주기를 제어하는 것을 의미 종류 INSERT UPDATE DELETE SELECT 2. DCL 무결성, 보안 및 권한 제어, 회복을 위해 데이터베이스에 접근을 제어하는 SQL 명령어 종류 GRANT REVOKE COMMIT ROLLBACK 3. 집계썽 SQL 작성 단일행을 기반으로 산출하지 않고 복수 행을 그룹별로 모아 놓고 그룹당 단일 계산 결과를 반환 GROUP BY 구문을 활용하여 복수 행을 그룹핑 SELECT, HAVING, ORDER BY 등의 구문에 활용 종류 집계함수 COUNT SUM AVG MAX MIN 그룹함수 ROLLUP CUBE GROUPING SETS 윈도우 함수 순위 함수 그룹 내 비율 함수 행 순서 함수 4. 오류 처리 프로그램 코드 상의 구문 오류 또는 프로그램 실행시 상황에 따라 발생하는 오류를 처리하는 과정 방법 오류 복구 오류 회피 오류 전환","link":"/2020/05/18/Engineer_Information_Processing/ch10_SQL%EC%9D%91%EC%9A%A9/%EC%9D%91%EC%9A%A9SQL/%ED%95%B5%EC%8B%AC%EC%A0%95%EB%A6%AC/"},{"title":"인터페이스설계확인 - 데이터표준확인","text":"인터페이스설계확인 인터페이스 데이터 표준 개념 인터페이스를 위해 인터페이스가 되어야 할 범위의 데이터들의 형식과 표준을 정의 한 것 인터페이스 데이터 형태의 동일 여부에 따라 기존에 있었던 데이터 중 공통의 영역을 추출하여 정의하는 경우도 있고 인터페이스를 위해 한 쪽의 데이터를 변환하는 경우도 있음 인터페이스 데이터 표준 확인 인터페이스 구현 전에 개발자는 인터페이스 데이터 표준을 확인 인터페이스 구현 시 데이터 표준을 준수하여 구현 Json, DB, XML 등 다양한 형태로 인터페이스 모듈의 표현이 가능","link":"/2020/05/20/Engineer_Information_Processing/ch09_%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4%EA%B5%AC%ED%98%84/%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4%EC%84%A4%EA%B3%84%ED%99%95%EC%9D%B8/%EB%8D%B0%EC%9D%B4%ED%84%B0%ED%91%9C%EC%A4%80%ED%99%95%EC%9D%B8/"},{"title":"인터페이스설계확인 - 인터페이스기능확인","text":"인터페이스설계확인 인터페이스 설계서를 기반으로 외부 및 내부 모듈 간 공통적으로 제공되는 기능과 각 데이터의 인터페이스를 확인 개발하고자 하는 응용소프트웨어와 관련된 외부 및 내부 모듈 간의 연계가 필요한 인터페이스 기능을 식별 용어사전 EAI; Enterprise Application Integrtion 기업에서 운영된느 서로 다른 플랫폼 및 애플리케이션들 간의 정보 전달, 연계, 통합을 가능하게 해주는 솔루션 ESB; Enterprise Service Bus 애플리케이션보다는 서비스 중심으로 통합을 지향하는 아키텍처 인터페이스 기능 개념 내부와 외부 모듈 간 연계 기능 인터페이스 기능 확인 방법 인터페이스 목록과 인터페이스 명세서를 포함한 인터페이스 설계서를 통한 인터페이스 기능 확인 시스템의 정적/동적 모형을 통한 인터페이스 기능 확인 인터페이스 되는 데이터명세 정의를 통한 인터페이스 기능 확인 인터페이스 설계서 개념 이기종 시스템 또는 컴포넌트 간 데이터 교환 및 처리를 위한 목적으로 인터페이스 현황을 한눈에 확인하기 위하여 시스템이 갖는 인터페이스 목록과 각 인터페이스의 상세 데이터 명세와 각 기능의 세부 정보를 정의한 인터페이스 정의서로 구성 시스템 인터페이스 목록 개념 연계 업무와 연계에 참여하는 송수신 시스템의 정보, 연계방식과 통신 유형 등에 대한 정보를 포함 시스템 인터페이스 명세서 개념 데이터 송신 시스템과 수신 시스템 간의 데이터 저장소와 속성 등의 상세 내역을 포함 상세 기능별 인터페이스 정의서 개념 인터페이스를 각 세부 기능의 개요, 세부 기능이 동작하기 전에 필요한 사전 조건, 사후 조건 및 인터페이스 파라미터, 호출 이후 결과를 확인하기 위한 반환 값등을 정의한 문서 정적/동적 모형을 통한 인터페이스 기능 확인 시스템을 구성하는 주요 구성 요소 간 트랜잭션을 보여 주고, 이를 통해 시스템에서 인터페이스는 어디에 속하고 어떤 트랜잭션이 인터페이스를 통해 상호 교환되는지 확인 데이터 명세 정의를 통한 인터페이스 기능 확인 제공 시비스 목록과 이에 대한 인터페이스 방식 및 명세, 리턴 형태까지 정의를 상세화하여 개발 수준에서 인터페이스 기능 확인 내부, 외부 모듈 연계 방법 1. EAI의 개념 기업에서 운영된느 서로 다른 플랫폼 및 애플리케이션들 간의 정보 전달, 연계, 통합을 가능하게 해주는 솔루션 EAI를 사용함으로써 각 비즈니스 간 통합 및 연계성을 증대 시켜 효율성을 높여 줄 수 있으며 각 시스템 간의 확정성을 높여줌 2. EAI의 구축 유형 3. ESB의 개념 애플리케이션보다는 서비스 중심으로 통합을 지향하는 아키텍처 웹 서비스 중심으로 표준화된 데이터, 버스를 통해 이기종 애플리케이션을 유연하게 통합하는 핵심 플랫폼","link":"/2020/05/19/Engineer_Information_Processing/ch09_%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4%EA%B5%AC%ED%98%84/%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4%EC%84%A4%EA%B3%84%ED%99%95%EC%9D%B8/%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4%EA%B8%B0%EB%8A%A5%ED%99%95%EC%9D%B8/"},{"title":"절차형SQL - DML","text":"절차형SQL 한 개의 테이블에 대해 데이터를 삽입, 수정, 삭제하고 행을 조회하는 DML 명령문을 작성 윈도우 함수와 그룹 함수를 사용하여 순위와 소계, 중계, 총합계를 산출하는 DML 명령문을 작성 사용자의 그룹을 정의하여 사용자를 생성 또는 변경할 수 있고 사용자의 권한 부여와 회수를 위한 DCL 명령문을 작성 DML; Data Manipulation Language 정의 데이터를 조작하는 명령어이며, 여기서 조작은 데이터 관점에서 생명 주기를 제어하는 것을 의미 DML 유형 구분 명령어 내용 데이터 생성 INSERT 삽입 형태로 신규 데이터를 테이블에 저장 데이터 조회 SELECT 테이블의 내용을 레코드 단위로 조회 데이터 변경 UPDATE 테이블의 내용을 레코드 단위로 변경 데이터 삭제 DELETE 테이블의 내용을 레코드 단위로 삭제 데이터 삽입 INSERT 데이터를 삽입하기 위한 명령어로 다음과 같이 두 가지 형태의 명령문 형식 제공 데이터 삽입 결과로 하나의 레코드가 추가되므로 삽입에 사용되는 정보는 하나의 레코드를 충분히 묘사해야 함 기본형식 12INSERT INTO table_name VALUES(value1, value2,...);INSERT INTO table_name(column1, column2, ...) VALUES(value1, value2, ...); 데이터 조회 SELECT 레코드 단위로 데이터의 내용을 조회할 때 사용하는 명령어 가장 많이 사용되는 SQL명령어로서, 다른 DML 명령어와 같이 사용되어 SQL 활용을 풍부하게 함 기본 형식 1SELECT [OPTION] columns FROM table [WHERE 절]; - OPTION - ALL - DISTINCT - columns - 칼럼명 목록 - 와일드 카드 데이터 수정 UPDATE 레코드 단위로 데이터의 내용을 수정할 때 사용하는 명령어 WHERE 절을 통해 어떤 조건이 만족할 경우에만 특정 칼럼의 값을 수정하는 용도로 많이 사용 기본 형식 1UPDATE tabel SET column1=value1, column2=value2 ... [WHERE절]; 데이터 삭제 DELETE 레코드 단위로 데이터틔 내용을 삭제할 때 사용하는 명령어 WHERE 절을 통해 어떤 조건이 만족하는 레코드만 삭제 가능 조건절 없이 DELETE하는 경우 테이블 전체가 한 번에 삭제 기본 형식 1DELETE FROM table[WHERE 절];","link":"/2020/05/18/Engineer_Information_Processing/ch10_SQL%EC%9D%91%EC%9A%A9/%EC%9D%91%EC%9A%A9SQL/DML/"},{"title":"절차형SQL - 사용자 정의함수","text":"절차형SQL 반복적으로 사용하는 특정 기능을 수행하기 위해 여러개의 SQL 명령문을 포함하는 프로시저를 작성하고 프로시저 호출문을 작성 일련의 연산 처리 결과가 단일값으로 반환되는 사용자 정의함수를 작성하고 호출하는 쿼리를 작성 하나의 이벤트가 발생하면 관련성이 있는 몇 개의 테이블 간에 연속적으로 데이터 삽입, 삭제, 수정을 할 수 있는 트리거를 작성 사용자 정의함수 개념 절차형 SQL을 활용하여 일련의 연산 처리 결과를 단일값으로 변환 DBMS에서 제공되는 공통적 함수 이외에 사용자가 직접 정의하고 작성 호출을 통해 실행되며, 단일값을 조회 또는 삽입, 수정 작업에 이용 사용자 정의함수의 구성 사용자 정의함수 작성 예 사용자 정의함수 호출 쿼리 작성","link":"/2020/05/18/Engineer_Information_Processing/ch10_SQL%EC%9D%91%EC%9A%A9/%EC%A0%88%EC%B0%A8%ED%98%95SQL/%EC%82%AC%EC%9A%A9%EC%9E%90%EC%A0%95%EC%9D%98%ED%95%A8%EC%88%98/"},{"title":"절차형SQL - 이벤트","text":"절차형SQL 이벤트의 개념 특정 시간에 특정한 쿼리, 프로시저, 함수 등을 실행시키는 기능 이벤트 생성 사례 MySql의 경우 이벤트를 생성시, mysql.evnet, information_schema, events 테이블에 자동으로 등록","link":"/2020/05/18/Engineer_Information_Processing/ch10_SQL%EC%9D%91%EC%9A%A9/%EC%A0%88%EC%B0%A8%ED%98%95SQL/%EC%9D%B4%EB%B2%A4%ED%8A%B8/"},{"title":"인터페이스설계확인 - 핵심정리","text":"인터페이스설계확인 1. 인터페이스 기능 확인 인터페이스 기능 확인 방법 인터페이스 목록과 인터페이스 명세서를 포함한 인터페이스 설계서를 통한 인터페이스 기능 확인 시스템의 정적/동적 모형을 통한 인터페이스 기능 확인 인터페이스 되는 데이터명세 정의를 통한 인터페이스 기능 확인 내부, 외부 모듈 연계 방법 EAI ESB 2. 데이터 표준 확인 인터페이스를 위해 인터페이스가 되어야 할 범위의 데이터들의 형식과 표준을 정의 한 것","link":"/2020/05/20/Engineer_Information_Processing/ch09_%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4%EA%B5%AC%ED%98%84/%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4%EC%84%A4%EA%B3%84%ED%99%95%EC%9D%B8/%ED%95%B5%EC%8B%AC%EC%A0%95%EB%A6%AC/"},{"title":"논리데이터베이스 - 관계데이터베이스 모델","text":"논리데이터베이스 관계 데이터 모델의 기본 용어를 익히고 릴레이션을 구성하는 요소와 특성을 이해 관계 데이터 언어의 종류인 관계 대수의 일반 집합 연산자와 순수 관계 연산자의 차이를 이해하고 관계해석의 개념을 정리 시스템 카탈로그와 뷰에 대한 개념 및 특징 이해 용어사전 관계 데이터 모델 실 세계 데이터를 행과 열과 구성된 표 형태로 저장하고 한 테이블의 필드 값을 이용하여 다른 테이블에 관련된 데이터를 찾는 식으로 검색하는 데이터 모델 시스템 카탈로그 데이터베이스의 객체와 구조들에 관한 모든 데이터를 포함하는 시스템 데이터베이스 관계 데이터 모델 개념 DBMS에서 지원하는 데이터 모델 실 세계 데이터를 행과 열과 구성된 표 형태로 저장하고 한 테이블의 필드 값을 이용하여 다른 테이블에 관련된 데이터를 찾는 식으로 검색하는 데이터 모델 관계 데이터 모델의 기본 용어 Relation 릴레이션 하나의 개체에 관한 데이터를 2차원 테이블 구조로 저장한 것 파일 관리 시스템 관점에서 파일에 대응 Attribute 속성 릴레이션의 열 파일 관리 시스템 관점에서 필드에 대응 Tuple 튜플 릴레이션의 행 파일 관리 시스템 관점에서 레코드에 대응 Domain 도메인 하나의 속성이 가질 수 있는 모든 값의 집합 속성 값을 입력 및 수정 할 때 적합성 판단의 기준이 됨 일반적으로 속성의 특성을 고려한 데이터 타입으로 정의 Null 널 속성 값을 아직 모르거나 해당되는 값이 없음을 표현 Degree 차수 하나의 릴레이션에서 속성의 전체 개수 Cardinality 카디널리티 하나의 릴레이션에서 튜플의 전체 개수 릴레이션의 구성 Relation schema 릴레이션 스키마 릴레이션의 논리적 구조 릴레이션의 이름과 릴레이션에 포함된 모든 속성 이름으로 저으이 정적인 특성 Relation instance 릴레이션 인스턴스 어느 한 시점에 릴레이션에 존재하는 튜플들의 집합 동적인 특징 릴레이션 구성 릴레이션 특성 튜플의 유일성 하나의 릴레이션에는 동일한 튜플이 존재할 수 없음 튜플의 무순서 하나의 릴레이션에서 튜플 사이의 순서는 무의미함 속성의 무순서 하나의 릴레이션에서 속성 사이의 순서는 무의미함 속성의 원자성 속성 값으로 원자 값만 사용 가능 Integrity constraint 무결성 제약조건 데이터의 무결성을 보장하고 일관된 상태로 유지하기 위한 규칙 무결성 데이터의 결함이 없는 상태 정확하고 유효하게 유지 무결성 제약 조건 개체 무결성 제약조건 기본키를 구성하는 모든 속성은 널 값을 가질 수 없다 참조 무결성 제약조건 외래키는 참조할 수 없는 값을 가질 수 없다","link":"/2020/05/13/Engineer_Information_Processing/ch12_%EB%85%BC%EB%A6%AC%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EC%84%A4%EA%B3%84/%EA%B4%80%EA%B3%84%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EB%AA%A8%EB%8D%B8/%EA%B4%80%EA%B3%84%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%AA%A8%EB%8D%B8/"},{"title":"절차형SQL - 핵심정리","text":"절차형SQL 1. 사용자 정의함수 절차형 SQL을 활용하여 일련의 연산 처리 결과를 단일값으로 변환 DBMS에서 제공되는 공통적 함수 이외에 사용자가 직접 정의하고 작성 호출을 통해 실행되며, 단일값을 조회 또는 삽입, 수정 작업에 이용 2. 트리거 특정 테이블에 삽입, 수정, 삭제 등의 데이터 변경 이벤트가 발생하면 DBMS에서 자동적으로 실행되도록 구현된 프로그램 이벤트는 전체 트랜잭션 대상과 각 행에 의해 발생되는 경우 모두를 포함할 수 있으며 테이블과 뷰, DB작업을 대상으로 정의 데이터 제어어 사용 불가 3. 이벤트 특정 시간에 특정한 쿼리, 프로시저, 함수 등을 실행시키는 기능","link":"/2020/05/18/Engineer_Information_Processing/ch10_SQL%EC%9D%91%EC%9A%A9/%EC%A0%88%EC%B0%A8%ED%98%95SQL/%ED%95%B5%EC%8B%AC%EC%A0%95%EB%A6%AC/"},{"title":"절차형SQL - 트리거","text":"절차형SQL 트리거의 개념 특정 테이블에 삽입, 수정, 삭제 등의 데이터 변경 이벤트가 발생하면 DBMS에서 자동적으로 실행되도록 구현된 프로그램 이벤트는 전체 트랜잭션 대상과 각 행에 의해 발생되는 경우 모두를 포함할 수 있으며 테이블과 뷰, DB작업을 대상으로 정의 트리거의 목적 특정 테이블에 대한 데이터 변경을 시작점으로 설정하고, 그와 관련된 작업을 자동적으로 수행 일반적으로 이벤트와 관련된 테이블의 데이터 삽입, 추가, 삭제 작업을 DBMS가 자동적으로 실행시키는데 활용 데이터 무결성 유지 및 로그 메시지 출력등의 별도 처릴르 위해 트리거 사용 트리거의 세 가지 구성 요소 트리거가 실행될 조건이 되는 문장이나 이벤트 실행 조건의 제약 실행될 내용 트리거 작성시 주의사항 데이터 제어어 사용불가 트리거 내에 commit, rollback 등 사용 불가 오류에 주의 트리거 실행 중 오류가 발생시 트리거 실행의 원인을 제공한 데이터 작업에도 영향","link":"/2020/05/18/Engineer_Information_Processing/ch10_SQL%EC%9D%91%EC%9A%A9/%EC%A0%88%EC%B0%A8%ED%98%95SQL/%ED%8A%B8%EB%A6%AC%EA%B1%B0/"},{"title":"논리데이터베이스 - 시스템 카탈로그와 뷰","text":"논리데이터베이스 시스템 카탈로그 개념 데이터베이스의 객체(사용자, 릴레이션 뷰, 인덱스, 권한)와 구조들에 관한 모든 데이터를 포함하는 시스템 데이터베이스 카탈로그에 저장된 정보를 메타데이터라고 함 시스템 카탈로그는 사용자 및 질의 최적호 모듈 등 DBMS 자신의 구성요소에 의해서 사용 시스템 카탈로그는 관계DBMS마다 표준화되어 있지 않아서 관계 DBMS마다 서로 다른 형태로 시스템 카탈로그 기능을 제공 데이터 사전 또는 시스템 테이블이라고 함 시스템 카탈로그 특징 사용자가 SQL 문으로 내용 검색이 가능 데이터베이스 관리시스템에 의해 생성 및 유지 기본 테이블, 뷰, 인덱스 등이 변경되면 자동으로 시스템 카탈로그는 갱신 사용자가 SQL문으로 갱신은 불가능 위치 투명성 및 중복 투명성을 제공하기 위해 필요한 모든 제어 정보를 포함 시스템 카탈로그 내용 릴레이션의 정보 릴레이션 이름 저장된 파일 이름과 파일 구조 속성들에 대한 속성 이름과 타입 정의된 각 인덱스의 이름 정의된 무결성 제약 조건 인덱스 관련 정보 인덱스 이름 인덱스의 구조 인덱스의 키에 대한 정보 뷰 관련 정보 뷰의 이름 뷰의 정의 뷰의 소유자 사용자 관련 정보 사용자 계정 정보 사용자 권한 정보 통계 관련 정보 릴레이션 카디널리티 인덱스 카디널리티 인덱스의 높이 인덱스의 범위 View 뷰 개념 가상 테이블을 구성하는 데이터베이스 오브젝트로 별도의 저장 공간은 없지만 뷰를 통해 SELECT, DELETE, UPDATE를 할 수 있음 뷰의 장점과 단점 장점 논리적 독립성 제공 사용자 데이터 관리 용이 데이터 보안 용이 단점 뷰 자체 인덱스 불가 뷰 정의 변경 불가 데이터 변경 제약 존재","link":"/2020/05/13/Engineer_Information_Processing/ch12_%EB%85%BC%EB%A6%AC%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EC%84%A4%EA%B3%84/%EA%B4%80%EA%B3%84%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EB%AA%A8%EB%8D%B8/%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%B9%B4%ED%83%88%EB%A1%9C%EA%B7%B8%EC%99%80%EB%B7%B0/"},{"title":"논리데이터베이스 - 관계데이터언어","text":"논리데이터베이스 Relation data operaton 관계 데이터 연산 관계 데이터 모델의 연산 원하는 데이터를 얻기 위해 릴레이션에 필요한 처리 요구를 수행하는 것 관계대수와 관계 해석이 있음 Relational algebra 관계 대수의 개념 원하는 결과를 얻기 위해 릴레이션의 처리 과정을 순서대로 기술하는 언어 절차 언어 릴레이션을 처리하는 연산자들의 모임 대표 연산자 8개 일반 집합 연산자와 순수 관계 연산자로 분류 폐쇠 특성이 존재 피연산자도 릴레이션이고 연산의 결과도 릴레이션 관계 대수 연산자의 종류 일반 집합 연산자와 순수 관계 연산자 Set operation 일반 집합 연산자 릴레이션이 튜플의 집합이라는 개념을 이용하는 연산자 일반 집합 연산자 특성 피연산자가 2개 필요함 2개의 릴레이션을 대상으로 연산을 수행 합집합, 교집합, 차집합은 피연산자인 두 릴레이션이 합병 가능해야 함 합병가능 조건 두 릴레이션의 차수가 같아야 함 두 릴레이션에서 서로 대응되는 속성의 도메인이 같아야 함 일반 집합 연산자 - 카티션 프로덕트 cartesian product 두 릴레이션 R과 S의 카티션 프로덕트 : R x S 릴레이션 R에 속한 각 튜플과 릴레이션 S에 속한 각 튜플을 모두 연결하여 새로운 튜플로 결과 릴레이션을 구성 결과 릴레이션의 특성 차수는 릴레이션 R과 S의 차수를 더함 카디널리티는 릴레이션 R과 S의 카디널리티를 곱함 교환적 특징 R x S = S x R 결합적 특징 (R x S) x T = R x (S x T) 카디션 프로덕트 연산 Relational operation 순수 관계 연산자 릴레이션 구조와 특성을 이용하는 연산자 Relational calculus 관계 해석 개념 처리를 원하는 데이터가 무엇인지만 기술하는 언어 비절차 언어 분류 튜플 관계 해석 도메인 관계 해석","link":"/2020/05/13/Engineer_Information_Processing/ch12_%EB%85%BC%EB%A6%AC%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EC%84%A4%EA%B3%84/%EA%B4%80%EA%B3%84%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EB%AA%A8%EB%8D%B8/%EA%B4%80%EA%B3%84%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%96%B8%EC%96%B4/"},{"title":"논리데이터베이스 - 개체-관계(E-R)모델","text":"논리데이터베이스 개체-관계(Entity-Relationship) 모델 정의 개념적 데이터 모델의 가장 대표적 데이터를 개체, 관계, 속성으로 묘사 E-R 다이어그램으로 표현하며, 1:1, 1:N, N:M 등의 관계 유형을 제한 없이 나타낼 수 있음 E-R 다이어그램 개념 E-R 모델의 기본 아이디어를 이해하기 쉽게 기호를 사용하여 시각적으로 표현한 그림 실체 간의 관계는 물론 조직, 사용자, 프로그램, 데이터 등 시스템 내에서 역할을 가진 모든 실체를 표현 데이터에 대해 개발자, 관리자, 사용자들이 서로 다르게 인식하고 있는 뷰들을 하나로 단일화 시킴 표기법 피터첸 표기법 정보공학 표기법 바커 표기법 E-R 다이어그램 기호 E-R 다이어그램 표기법 비교 관계의 표현 및 이해","link":"/2020/05/14/Engineer_Information_Processing/ch12_%EB%85%BC%EB%A6%AC%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EC%84%A4%EA%B3%84/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%AA%A8%EB%8D%B8%EB%A7%81%EB%B0%8F%EC%84%A4%EA%B3%84/%EA%B0%9C%EC%B2%B4%EA%B4%80%EA%B3%84%EB%AA%A8%EB%8D%B8/"},{"title":"논리데이터베이스 - 핵심정리","text":"논리데이터베이스 1. 관계 데이터 모델 실 세계 데이터를 행과 열과 구성된 표 형태로 저장하고 한 테이블의 필드 값을 이용하여 다른 테이블에 관련된 데이터를 찾는 식으로 검색하는 데이터 모델 용어 릴레이션 속성 튜플 도메인 차수 카디널리티 릴레이션 특성과 무결성 제약조건 2. 관계 데이터언어 관계 데이터 모델의 연산 원하는 데이터를 얻기 위해 릴레이션에 필요한 처리 요구를 수행하는 것 종류 일반 집합 연산자 순수 관계 연산자 관계해석의 개념 3. 시스템 카탈로그와 뷰 데이터베이스의 객체(사용자, 릴레이션 뷰, 인덱스, 권한)와 구조들에 관한 모든 데이터를 포함하는 시스템 데이터베이스 뷰는 가상 테이블을 구성하는 데이터베이스 오브젝트로 별도의 저장 공간은 없지만 뷰를 통해 SELECT, DELETE, UPDATE를 할 수 있음","link":"/2020/05/13/Engineer_Information_Processing/ch12_%EB%85%BC%EB%A6%AC%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EC%84%A4%EA%B3%84/%EA%B4%80%EA%B3%84%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EB%AA%A8%EB%8D%B8/%ED%95%B5%EC%8B%AC%EC%A0%95%EB%A6%AC/"},{"title":"논리데이터베이스 - 논리 데이터모델 품질검증","text":"논리데이터베이스 좋은 데이터 모델의 조건 Completeness 완전성 업무에 필요로 하는 모든 데이터가 데이터 모델에 정의되어 있어야함 Non-Redundancy 중복배제 하나의 데이터베이스 내에 동일한 사실은 반드시 한 번만 기록하여야 함 Business Rules 비즈니스 룰 수많은 업무 규칙을 데이터 모델에 표현하고 이를 해당 데이터 모델을 활용하는 모든 사용자가 그 규칙을 공유할 수 있게 제공 Data Reusability 데이터 재사용 데이터의 통합성과 독립성에 대하여 충분히 고려 Stability and Flexibility 안정성 및 활용성 확장성을 담보하기 위해서는 데이터 관점의 통합 불가피 Elegance 간결성 합리적으로 잘 정리된 데이터를 통합하여 데이터의 집합을 정의하고, 이를 데이터 모데로 잘 표현하여 활용 Communication 의사소통 데이터 분석 과정에서 도출되는 많은 업무 규칙은 데이터 모델에 개체, 서브타입, 속성, 관계등의 형태로 최대한 자세하게 표현되어야 함 Integration 통합성 동일한 성격의 데이터를 한 번만 정의하기 위해 공유 데이터에 대한 구조를 여러 업무 영역에서 공동으로 사용하기 용이하게 해야 함 데이터 모델 품질 검증 기준","link":"/2020/05/14/Engineer_Information_Processing/ch12_%EB%85%BC%EB%A6%AC%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EC%84%A4%EA%B3%84/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%AA%A8%EB%8D%B8%EB%A7%81%EB%B0%8F%EC%84%A4%EA%B3%84/%EB%85%BC%EB%A6%AC%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%AA%A8%EB%8D%B8%ED%92%88%EC%A7%88%EA%B2%80%EC%A6%9D/"},{"title":"논리데이터베이스 - 데이터모델개념","text":"논리데이터베이스 E-R 표기법에 따라 주제 영역별로 개체와 식별자를 포함한 속성을 도식화 및 개체 간 관계의 기수성, 선택성, 식별/비식별 관계를 도식화 개체 내 속성 원자성과 함수 종속성을 분석하여 데이터베이스 정규화 대상 개체를 도출하고 데이터베이스 정규화를 수행 논리 데이터 모델에 대하여 정확성, 완전성, 준거성, 최신성, 일관성, 활용성의 품질기준을 적용하고 개체, 속성, 관계에 대하여 체크리스트를 작성한 후 검증 결과에 따라 논리 데이터 모델 품질 검증 결과서를 작성 용어사전 데이터 모델 현실 세계의 정보들을 컴퓨터에 표현하기 위해 단순화, 추상화하여 체계적으로 표현한 개념적 모형 이상 현상 불필요한 데이터 중복으로 인해 릴레이션에 대한 데이터 삽입/수정/삭제 연산을 수행할 때 발생할 수 있는 부작용 데이터베이스 개발절차 요구분석 비지니스 요구사항 전략수립 개념적데이터 모델링 분석 논리적데이터 모델링 설계 물리적데이터 모델링 개발 데이터베이스 구축 운영시스템 안에 데이터베이스 존재 데이터 모델의 정의 현실 세계의 정보들을 컴퓨터에 표현하기 위해서 단순화, 추상화하여 체계적으로 표현한 개념적 모형 종류 개념적 데이터 모델 논리적 데이터 모델 물리적 데이터 모델 구성 요소 개체 속성 관계 표시 요소 구조 연산 제약 조건 데이터 모델링 절차 개념적 데이터 모델링 중요 개념을 구분 핵심 개체 도출 ERD 작성 논리적 데이터 모델링 각 개념을 구체화 ERD-RDB 모델 사상 상세 속성 정의 정규화 물리적 데이터 모델링 개체, 인덱스 등 생성 DB 개체 정의 테이블 및 인덱스 등 설계 데이터 모델의 종류 1. 개념적 데이터 모델 현실 세계에 대한 인식을 추상적 개념으로 표현하는 과정 속성들로 기술된 개체 타입과 이 개체 타입들 간의 관계를 이용하여 현실 세계를 표현 현실 세계에 존재하는 개체를 인간이 이해할 수 있는 정보 구조로 표현하기 때문에 정보 모델이라고 함 대표적인 개념적 데이터 모델에는 E-R 모델이 있음 2. 논리적 데이터 모델 개념적 모델링 과정에서 얻은 개념적 구조를 컴퓨터가 이해하고 처리할 수 있는 컴퓨터 세계의 환경에 맞도록 변환하는 과정 필드로 기술된 데이터 타입과 이 데이터 타입들 간의 관계를 이용한 현실 세계를 표현 단순히 데이터 모델이라고 하면 논리적 데이터 모델을 의미 특정 DBMS는 특정 논리적 데이터 모델 하나만 선정하여 사용 데이터 간의 관계를 어떻게 표현하느냐에 따라 관계 모델, 계층 모델, 네트워크 모델로 구분 3. 물리적 데이터 모델 논리적 데이터 모델에서 레코드의 상세 스펙 등을 기술한 모델로 실제 컴퓨터에 데이터가 저장되는 방법을 정의 DB 개체 정의 테이블 및 인덱스 등 설계 데이터 모델의 구성 요소 1. Entity 개체 데이터베이스에 표현하려는 것으로 사람이 생각하는 개념이나 정보 단위 같은 현실 세계의 대상체 실세계에 독립적으로 존재하는 유형, 무형의 정보로서 서로 연관된 몇 개의 속성으로 구성 파일 시스템의 레코드에 대응 하는 것으로 어떤 정보를 제공하는 역할을 수행 독립적으로 존재하거나 그 자체로서도 구별 가능 유일한 식별자에 의해 식별되고 다른 개체와 하나 이상의 관계가 있음 2. Attribute 속성 데이터베이스를 구성하는 가장 작은 논리적 단위 파일 구조상의 데이터 항목 또는 데이터 필드에 해당 속성은 개체를 구성하는 항목 속성의 수는 Degree 3. Relationship 관계 개체와 개체 사이의 논리적 연결을 의미 개체 간의 관계와 속성 간의 관계가 있음 형태 일대일(1:1) 일대다(1:N) 다대다(N:M) 데이터 모델에 표시할 요소 Structure 구조 논리적으로 표현된 개체 타입들 간의 관계로서 데이터 구조 및 정적 성질을 표현 Operation 연산 데이터베이스에 저장된 실제 데이터를 처리하는 작업에 대한 명세로서 데이터베이스를 조작하는 기본도구 Constraint 제약조건 데이터베이스에 저장될 수 있는 실제 데이터베이스의 논리적인 제약 조건","link":"/2020/05/13/Engineer_Information_Processing/ch12_%EB%85%BC%EB%A6%AC%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EC%84%A4%EA%B3%84/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%AA%A8%EB%8D%B8%EB%A7%81%EB%B0%8F%EC%84%A4%EA%B3%84/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%AA%A8%EB%8D%B8%EA%B0%9C%EB%85%90/"},{"title":"논리데이터베이스 - 논리적 데이터 모델링","text":"논리데이터베이스 논리적 데이터 모델링 정의 E-R 다이어그램으로 표현된 개념적 구조를 데이터베이스에 저장할 형태로 표현한 논리적 구조로 정의하는 과정 정확한 업무 분석을 통한 자료의 흐름을 분석하여 현재 사용 중인 양식, 문서, 장표를 중심으로 자료항목을 추출하여 엔티티와 속성들의 관계를 구조적으로 정의하는 단계 논리적 데이터 모델링 특성 요구사항을 충분히 수집하지 않으면 다음 단계의 요구사항 변경에 따른 많은 비용이 발생 모든 이해당사자들과 의사소통의 보조자료로서 E-R 모델을 활용 논리적 모델은 H/W나 S/W에 독립적 DBMS에 맞는 논리적 스키마 설계 트랜잭션 인터페이스를 설계 사용자의 요구에 대한 트랜잭션을 모델링하는 것은 개념적 설계단계 관계형 데이터베이스에서는 테이블을 설계하는 단계 종류 관계 데이터 모델 계층 데이터 모델 네트워크 데이터 모델","link":"/2020/05/14/Engineer_Information_Processing/ch12_%EB%85%BC%EB%A6%AC%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EC%84%A4%EA%B3%84/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%AA%A8%EB%8D%B8%EB%A7%81%EB%B0%8F%EC%84%A4%EA%B3%84/%EB%85%BC%EB%A6%AC%EC%A0%81%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%AA%A8%EB%8D%B8%EB%A7%81/"},{"title":"논리데이터베이스 - 핵심정리","text":"논리데이터베이스 1. 데이터 모델 개념 현실 세계의 정보들을 컴퓨터에 표현하기 위해서 단순화, 추상화하여 체계적으로 표현한 개념적 모형 종류 개념적 데이터 모델 논리적 데이터 모델 물리적 데이터 모델 구성 요소 개체 속성 관계 표시 요소 구조 연산 제약 조건 2. 개체-관계(E-R)모델 데이터를 개체, 관계, 속성으로 묘사 E-R 다이어그램으로 표현하며, 1:1, 1:N, N:M 등의 관계 유형을 제한 없이 나타낼 수 있음 3. 논리적 데이터모델링 E-R 다이어그램으로 표현된 개념적 구조를 데이터베이스에 저장할 형태로 표현한 논리적 구조로 정의하는 과정 논리적 모델은 H/W나 S/W에 독립적 종류 관계 데이터 모델 계층 데이터 모델 네트워크 데이터 모델 4. 데이터베이스 정규화 중복성을 최소화하고 정보의 일관성을 보장하기 위한 개념 릴레이션을 관련 있는 속성들로만 구성되도록 릴레이션을 분해하는 과정 5. 논리 데이터모델 품질검증 좋은 데이터 모델의 조건 완전성 중복배제 비즈니스 룰 데이터 재사용 안정성 및 활용성 간결성 의사소통 통합성 데이터 모델 품질 검증 기준 정확성 완전성 준거성 최신성 일관성 활용성","link":"/2020/05/14/Engineer_Information_Processing/ch12_%EB%85%BC%EB%A6%AC%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EC%84%A4%EA%B3%84/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%AA%A8%EB%8D%B8%EB%A7%81%EB%B0%8F%EC%84%A4%EA%B3%84/%ED%95%B5%EC%8B%AC%EC%A0%95%EB%A6%AC/"},{"title":"물리데이터베이스 - 데이터베이스백업","text":"물리데이터베이스 데이터베이스 백업 개념 데이터베이스 백업은 전산 장비의 장애에 대비 하여 데이터베이스에 저장된 데이터를 보호하고 복구하기 위한 작업 치명적인 데이터 손실을 막기 위해서는 데이터베이스를 정기적으로 백업 데이터베이스 관리 시스템은 데이터베이스 파괴 및 실행 중단이 발생하면 이를 복구할 수 있는 기능을 제공함 데이터베이스 장애 유형 사용자 실수 사용자 실수로 인해 테이블이 삭제되거나 잘못된 트랜잭션이 처리된 경우 미디어 장애 CPU, 메모리, 디스크 등 하드웨어 장애나 데이터가 파손 구문 장애 프로그램 오류나 사용 공간의 부족으로 인해 발생하는 장애 사용자 프로세스 장애 프로그램이 비정상적으로 종료되거나 네트워크 이상으로 세션이 종료되어 발생하는 오류 인스턴스 장애 하드웨어 장애, 정전, 시스템 파일 파손 등 비정상적인 요인으로 인해 메모리나 데이터베이스 서버의 프로세스가 중단 로그 파일 로그 파일은 데이터베이스의 처리 내용이나 이용 상황 등 상태 변화를 시간의 흐름에 따라 모두 기록한 파일 데이터베이스 복구를 위해 필요한 가장 기본적인 자료 로그 파일을 기반으로 데이터베이스를 과거 상태로 복귀(UNDO)시키거나 현재 상태로 재생(REDO)시켜 데이터베이스 상태를 일관성 있게 유지 로그 파일은 트랜잭션 시작 시점, Rollback 시점, 데이터 입력, 수정, 삭제 시점 등에서 기록 로그 파일 내용 트랜잭션이 작업한 모든 내용, 트랜잭션 식별, 트랜잭션 레코드, 데이터 식별자, 갱신 이전 값(Before Image), 갱신 이후 값(After Image) 등 데이터베이스 복구 알고리즘 1. NO-UNDO/REDO 데이터베이스 버퍼의 내용을 비동기적으로 갱신한 경우의 복구 알고리즘 NO-UNDO : 트랜잭션 완료 전에는 변경 내용이 데이터베이스에 기록되지 않으므로 취소할 필요가 없음 REDO : 트랜잭션 완료 후 데이터베이스 버퍼에는 기록되어 있고, 저장매체에는 기록되지 않으므로 트랜잭션을 다시 실행 2. UNDO/NO-REDO 데이터베이스 버퍼의 내용을 동기적으로 갱신한 경우의 복구 알고리즘 UNDO : 트랜잭션 완료 전에 시스템이 파손되었다면 변경된 내용 취소 NO-REDO : 트랜잭션 완료 전에 데이터베이스 버퍼 내용을 이미 저장매체에 기록했으므로 트랜잭션 내용을 다시 실행하지 않음 3. UNDO/REDO 데이터베이스 버퍼의 내용을 동기/비동기적으로 갱신한 경우의 복구 알고리즘 데이터베이스 기록 전에 트랜잭션이 완료될 수 있으므로 완료된 트랜잭션이 데이터베이스에 기록되지 못했다면 다시 실행 4. NO-UNDO/NO-REDO 데이터베이스 버퍼의 내용을 동기적으로 저장 매체에 기록하지만 데이터베이스와는 다른 영역에 기록한 경우의 복구 알고리즘 NO-UNDO : 변경 내용은 데이터베이스와 다른 영역에 기록되어 있으므로 취소할 필요가 없음 NO-REDO : 다른 영역에 이미 기록되어 있으므로 트랜잭션을 다시 실행할 필요 없음 백업종류 1. 물리 백업 데이터베이스 파일을 백업하는 방법 백업 속도가 빠르고 작업이 단순하지만 문제 발생시 원인 파악 및 문제 해결이 어려움 완전 복구 가능 2. 논리 백업 DB 내의 논리적 객체들을 백업하는 방법 복원 시 데이터 손상을 막고 문제 발생 시 원인 파악 및 해결이 수월하지만 백업/복원 시 시간이 많이 소요됨 구분 설명 복구수준 물리백업 로그 파일 백업 실시 완전 복구 물리백업 로그 파일 백업 없음 백업 시점까지 복구 논리 백업 DBMS 유틸리티 백업 시점까지 복구","link":"/2020/05/15/Engineer_Information_Processing/ch13_%EB%AC%BC%EB%A6%AC%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EC%84%A4%EA%B3%84/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EB%AC%BC%EB%A6%AC%EC%86%8D%EC%84%B1%EC%84%A4%EA%B3%84/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EB%B0%B1%EC%97%85/"},{"title":"물리데이터베이스 - 데이터베이스 용량 설계","text":"물리데이터베이스 데이터베이스 용량 설계 개념 데이터베이스 용량 설계는 데이터가 저장될 공간을 정의 데이터베이스 용량을 설계할 때는 테이블에 저장할 데이터양과 인덱스, 클러스터 등이 차지하는 공간 등을 예측하여 반영함 설계과정에서 수행 Tablespace 테이블 스페이스 테이블이 저장되는 논리적인 영역으로, 하나의 테이블스페이스에 하나 또는 그 이상의 테이블 저장 가능 테이블을 저장하면 논리적으로는 테이블스페이스에 저장되고, 물리적으로는 해당 테이블스페이스와 연관된 데이터 파일에 저장 데이터베이스를 테이블, 테이블스페이스, 데이터 파일로 나눠 관리하면 논리적 구성이 물리적 구성에 종속되지 않아 투명성이 보장됨 테이블스페이스는 데이터베이스에 저장되는 내용에 따라 테이블, 인덱스, 임시(Temporary) 등의 용도로 구분하여 설계 테이블스페이스 설계 시 고려사항 테이블스페이스는 업무별로 구분하여 지정 대용량 테이블은 하나의 테이블스페이스에 독립적으로 저장 테이블과 인덱스는 분리하여 저장 LOB(Large Object)타입의 데이터는 독립적인 공간으로 지정 데이터베이스 용량 설계 목적 데이터베이스의 용량을 정확히 산정하여 디스크의 저장 공간을 효과적으로 사용하고 확장성 및 가용성을 높임 디스크의 특성을 고려하여 설계함으로써 디스크의 입/출력 부하를 분산시키고 채널의 병목 현상을 최소화 디스크에 대한 입/출력 경합이 최소화되도록 설계함으로써 데이터 접근성 향상 테이블과 인덱스의 테이블스페이스를 분리 구성 테이블스페이스와 임시 테이블스페이스를 분리 구성 테이블을 마스터 테이블과 트랜잭션 테이블로 분류 데이터베이스의 기본 용량이 모두 찼을 경우 추가적으로 공간이 할당되는 익스텐트(Extent) 발생을 최소화하여 성능 향상 데이터베이스 용량을 정확히 분석하여 테이블과 인덱스에 적합한 저장 옵션 지정 데이터베이스 용량 분석 절차 데이터 예상 건수, Row 길이, 보존 기간, 증가율 등 기초 자료를 수집하여 용량을 분석 분석된 자료를 바탕으로 DBMS에 이용될 테이블, 인덱스 등 오브젝트별 용량을 산정 테이블과 인덱스의 테이블스페이스 용량을 산정 데이터베이스에 저장될 모든 데이터 용량과 데이터베이스 설치 및 관리를 위한 시스템 용량을 합해 디스크 용량을 산정","link":"/2020/05/15/Engineer_Information_Processing/ch13_%EB%AC%BC%EB%A6%AC%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EC%84%A4%EA%B3%84/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EB%AC%BC%EB%A6%AC%EC%86%8D%EC%84%B1%EC%84%A4%EA%B3%84/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EC%9A%A9%EB%9F%89%EC%84%A4%EA%B3%84/"},{"title":"물리데이터베이스 - 데이터지역화","text":"물리데이터베이스 데이터 지역화 Data Locality 개념 데이터베이스의 저장 데이터를 효율적으로 이용할 수 있도록 저장하는 방법 물리적 데이터베이스 셀계에서 데이터 지역화를 고려한 보조 저장장치의 설계가 중요함 물리적 데이터베이스 설계, 보조 기억 장치의 역할, 디스크 상의 파일의 배치를 지역화 관점에서 검토 물리적 데이터베이스 설계 논리적 설계의 데이터 구조를 보조 기억 장치상의 파일(물리적 데이터 모델)로 매핑 하나의 파일에 여러 릴레이션이 저장될 수 있음 예상 빈도를 포함하여 데이터베이스 질의와 트랜잭션을 분석 데이터에 대한 효율적인 접근을 제공하기 위하여 저장 구조와 접근 방법들을 고려함 질의를 효율적으로 지원하기 위해 인덱스 구조를 적절히 사용함 보조 기억 장치의 역할 각 파일은 고정된 크기의 블록들로 나누어져 저장됨 여러 개의 블록들에 파일의 데이터가 분산되어 저장됨 디스크는 데이터베이스를 장기간 보관하는 주된 보조 기억장치 디스크상에서 파일의 레코드 배치 릴레이션의 속성은 고정 길이 또는 가변 길이의 필드로 표현됨 연관된 필드들이 모여서 고정 길이 또는 가변 길이의 레코드가 됨 한 릴레이션을 구성하는 레코드들의 모임은 파일이라고 부르는 블록들의 모임에 저장 한 파일에 속하는 블록들의 위치가 반드시 인접해 있을 필요는 없음 인접한 블록들을 읽는 경우 탐구 시간과 회전 지연 시간이 들지 않기 때문에 입출력 속도가 빠르므로 블록들이 인접하도록 파일의 블록들을 재조직함","link":"/2020/05/15/Engineer_Information_Processing/ch13_%EB%AC%BC%EB%A6%AC%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EC%84%A4%EA%B3%84/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EB%AC%BC%EB%A6%AC%EC%86%8D%EC%84%B1%EC%84%A4%EA%B3%84/%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%A7%80%EC%97%AD%ED%99%94/"},{"title":"논리데이터베이스 - 데이터베이스 정규화","text":"논리데이터베이스 Anomaly 이상 현상 불필요한 데이터 중복으로 인해 릴레이션에 대한 데이터 삽입/수정/삭제 연산을 수헹할 때 발생할 수 있는 부작용 Normalization 정규화를 통해 이상현상을 제거 종류 삽입 이상 새 데이터를 삽입시 불필요한 데이터도 함께 삽입되는 문제 갱신 이상 중복 데이터 중 일부만 변경하여 데이터가 불일치하게 되는 모순의 문제 삭제 이상 데이터를 삭제시 꼭 필요한 데이터까지 함께 삭제되는 데이터 손실의 문제 Normalization 정규화란? 중복성을 최소화하고 정보의 일관성을 보장하기 위한 개념 릴레이션을 관련 있는 속성들로만 구성되도록 릴레이션을 분해하는 과정 데이터 구조의 안정성을 최대로 함 중복을 배제하여 삽입, 삭제, 갱신 이상의 발생을 방지함 데이터 삽입 시 릴레이션을 재구성할 필요성을 줄임 논리적 설계 단계에서 수행 과정(아래 과정을 해야지 정규형이 됨) 비정규형 1NF 중복속성 제거 제1정규화 반복되는 속성이나 Group 속성 제거 2NF 부분종속성 제거 제2정규화 주 식별자에게 완전히 종속되지 않은 속성 제거 3NF 이행종속성 제거 제3정규화 비 식별자에 종속되는 속성 제거 BCNF(보이스코드정규형) 후보키가 아닌 결정자 제거 4NF 다치종속성 제거 제4정규화 다시종속성 제거 5NF 조인종속성 제거 제5정규화 조인 종속성 제거 정규화 목적 데이터 중복 배제로 데이터 관리 편의성 제고 및 자료 저장 공간의 최소화 데이터 모형 단순화 데이터 구조의 안정성 및 무결성 유지 속성의 배열상태 검증 엔티티와 속성의 누락 여부 검증 수단 자료검색과 추출의 효율성 추구 정규화 특징 어떠한 관계구조가 바람직한 것인지, 바람직하지 못한 관계를 어떻게 분해하여야 하는지에 관한 구체적인 판단 기준을 제공 정규화된 데이터 모델은 정확성, 일치성, 단순성, 비중복성, 안전성 보장","link":"/2020/05/14/Engineer_Information_Processing/ch12_%EB%85%BC%EB%A6%AC%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EC%84%A4%EA%B3%84/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%AA%A8%EB%8D%B8%EB%A7%81%EB%B0%8F%EC%84%A4%EA%B3%84/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EC%A0%95%EA%B7%9C%ED%99%94/"},{"title":"물리데이터베이스 - 클러스터링","text":"물리데이터베이스 Cluster 클러스터의 개념 데이터 저장시 데이터 액세스 효율을 향상시키기 위해 동일한 성격의 데이터를 동일한 데이터 블록에 저장하는 물리적 저장 방법 클러스터링키로 지정된 컬럼 값의 순서대로 저장되고, 여러 개의 테이블이 하나의 클러스터에 저장됨 클러스터의 특징 클러스터링 된 테이블은 데이터 조회 속도는 향상시키지만 데이터 입력, 수정, 삭제에 대한 성능은 저하됨 클러스터는 데이터의 분포도가 넓을수록 유리함 데이터 분포도가 넓은 테이블을 클러스터링 하면 저장 공간을 절약할 수 있음 대용량을 처리하는 트랜잭션은 전체 테이블을 스캔하는 일이 자주 발생하므로 클러스터링을 하지 않는 것이 좋음 처리 범위가 넓은 경우에는 단일 테이블 클러스터링을, 조인이 많이 발생하는 경우는 다중 테이블 클러스터링을 사용 파티셔닝된 테이블에는 클러스터링 불가 클러스터링된 테이블에 클러스터드 인덱스를 생성하면 접근 성능 향상 클러스터 대상 테이블 분포도가 넓은 테이블 대량의 범위를 자주 조회하는 테이블 입력, 수정, 삭제가 자주 발생하지 않는 테이블 자주 조인되어 사용되는 테이블 ORDER BY, GROUP BY, UNION이 빈번한 테이블","link":"/2020/05/15/Engineer_Information_Processing/ch13_%EB%AC%BC%EB%A6%AC%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EC%84%A4%EA%B3%84/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EB%AC%BC%EB%A6%AC%EC%86%8D%EC%84%B1%EC%84%A4%EA%B3%84/%ED%81%B4%EB%9F%AC%EC%8A%A4%ED%84%B0%EB%A7%81/"},{"title":"물리데이터베이스 - 파티셔닝","text":"물리데이터베이스 식별된 오브젝트의 데이터 타입, 사이즈, 증가 용량을 고려하여 저장 공간을 산출하고, 해당 오브젝트에 대한 테이블 스페이스를 할당 할당된 테이블 스페이스 용량을 기반으로 디스크 저장 용량을 산정하고, 데이터베이스 백업 주기, 방식에 따른 별도 저장 공간 용량을 산정 분산위치, 엔티티명, 테이블명, 테이블 스페이스명, 테이블 스페이스 용량, 데이터 파일명, 파티셔닝, 클러스터링 정보, 보안정보에 대한 물리 데이터베이스 설계서를 작성 Partition 파티션 개념 데이터베이스에서 파티션은 대용량의 테이블이나 인덱스를 작은 논리적 단위인 파티션으로 나누는 것 대용량 데이터베이스의 경우 중요한 몇 개의 테이블에만 집중되어 데이터가 증가되므로 이런 테이블을 작은 단위로 나눠 분산시키면 성능 저하를 방지와 데이터 관리가 쉬워짐 테이블이나 인덱스를 파티셔닝하면 파티션키 또는 인덱스키에 따라 물리적으로 별도의 공간에 데이터가 저장됨 데이터 처리는 테이블 단위로 이뤄지고 데이터 저장은 파티션별로 수행 파티션 장/단점 장점 데이터 접근 시 액세스 범위를 줄여 쿼리 성능이 향상됨 파티션별로 데이터가 분산되어 저장되므로 디스크의 성능이 향상됨 파티션별로 백업 및 복구를 수행하므로 속도가 빠름 시스템 장애 시 데이터 손상 정도를 최소화 데이터 가용성이 향상됨 파티션 단위로 입/출력을 분산시킬 수 있음 단점 하나의 테이블을 세분화하여 관리하므로 세심한 관리가 요구됨 테이블간 조인에 대한 비용이 증가함 용량이 작은 테이블에 파티셔닝을 수행하면 오히려 성능이 저하됨 파티션의 종류 1. Range Partitioning 범위 분할 지정한 열의 값을 기준을 분할 일별, 월별, 분기별 2. Hash Partitioning 해시 분할 해시 함수를 적용한 결과 값에 따라 데이터를 분할 특정 파티션에 데이터가 집중되는 범위 분할의 단점을 보완한 것으로 데이터를 고르게 분산할 때 유용함 특정 데이터가 어디에 있는지 판단할 수 없음 고객번호, 주민번호 등과 같이 데이터가 고른 컬럼에 효과적임 3. Composite Partitoning 조합 분할 범위 분할로 분할한 다음 해시 함수를 적용하여 다시 분할하는 방식 범위 분할한 파티션이 너무 커서 관리가 어려울 때 유용함 파티션키 선정시 고려사항 파티션키는 테이블 접근 유형에 따라 파티셔닝이 이뤄지도록 선정 데이터 관리의 용이성을 위해 이력성 데이터는 파티션 생성주기와 소멸주기를 일치 매일 생성되는 날짜 컬럼, 백업의 기준이 되는 날짜 컬럼, 파티션 간 이동이 없는 컬럼, I/O 병목을 줄일 수 있는 데이터 분포가 양호한 컬럼 등을 파티션키로 선정","link":"/2020/05/15/Engineer_Information_Processing/ch13_%EB%AC%BC%EB%A6%AC%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EC%84%A4%EA%B3%84/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EB%AC%BC%EB%A6%AC%EC%86%8D%EC%84%B1%EC%84%A4%EA%B3%84/%ED%8C%8C%ED%8B%B0%EC%85%94%EB%8B%9D/"},{"title":"물리데이터베이스 - 핵심정리","text":"물리데이터베이스 1. 파티셔닝 데이터베이스에서 파티션은 대용량의 테이블이나 인덱스를 작은 논리적 단위인 파티션으로 나누는 것 장점 데이터 접근 시 액세스 범위를 줄여 쿼리 성능이 향상됨 파티션별로 데이터가 분산되어 저장되므로 디스크의 성능이 향상됨 파티션별로 백업 및 복구를 수행하므로 속도가 빠름 시스템 장애 시 데이터 손상 정도를 최소화 데이터 가용성이 향상됨 파티션 단위로 입/출력을 분산시킬 수 있음 단점 하나의 테이블을 세분화하여 관리하므로 세심한 관리가 요구됨 테이블간 조인에 대한 비용이 증가함 용량이 작은 테이블에 파티셔닝을 수행하면 오히려 성능이 저하됨 종류 범위 분할 해시 분할 조합 분할 2. 클러스터링 데이터 저장시 데이터 액세스 효율을 향상시키기 위해 동일한 성격의 데이터를 동일한 데이터 블록에 저장하는 물리적 저장 방법 클러스터 대상 테이블 분포도가 넓은 테이블 대량의 범위를 자주 조회하는 테이블 입력, 수정, 삭제가 자주 발생하지 않는 테이블 자주 조인되어 사용되는 테이블 ORDER BY, GROUP BY, UNION이 빈번한 테이블 3. 데이터베이스 백업 데이터베이스 백업은 전산 장비의 장애에 대비하여 데이터베이스에 저장된 데이터를 보호하고 복구하기 위한 작업 로그 파일 데이터베이스의 처리 내용이나 이용 상황 등 상태 변화를 시간의 흐름에 따라 모두 기록한 파일 데이터베이스 복구 알고리즘 NO-UNDO/REDO UNDO/NO-REDO UNDO/REDO NO-UNDO/NO-REDO 백업 종류 물리 백업 논리 백업 4. 데이터베이스 용량 설계 데이터베이스 용량을 설계할 때는 테이블에 저장할 데이터양과 인덱스, 클러스터 등이 차지하는 공간 등을 예측하여 반영함 데이터베이스의 용량을 정확히 산정하여 디스크의 저장 공간을 효과적으로 사용하고 확장성 및 가용성을 높임 테이블스페이스 설계 시 고려사항 테이블스페이스는 업무별로 구분하여 지정 대용량 테이블은 하나의 테이블스페이스에 독립적으로 저장 테이블과 인덱스는 분리하여 저장 LOB(Large Object)타입의 데이터는 독립적인 공간으로 지정 5. 데이터 지역화 Locality 데이터베이스의 저장 데이터를 효율적으로 이용할 수 있도록 저장하는 방법 물리적 데이터베이스 설계, 보조 기억 장치의 역할, 디스크 상의 파일의 배치를 지역화 관점에서 검토","link":"/2020/05/15/Engineer_Information_Processing/ch13_%EB%AC%BC%EB%A6%AC%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EC%84%A4%EA%B3%84/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EB%AC%BC%EB%A6%AC%EC%86%8D%EC%84%B1%EC%84%A4%EA%B3%84/%ED%95%B5%EC%8B%AC%EC%A0%95%EB%A6%AC/"},{"title":"물리데이터베이스 - CRUD분석","text":"물리데이터베이스 CRUD의 개념 구분 조작 SQL Create 생성 INSERT Read 읽기/인출 SELECT Update 갱신 UPDATE Delete 삭제/제거 DELETE CRUD 분석의 개념 데이터베이스 테이블에 변화를 주는 트랜잭션의 CRUD 연산에 대해 CRUD 매트릭스를 작성하여 분석하는 것 테이블에 발생하는 트랜잭션의 주기별 발생횟수를 파악하고 연관된 테이블을 분석하면 테이블에 저장되는 데이터의 양을 유추할 수 있고 트랜잭션이 몰리는 테이블 분석 가능 CRUD 연산의 우선순위 C &gt; D &gt; U &gt; R 활용목적에 따라 모두 적을 수 도 있음 CRUD 매트릭스 분석 개념 데이터 프로세스와 엔티티 목록으로 CRUD Matrix 작성 CRUD 매트릭스 점검사항 모든 엔티티 타입에 CRUD가 한 번 이상 표기되었는가? 모든 엔티티 타입에 C가 한 번 이상 존재하는가? 모든 엔티티 타입에 R이 한 번 이상 존재하는가? 모든 단위 프로세스가 하나 이상의 엔티티 타입에 표기가 되는가?","link":"/2020/05/18/Engineer_Information_Processing/ch13_%EB%AC%BC%EB%A6%AC%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EC%84%A4%EA%B3%84/%EB%AC%BC%EB%A6%AC%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%AA%A8%EB%8D%B8%ED%92%88%EC%A7%88%EA%B2%80%ED%86%A0/CRUD%EB%B6%84%EC%84%9D/"},{"title":"물리데이터베이스 - E-R 다이어그램","text":"물리데이터베이스 논리 데이터 모델의 물리 데이터 모델 변환 엔티티는 테이블, 속성은 칼럼 등으로 변환 규칙 논리적 설계 물리적 설계 데이터베이스 엔티티 Entity 테이블 Table 테이블 속성 Attribute 칼럼 Column 칼럼 주 식별자 Primary Identifier 기본 키 Primary Key 기본 키 외래 식별자 Foreign Identifier 외래 키 Foreign Key 외래 키 관계 Relationship 관계 Relationship - 논리 데이터 모델 물리 데이터 모델 변환 순서 1. 단위 엔티티를 테이블로 변환 논리 모델에서 정의된 엔티티는 물리 모델에서 테이블로 변환 엔티티는 한글명, 테이블은 영문명으로 명칭을 동일하게 사용 메타데이터시스템과 같은 사전에 표준화된 용어가 있을 경우 메타에 등록되어 있는 단어 사용하여 명명 1.1 슈퍼 타입 기준 테이블 변환 서브타입을 슈퍼 타입에 통합하여 하나의 테이블로 만드는 것 서브타입에 속성이나 관계가 적을 경우에 적용하는 방법 하나로 통합된 테이블에는 서브 타입의 모든 속성 포함 1.2 슈퍼 타입 변환 장/단점 장점 데이터의 액세스가 상대적으로 용이 뷰를 이용하여 각각의 서브 타입 만을 액세스하거나 수정 가능 수행 속도 향상 서브 타입 구분이 없는 임의 집합에 대한 가공 용이 다수의 서브 타입을 통합하는 경우 조인 감소 복잡한 처리를 하나의 SQL로 통합 용이 단점 특정 서브 타입에 대한 NOT Null 제한이 어려움 테이블의 칼럼 증가로 디스크 저장 공간 증가 처리마다 서브 타입에 대한 구분이 필요할 경우가 많이 발생 인덱스의 크기 증가로 인덱스 효율이 낮아짐 1.3 서브 타입 기준 테이블 변환 슈퍼타입 속성들을 각각의 서브 타입에 추가하여 서브타입들을 개별적인 테이블로 만드는 것 서브 타입에 속성이나 관계가 많을 경우에 적용 1.4 서브 타입 변환 장/단점 장점 각 서브 타입 속성들의 선택 사양이 명확한 경우에 유리 서브 타입 유형에 대한 구분을 처리 마다할 필요가 없음 여러 개의 테이블로 통합하므로 테이블 당 크기가 감소하여 전체 테이블을 스캔하는 경우 유리 단위 테이블의 크기 감소 단점 서브 타입 구분 없이 데이터를 처리하는 경우 UNION이 발생 처리 속도 감소가 발생할 가능성이 높아짐 트랜잭션을 처리하는 경우 다수 테이블을 처리하는 경우가 자주 발생 복잡한 처리를 하는 SQL의 통합이 어려움 부분 범위에 대한 처리가 곤란해짐 여러 테이블을 통합한 경우 뷰로 조회만 가능 UID의 유지관리가 어려움 Unique Identifier, 식별자 1.5 개별 타입 기준 테이블 변환 슈퍼 타입과 서브 타입들을 각각의 개별적인 테이블로 변환 슈퍼 타입과 서브 타입 각각의 테이블 사이에는 1:1 관계 형성 1.6 개별 타입 기준 테이블 변환을 사용하는 경우 전체 데이터에 대한 처리가 자주 발생하는 경우 서브 타입 처리가 대부분 독립적으로 발생하는 경우 통합하는 테이블의 칼럼 수가 지나치게 많은 경우 서브 타입 칼럼 수가 다수인 경우 트랜잭션이 주로 슈퍼 타입에서 발생하는 경우 슈퍼 타입에서 범위가 넓은 처리가 빈번하게 발생하여 단일 테이블 클러스터링이 필요한 경우 2. 속성을 Column 칼럼으로 변환 칼럼의 명칭은 속성의 명칭과 반드시 일치할 필요는 없으나, 개발자와 사용자간 의사소통을 위해 가능한 표준화된 약어를 사용 SQL 예약어 사용은 피해야 함 SQL 문장의 가독성을 위해 칼럼 명칭은 가능한 짧게 칼럼명에 복합 단어 사용할 경우 미리 정의된 표준에 의해 명명 3. UID를 기본키로 변환 엔티티의 UID는 기본키로 선언 Not NULL, Unique 등의 제약 조건을 추가적으로 정의 4. 관계를 외래키로 변환 1:n 관계에서 1영역에 있는 기본키를 n영역의 외래키로 선언 외래키명은 1영역의 기본키 이름을 사용하거나 다른 의미를 가질 경우 변경하여 명명 순환 관계에서 자신의 기본키는 외래키로 정의 5. 관리 목적의 테이블/칼럼 추가 논리 모델링에서는 필요가 없으나 관리 또는 데이터베이스를 이용하는 프로그래밍의 수행 속도를 향상을 위해 추가 되는 테이블이나 칼럼 관리상 필요한 데이터를 등록한 일자, 시스템 번호 등을 의미 6. 칼럼 유형과 길이 정의 정의된 각 컬럼에 대해, 적용 DBMS에서 제공하는 데이터 유형 중 적절한 유형 정의 해당 데이터의 최대 길이를 파악하여 길이 설정 자주 사용되는 데이터 유형 7. 데이터 표준 적용 명명 규칙 및 표준 용어 사전을 활용하여 각 객체의 데이터 표준 수행 표준화 적용대상 데이터베이스 스토리지 그룹 테이블 스페이스 테이블 칼럼 인덱스 뷰","link":"/2020/05/18/Engineer_Information_Processing/ch13_%EB%AC%BC%EB%A6%AC%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EC%84%A4%EA%B3%84/%EB%AC%BC%EB%A6%AC%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%AA%A8%EB%8D%B8%ED%92%88%EC%A7%88%EA%B2%80%ED%86%A0/ER%EB%8B%A4%EC%9D%B4%EC%96%B4%EA%B7%B8%EB%9E%A8/"},{"title":"물리데이터베이스 - 물리데이터 모델 품질 기준","text":"물리데이터베이스 SQL 성능 튜닝의 정의 튜닝 대상이 되는 SQL을 이해하고 정보를 분석하여 성능을 개선하는 활동 최소한의 CPU, I/O, 메모리를 사용하여 최대한 빠른 시간 내에 원하는 작업을 수행하도록 만드는 것 SQL 성능 튜닝의 순서 문제 있는 SQL 식별 옵티마이저 통계 확인 실행 계획 검토 SQL문 재구성 인덱스 재구성 실행 계획 유지 관리 SQL 성능 튜닝 순서 1. 문제 있는 SQL 식별 애플리케이션의 성능을 관리하거나 모니터링하기 위한 툴인 APM을 활용 APM; Application Performance Management 2. 옵티마이저 통계확인 개발자가 작성한 SQL을 가장 빠르고 효율적으로 수행할 최적의 처리경로를 생성해 주는 데이터베이스 핵심 모듈 Oracle은 CBO와 RBO 모드 지원 CBO; Cost Based Optimizer RBO; Rule Based Optimizer 3. 실행 계획 검토 DBMS의 옵티마이저가 수립한 SQL 코드의 실행 절차와 방법을 의미 요구사항들을 처리하기 위한 연산 순서가 적혀 있으며, 연산에는 조인, 테이블, 검색, 필터, 정렬 등이 있음 Driving 테이블이 최상의 필터를 가지고 있는지를 중심으로 검토 Driving 테이블 조인이 발생할 때 첫 번째로 액세스 되는 테이블 드라이빙 테이블 순서에 따라 데이터를 액세스하는 양이 대폭 늘어나거나 줄어들 수 있기 때문에 어떤 테이블을 먼저 드라이빙 하는지가 매우 중요 가장 적은 데이터를 추출할 것으로 예상되는 테이블을 먼저 드라이빙 처리량이 작은 Table을 Driving 테이블로 지정되었는지 확인 4. SQL문 재구성 WHERE절 사용 칼럼 변경 연산자 확인 범위 한정 사용 서브쿼리에 특정 데이터가 존재하는지 확인할 때는 EXISTS 보다 IN 사용 5. 인덱스 재구성 인덱스 구성 실행 계획 검토 관련 SQL 검토 코드 테이블 확인 단일 인덱스로 조회만 이루어진 테이블은 IOT로 구성 불필요한 인덱스 제거 6. 실행 계획 유지관리 실행 계획이 유지되고 있는지 모니터링하고 관리 데이터베이스 버전 업그레이드시 데이터의 시스템 이동 등 시스템 환경의 변경 사항 발생시","link":"/2020/05/18/Engineer_Information_Processing/ch13_%EB%AC%BC%EB%A6%AC%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EC%84%A4%EA%B3%84/%EB%AC%BC%EB%A6%AC%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%AA%A8%EB%8D%B8%ED%92%88%EC%A7%88%EA%B2%80%ED%86%A0/SQL%EC%84%B1%EB%8A%A5%ED%8A%9C%EB%8B%9D/"},{"title":"물리데이터베이스 - 물리데이터 모델 품질 기준","text":"물리데이터베이스 물리데이터 모델에 대하여 정확성, 완전성, 준거성, 최신성, 일관성, 활용성의 품질기준을 적용 논리 데이터 모델과 물리 데이터 모델을 비교하여 테이블, 칼럼, 키, 오브젝트 구성 요소의 누락 여부와 일치성을 확인 논리 데이터베이스 설계에서 엔티티, 속성, 주식별자, 외래식별자를 각각 테이블, 칼럼, 기본 키, 외래 키로 변환하여 표현 CRUD 분석과 SQL 성능 튜닝의 개념과 절차를 이해 물리 데이터 모델 품질 기준 물리 데이터 모델을 설계하고 데이터베이스 객체를 생성한 후 개발 단계로 넘어가기 전에 모델러와 이해관계자들이 모여 수행 시스템 성능에 직접적인 영향을 미치므로 향후 발생할 문제에 대해 면밀히 검토해야 함 데이터베이스 성능 향상과 오류 예방 검토시 모든 이해관계자가 동의하는 검토 기준이 필요 품질기준 정확성 데이터 모델이 표기법에 따라 정확하게 표현되었고, 업무영역 또는 요구사항이 정확하게 반영되었음을 의미 예시 사용된 표기법에 따라 데이터 모델이 정확하게 표현되었는가? 대상 업무 영역의 업무 개념과 내용이 정확하게 표현되었는가? 요구사항의 내용이 정확하게 반영되었는가? 업무 규칙이 정확하게 표현되었는가? 완정성 데이터 모델의 구성 요소를 정의하는데 있어서 누락을 최소화하고, 요구 사항 및 업무 영역 반영에 있어서 누락이 없음을 의미 예시 물리 데이터 모델 작성 항목의 충실도 필요한 설명 항목(테이블/칼럼 설명)들의 작성 상태 물리 모델링 단계에서 결정해야 할 항목들의 작성 성태(칼럼 데이터 타입 및 길이, Null 허용 여부, 서브타입 변환 등 필요에 따라서는 저장공간 지정, 테이블/인덱스 생성 관련 파라미터 결정 사항등까지도 포함) 요구 사항 반영 및 업무 영역 방녕의 완전성 : 목적하는 업무 영역을 기술한 논리 데이터 모델의 구성 요소(엔티티, 속성, 관계, 식별자)들이 누락없이 물리 데이터 모델로 변환되어 정의된 정도 준거성 제반 준수 요건들이 누락 없이 정화하게 준수되었음을 의미 예시 데이터 표준, 규칙 등을 준수하였는가? 법적 요건을 준수하였는가? 법적 요건을 준수하기에 충분하도록 도메인이 정의 되었는가? 최신성 데이터 모델이 현행시스템의 최신 상태를 반영하고 있고, 이슈 사항들이 지체 없이 반영되고 있음을 의미 예시 엄무상의 변경이나 결정 사항 등이 시의 적절하게 반영되고 있는가? 최근의 이슈 사항이 반영되었는가? 현행 데이터 모델의 현행 시스템과 일치하는가? 일관성 여러 영역에서 공통 사용되는 데이터 요소가 전사 수준에서 한 번만 정의되고 이를 여러 다른 영역에서 참조/활용되면서, 모델 표현상의 일관성을 유지하고 있음을 의미 예씨 여러 주제 영역에서 공통적으로 사용되는 개체는 일관성 있게 사용되는가?(전사 수준에서 한 번만 정의되고 이를 여러 다른 영역에서 참조/활용한다는 의미에서 통합성이라고하기도 함) 모델 표현상의 일관성을 유지하고 있는가? 동일/유사 목적/용도의 칼럼들은 일관성 있게 정의되었는가? 조인 대상 칼럼들은 일관성있게 정의되었는가? 활용성 작성된 모델과 그 설명 내용이 이해관계자에게 의미를 충분하게 전달할 수 있으면서, 업무 변화 시에 설계 변경없이 최소화되도록 유연하게 설계되어 있음을 의미 예시 작성된 설명 내용이나 모델 표기 등이 사용자나 모델을 보는 사람에게 충분히 이해가 될 수 있고, 모델의 작성 의도를 명확하게 이해할 수 있는가(의사소통의 충분성) PK, UK 등의 칼럼 구성은 데이터 무결성을 보장하면서 데이터 액세스를 효율화 하기에 충분한가? 논리 데이터 모델의 유연성이 물리 데이터 모델에도 반영되었는가(오류가 적고 업무 변화에 유연하게 대응하여 데이터 구조의 변경이 최소화 될 수 있는 설계 결과) 코드화 대상 칼럼에 대한 코드 정의는 업무 지원 및 적용에 충분한가? 물리 데이터 모델의 품질 검토 순서 데이터 품질 정책 및 기준 확인 물리 데이터 품질의 특성에 따라 품질 기준 작성 데이터 품질 기준에 따라 체크리스트 작성 논리 데이터 모델과 물리 데이터 모델 비교 각 모델링 단계의 모델러와 이해관계자가 품질 검토 수행 모델러와 이해관계자가 작성한 체크리스트 내용을 종합하여 물리 데이터베이스 모델의 품질 검토 보고서 작성","link":"/2020/05/18/Engineer_Information_Processing/ch13_%EB%AC%BC%EB%A6%AC%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EC%84%A4%EA%B3%84/%EB%AC%BC%EB%A6%AC%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%AA%A8%EB%8D%B8%ED%92%88%EC%A7%88%EA%B2%80%ED%86%A0/%EB%AC%BC%EB%A6%AC%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%AA%A8%EB%8D%B8%ED%92%88%EC%A7%88%EA%B8%B0%EC%A4%80/"},{"title":"물리데이터베이스 - 핵심정리","text":"물리데이터베이스 1. 물리 데이터 모델 품질 기준 데이터베이스 성능 향상과 오류 예방 품질 기준 정확성 완전성 준거성 최신성 일관성 활용성 2. 물리 E-R 다이어그램 논리데이터 모델 물리 데이터 모델 변환 단위 엔티티 -&gt; 테이블 속성 -&gt; 칼럼 UID -&gt; 기본키 관계 -&gt; 외래키 관리 목적의 테이블/칼럼 추가 칼럼 유형과 길이 정의 데이터 표준 적용 3. CRUD 분석 CRUD 매트릭스 분석 개념 데이터 프로세스를 행으로 하고 엔티티 목록을 열로 하여 CRUD Matrix를 작성한 후 CRUD Matrix에서 사용되지 않는 프로세스와 엔티티 여부 확인하는 분석 기법 점검사항 모든 엔티티 타입에 CRUD가 한 번 이상 표기되었는가? 모든 엔티티 타입에 C가 한 번 이상 존재하는가? 모든 엔티티 타입에 R이 한 번 이상 존재하는가? 모든 단위 프로세스가 하나 이상의 엔티티 타입에 표기가 되는가? 4. SQL 성능 튜닝 SQL 성능 튜닝의 정의 튜닝 대상이 되는 SQL을 이해하고 정보를 분석하여 성능을 개선하는 활동 SQL 성능 튜닝의 순서 문제 있는 SQL 식별 옵티마이저 통계 확인 실행 계획 검토 SQL문 재구성 인덱스 재구성 실행 계획 유지 관리","link":"/2020/05/18/Engineer_Information_Processing/ch13_%EB%AC%BC%EB%A6%AC%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EC%84%A4%EA%B3%84/%EB%AC%BC%EB%A6%AC%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%AA%A8%EB%8D%B8%ED%92%88%EC%A7%88%EA%B2%80%ED%86%A0/%ED%95%B5%EC%8B%AC%EC%A0%95%EB%A6%AC/"},{"title":"물리데이터베이스 - 반정규화","text":"물리데이터베이스 반정규화 Denormalization 개념 시스템의 성능 향상, 개발 및 운영의 편의성 등을 위해 정규화된 데이터 모델을 통합, 중복, 분리하는 과정으로 의도적으로 정규화 원칙을 위배하는 행위 반정규화를 수행하면 시스템의 성능이 향상되고 관리 효율성은 증가하지만 데이터의 일관성 및 무결성이 저하될 수 있므 과도한 반정규화는 오히려 성능을 저하시킬 수 있음 데이터의 일관성과 무결성을 우선으로 할 지, 데이터베이스의 성능과 단순화를 우선으로 할 지를 사전에 결정해야 함 방법 테이블 통합 테이블 분할 중복 테이블 추가 중복 속성 추가 반정규화 방법 1. 테이블 통합 테이블 조인이 많은 경우 하나의 테이블로 합치는 것이 성능 향상에 유리 종류 1:1 관계 테이블 통합 1:N 관계 테이블 통합 수퍼타입/서브타입 테이블 통합 고려사항 데이터 검색은 간편하지만, 레코드 증가로 처리량 증가 입력, 수정, 삭제 규칙의 복잡도 증가 2. 테이블 분할 테이블에서 특정 레코드나 특정 속성에 집중적으로 접근할 경우 테이블 분할 종류 수평 분할 수직 분할 2.1 수평 분할 Record 레코드를 기준으로 테이블을 분할 레코드별로 사용 빈도의 차이가 큰 경우 사용 빈도에 따라 분할 2.2 수직 분할 테이블의 많은 속성 중 특정 속성들만 접근이 잦을 경우 속성을 기준으로 테이블을 분할 갱신 위주의 속성 분할 데이터 갱신 시 레코드 잠금으로 인해 다른 작업을 수행할 수 없으므로 갱신이 자주 일어나는 속성 분할 자주 조회되는 속성 분할 자주 조회되는 속성이 극히 일부일 경우 자주 사용되는 속성을 수직 분할하여 사용 크기가 큰 속성 분할 이미지나 2GB이상 저장 될 수 있는 텍스트 형식 등으로 된 속성을 수직 분할하여 사용 보안을 적용해야 하는 속성 분할 테이블 내 특정 속성에 대한 보안ㅇ르 적용할 수 없으므로 보안을 적용해야 하는 속성들을 수직분할하여 사용 2.3 테이블 분할 시 고려사항 기본키의 유일성 관리가 어려움 데이터 양이 적거나 사용 빈도가 낮은 경우 테이블 분할이 필요한지를 고려 분할된 테이블의 전체 조회 시는 Union을 사용해야하므로 수행 속도가 느려짐 데이터 검색에 중점을 두어 테이블 부할 여부를 결정해야 함 3. 중복 테이블 추가 여러 테이블에서 데이터를 추가해서 사용해야 하는 경우 다른 서버에 저장된 테이블을 이용해야하는 경우 3.1 중복 테이블을 추가하는 경우 정규화로 인해 수행 속도가 느려지는 경우 많은 범위의 데이터를 자추 처리해야하는 경우 특정 범위의 데이터를 자추 처리해야하는 경우 처리 범위를 줄이지 않고는 수행 속도를 개선할 수 없는 경우 3.2 중복 테이블 추가하는 방법 집계 테이블 추가 SUM, AVG 등 집계 데이터를 위한 테이블을 생성하고, 각 원본 테이블에 트리거를 설정하여 사용하는 것 이력 테이블 추가 이력 관리 드으이 목적으로 추가하는 테이블로, 적절한 데이터 양의 유지와 활용도를 제고하기 위해 기본키를 적절히 설정 부분 테이블 추가 하나의 테이블의 전체 칼럼 중 자주 이용하는 집중화 된 칼럼들이 있을 때 해당 칼럼들을 모아 놓은 별도의 반정규화된 테이블 생성 4. 중복 속성 추가 테이블을 조인해서 데이터를 처리할 때 데이터를 조회하는 경로를 단축하기 위해 자주 사용하는 속성을 추가하는 것 4.1 중복 속성을 추가하는 경우 조인이 자주 발생하는 속성인 경우 접근 경로가 복잡한 속성인 경우 기본키의 형태가 적절하지 않거나 여러 개의 속성으로 구성된 경우 4.2 중복 속성 추가 시 고려사항 테이블 중복과 속성의 중복을 고려 테이블 일관성 및 무결성에 유의 SQL 그룹 함수를 이용하여 처리할 수 있어야 함 저장 공간의 지나친 낭비를 고려","link":"/2020/05/17/Engineer_Information_Processing/ch13_%EB%AC%BC%EB%A6%AC%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EC%84%A4%EA%B3%84/%EB%AC%BC%EB%A6%AC%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EB%AA%A8%EB%8D%B8%EB%A7%81/%EB%B0%98%EC%A0%95%EA%B7%9C%ED%99%94/"},{"title":"물리데이터베이스 - 칼럼 속성","text":"물리데이터베이스 칼럼 속성의 정의 및 특징 속성은 데이터베이스를 구성하는 가장 작은 논리적 단위 파일 구조상의 데이터 항목 또는 데이터 필드에 해당됨 속성은 개체의 구성 항목이며 특성을 기술 속성의 수는 Degree 또는 차수라고 함 속성의 특성에 따른 분류 기본 속성 Basic Attribute 업무 분석을 통해 정의한 속성 개체 타입에 가장 일반적이고 많은 속성을 차지 업무로부터 분석한 속성이라도 이미 업무상 코드로 정의한 속성은 기본 속성에서 제외 설계 속성 Designed Attribute 원래 업무에는 존재하지 않지만 설계를 하면서 도출하는 속성 업무의 필요에 의해 새로 만들거나 변형하여 정의한 속성 파생 속성 Derived Attribute 다른 속성으로부터 계산이나 변형되어 생성되는 속성 다른 속성의 영향을 받기 때문에 정합성 유지를 위해 가급적 파생 속성을 적게 정의하는 것이 좋음 개체 구성 방식에 따른 분류 기본키 속성 개체를 식별할 수 있는 속성 외래키 속성 다른 개체와의 관계에서 포함된 속성 일반 속성 개체에 포함되어 있고 기본 키, 외래 키에 포함되지 않은 속성 속성 후보 선정 원칙 원시 속성으로 보이는 후보는 버리지 않음 소그룹별로 후보군을 만들고 가장 근접한 개체에 할당 속성명 지정 원치 해당 업무에서 사용하는 이름을 부여 서술식 속성명은 사용하지 않음 약어 사용은 가급적 자제 개체 타입명은 속성명으로 사용해서는 안됨 개체타입에서 유일하게 식별 가능하도록 지정","link":"/2020/05/17/Engineer_Information_Processing/ch13_%EB%AC%BC%EB%A6%AC%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EC%84%A4%EA%B3%84/%EB%AC%BC%EB%A6%AC%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EB%AA%A8%EB%8D%B8%EB%A7%81/%EC%B9%BC%EB%9F%BC%EC%86%8D%EC%84%B1/"},{"title":"물리데이터베이스 - 키 종류","text":"물리데이터베이스 키의 개념 데이터베이스에서 조건에 만족하는 튜플을 찾거나 순서대로 정렬할 때 튜플들을 서로 구분할 수 있는 기준이 되는 애트리뷰트 종류 슈퍼키 후보키 기본키 대체키 키의 특징 Uniqueness 유일성 하나의 키 값으로 하나의 튜플만을 유일하게 식별할 수 있어야 함 Minimality 최소성 릴레이션의 모든 튜플을 유일하게 식별하기 위해 꼭 필요한 속성만으로 구성 키의 종류 개념도 슈퍼키 &gt; 후보키 &gt; 대체키 &gt; 기본키 후보키 = 기본키 + 대체키 기본키 = 후보키 - 대체키 키의 종류 상세 슈퍼키 Super Key 한 릴레이션 내의 속성들의 집합으로 구성된 키 릴레이션을 구성하는 모든 튜플에 대해 유일성은 만족시키지만 최소성은 만족시키지 못함 ex) 학번+주민번호 후보키 Candidate Key 릴레이션을 구성하는 속성들 중에서 튜플을 유일하게 식별할 수 있는 하나 또는 몇 개의 속성의 집합 릴레이션의 모든 튜플에 대해 유일성과 최소성 모두 만족 기본키 Primary Key 릴레이션에서 튜플ㅇ르 구별할 수 있는 유일한 식별자 후보키 중에서 선정된 키로 유일성과 최소성 만족 기본키는 Null값을 가질 수 없고 중복값을 가질 수 없음 대체키 Primary Key 후보키가 둘 이상인 경우 기본키로 선택되지 못한 후보들키를 보조키라고도 함 외래키 Foreign Key 참조되는 릴레이션의 기본키와 대응되어 릴레이션 간에 참조관계 표현 참조 릴레이션의 기본키에 없는 값은 입력할 수 없음","link":"/2020/05/17/Engineer_Information_Processing/ch13_%EB%AC%BC%EB%A6%AC%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EC%84%A4%EA%B3%84/%EB%AC%BC%EB%A6%AC%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EB%AA%A8%EB%8D%B8%EB%A7%81/%ED%82%A4%EC%A2%85%EB%A5%98/"},{"title":"물리데이터베이스 - 데이터베이스 무결성","text":"물리데이터베이스 데이터베이스 무결성과 칼럼 속성 및 키 종류에 대해 이해 테이블 간의 조인을 줄이기 위한 칼럼 반정규화, 정규화에서 나눈 테이블을 하나의 테이블로 통합, 하나의 테이블을 여러 개 테이블로 분리, 요약 테이블을 생성의 방법으로 반정규화를 수행 반정규화에 따른 영향도를 조사하여 적절한 조치를 하고, 반정규화가 적용된 물리 데이터베이스 설계서를 작성 데이터베이스 무결성 Integrity 개념 데이터의 정확성, 일관성, 유효성, 신뢰성 등과 무효 갱신으로부터 데이터 보호 등을 위해 필요 무결성 제약 조건은 데이터베이스에 들어 있는 데이터의 정확성을 보장하기 위해 부정확한 자료가 데이터베이스 내에 저장되는 것을 방지 하기 위한 제약 조건임 무결정의 종류 개체 무결성 도메인 무결성 참조 무결성 사용자 정의 무결성 무결성의 종류 1. Entity Integrity 개체 무결성, 실체 무결성 개체의 유일성을 보장하기 위한 무결성 데이터베이스 테이블은 기본 키로 설정된 속성은 null 값이나 중복 값을 가질 수 없음 2. Domain Integrity 도메인 무결성, 영역 무결성 특정 속성 값이 미리 정의된 도메인 범위에 속해야 함 도메인은 하나의 애트리뷰트가 취할 수 있는 같은 타입의 원자값의 집합 3. Referential Integrity 참조 무결성 릴레이션은 참조할 수 없는 외래키 값을 가질 수 없음 외래키 값은 Null이거나 참조하는 릴레이션의 기본 키 값이어야 함 4. User Defined Integrity 사용자 정의 무결성 모든 데이터는 사용자가 정의한 제약 조건인 업무 규칙 Business Rule을 준수해야 함 데이터 무결성 강화 개념 데이터 품질에 직접적인 영향을 주며, 데이터의 품질을 확보하고 유지하기 위해서는 데이터베이싀 구축 과정에서 적정한 무결성 방안을 확보 해야 함 프로그램이 완성되고 데이터가 축척된 상태에서 무결성을 정의할 경우 많은 비용 발생 데이터베이스에서 모두 이뤄질 수 없으므로 복잡한 규칙을 기반으로 데이터 상호 간 유지해야할 정합성은 어플리케이션 내에서 처리 데이터 무결성 강화 방법 1. 애플리케이션 데이터를 조작하는 프로그램 내에 데이터 생성, 수정, 삭제 시 무결성 조건을 검증 하는 코드를 추가 장점 사용자 정의 같은 복잡한 무결성 조건을 구현 단점 소스코드에 분산되어 관리의 어려움이 있음 개별적으로 시행되므로 적정성 검토에 어려움 2. 데이터베이스 트리거 트리거 이벤트시 저장 SQL을 실행하여 무결성 조건을 실행 장점 통합 관리가 가능함 복잡한 요건 구현 가능 3. 제약 조건 데이터베이스 제약 조건 기능을 선언하여 무결성을 유지 장점 통합 관리가 가능함, 간단한 선언으로 구현 가능 변경이 용이하고, 유효/무효 상태 변경이 가능 원칙적으로 잘못된 데이터 발생을 막을 수 있음 단점 복잡한 제약 조건 구현이 불가능, 예외적인 처리가 불가능","link":"/2020/05/16/Engineer_Information_Processing/ch13_%EB%AC%BC%EB%A6%AC%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EC%84%A4%EA%B3%84/%EB%AC%BC%EB%A6%AC%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EB%AA%A8%EB%8D%B8%EB%A7%81/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EB%AC%B4%EA%B2%B0%EC%84%B1/"},{"title":"물리데이터베이스 - 데이터베이스 암호화","text":"물리데이터베이스 데이터베이스 보안 기능 적용 데이터베이스의 접근 권한 및 데이터베이스 동작 객체(sql, 프로시저, 트리거 등)의 보안 취약점을 보완하기 위해 보안 기능을 적용 민감 데이터는 데이터 자체의 보안 방안(암호화, 익명화 등)도 고려 고려사항 데이터베이스 접근 권한 데이터베이스, 스키마, 엔티티(테이블)의 접근 권한 관리(접근 권한 객체 관리 수준은 성능과 보안성을 고려하여 관리) 예시: 테이블 권한 관리 시 성능이 저하, 민감 테이블만 관리 악의적 코드 삽입 금지 프로시저(Procedure), 트리거(Trigger), 배치(Batch) 등 데이터베이스 객체의 동작상에 악의적인 코드가 삽입되지 않도록 동작 간 처리 민감 데이터 관리 개인 정보나 업무상 민감 데이터는 암/복호화나 익명화 처리를 통해 데이터베이스에서 관리 악의적 시도시 에러 처리 공격 패턴에 대한 사용자 정의 예외 처리를 적용하고 에러 처리 내용이 외부에서 조회되지 않도록 권한 관리 데이터베이스 암호화(Encryption) 알고리즘 데이터베이스 암호화 알고리즘은 크게 대칭 키, 해시, 비대칭 키 알고리즘이 사용됨 대칭 키 암호 알고리즘 DES ARIA 128/192/256 SEED 해시 알고리즘 SHA 256/384/512 HAS-160 비대칭 키 암호 알고리즘 RSA ECDSA 데이터베이스 암호화 기법 애플리케이션에서 암호화를 수행하는 API 방식과 데이터베이스에서 암호화를 수행하는 Plug-in 방식, API 방식과 Plug-in 방식을 혼합한 Hybrid 방식","link":"/2020/05/15/Engineer_Information_Processing/ch13_%EB%AC%BC%EB%A6%AC%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EC%84%A4%EA%B3%84/%EB%AC%BC%EB%A6%AC%EC%9A%94%EC%86%8C%EC%A1%B0%EC%82%AC%EB%B6%84%EC%84%9D/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EC%95%94%ED%98%B8%ED%99%94/"},{"title":"물리데이터베이스 - 핵심정리","text":"물리데이터베이스 1. 데이터베이스 무결성 데이터의 정확성을 보장하기 위해 부정확한 자료가 데이터베이스 내에 저장되는 것을 방지 하기 위한 제약 조건임 무결정의 종류 개체 무결성 도메인 무결성 참조 무결성 사용자 정의 무결성 2. 칼럼 속성 속성은 데이터베이스를 구성하는 가장 작은 논리적 단위 파일 구조상의 데이터 항목 또는 데이터 필드에 해당됨 특성에 따른 분류 기본 속성 설계 속성 파생 속성 개체 구성 방식에 따른 분류 기본키 속성 외래키 속성 일반 속성 3. 키 종류 데이터베이스에서 조건에 만족하는 튜플을 찾거나 순서대로 정렬할 때 튜플들을 서로 구분할 수 있는 기준이 되는 애트리뷰트 종류 슈퍼키 후보키 기본키 대체키 4. 반정규화 시스템의 성능 향상, 개발 및 운영의 편의성 등을 위해 정규화된 데이터 모델을 통합, 중복, 분리하는 과정으로 의도적으로 정규화 원칙을 위배하는 행위 방법 테이블 통합 테이블 분할 중복 테이블 추가 중복 속성 추가","link":"/2020/05/17/Engineer_Information_Processing/ch13_%EB%AC%BC%EB%A6%AC%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EC%84%A4%EA%B3%84/%EB%AC%BC%EB%A6%AC%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EB%AA%A8%EB%8D%B8%EB%A7%81/%ED%95%B5%EC%8B%AC%EC%A0%95%EB%A6%AC/"},{"title":"물리데이터베이스 - 데이터베이스 이중화 구성","text":"물리데이터베이스 데이터베이스 이중화 Database Replication 정의 시스템 오류로 인한 데이터베이스 서비스 중단이나 물리적 손상 발생 시 이를 복구하기 위해 동일한 데이터베이스를 복제하여 관리 하나 이상의 데이터베이스가 항상 같은 상태를 유지하므로 데이터베이스에 문제가 발생하면 복제된 데이터베이스를 이용하여 즉시 문제 해결 가능 여러 개의 데이터베이스를 동시에 관리하므로 사용자가 수행하는 작업이 데이터베이스 이중화 시스템에 연결된 다른 데이터베이스에도 동일하게 적용됨 애플리케이션을 여러 개의 데이터베이스로 분산시켜 처리하므로 데이터베이스 부하를 줄일 수 있음 데이터베이스 이중화를 이용하면 손쉽게 백업 서버 운영 가능 데이터 이중화의 분류 변경 내용의 전달 방식에 따라 Eager 기법과 Lazy 기법으로 나뉨 Eager 기법 트랜잭션 수행 중 데이터 변경이 발생하면 이중화 된 모든 데이터베이스에 즉시 전달하여 변경 내용이 즉시 적용되도록 하는 기법 Lazy 기법 트랜잭션의 수행이 종료되면 변경 사실을 새로운 트랜잭션에 작성하여 각 데이터베이스에 전달되는 기법으로, 데이터베이스마다 새로운 트랜잭션이 수행되는 것으로 간주됨 데이터 이중화의 구성 방법 활동-대기(Active-Standby) 방법과 활동-활동(Active-Active) 방법이 있음 Active-Active 두 개의 DB가 서로 다른 서비스를 제공하다가 둘 중 한쪽 DB에 문제가 발생하면 나머지 다른 DB가 서비스를 제공 두 개의 DB가 모두 처리하기 때문에 처리율이 높지만 구성 방법 및 설정이 복잡함 Active-Standby 한 DB가 활성 상태로 서비스하고 있으면 다른 DB는 대기하고 있다가 활성 DB에 장애 발생 시 대기 상태의 DB가 자동으로 모든 서비스를 대신 수행 구성 방법과 관리가 쉬워 많은 기업에서 이용","link":"/2020/05/15/Engineer_Information_Processing/ch13_%EB%AC%BC%EB%A6%AC%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EC%84%A4%EA%B3%84/%EB%AC%BC%EB%A6%AC%EC%9A%94%EC%86%8C%EC%A1%B0%EC%82%AC%EB%B6%84%EC%84%9D/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EC%9D%B4%EC%A4%91%ED%99%94%EA%B5%AC%EC%84%B1/"},{"title":"물리데이터베이스 - 분산데이터베이스","text":"물리데이터베이스 분산 데이터베이스의 정의 하나의 데이터베이스 관리 시스템(DBMS)이 여러 CPU에 연결된 저장장치들을 제어하는 형태의 데이터베이스 논리적으로 같은 시스템에 속하지만, 컴퓨터 네트워크를 통해 물리적으로 분산되어 있는 데이터베이스 데이터베이스를 연결하는 빠른 네트워크 환경을 이용하여 데이터베이스를 여러 지역 노드로 위치시켜 사용성과 성능을 극대화 시킨 데이터베이스 분산 데이터베이스 설계 시 고려사항 작업부하(Work Load)의 노드별 분산 정책 지역의 자치성 보장 정책 데이터의 일관성 정책 사이트나 회선의 고장으로 부터의 회복 기능 통신 네트워크를 통한 원격 접근 기능 분산 데이터베이스의 목표 투명성 위치투명성 액세스하려는 데이터베이스의 실제 위치를 알 필요 없이 단지 데이터베이스의 논리적인 명칭만으로 액세스 할 수 있음 중복투명성 동일 데이터가 여러 곳에 중복되어 있더라도 사용자는 마치 하나의 데이터만 존재하는 것처럼 사용하고, 시스템은 자동으로 여러 자료에 대한 작업을 수행 병행투명성 분산 데이터베이스와 관련된 다수의 트랜잭션들이 동시에 실현되더라도 그 트랜잭션의 결과는 영향을 받지 않음 장애투명성 트랜잭션, DBMS, 네트워크, 컴퓨터 장애에도 불구하고 트랜잭션을 정확하게 처리 분산 데이터베이스의 장/단점 장점 지역 자치성, 점증적 시스템 용량 확장 신뢰성과 가용성이 높음 효용성과 융통성이 높음 빠른 응답 속도와 통신비용 절감 시스템의 성능 향상 중앙 컴퓨터의 장애가 전체 시스템에 영향을 끼치지 않음 자료의 공유성 향상 시스템 규모의 적절한 조절 가능 각 지역 사용자의 요구 수용 증대 단점 소프트웨어 개발 비용 증가 DBMS가 수행할 기능이 복잡 데이터베이스 설계, 관리의 복잡성 오류의 잠재성 증가 처리 비용의 증가 데이터 무결성에 대한 위협 분산 데이터베이스 설계 방법 1. 테이블 위치 분산 테이블 위치 분산은 데이터베이스의 테이블을 각기 다른 서버에 분산시켜 배치하는 방법 테이블 위치를 분산할 때는 테이블의 구조를 변경하지 않으며, 다른 데이터베이스의 테이블과 중복되지 않게 배치 데이터베이스의 테이블을 각각 다른 위치에 배치하려면 해당 테이블들이 놓일 서버들을 미리 설정해야 함 2. Fragment 분할 테이블의 데이터를 분할하여 분산시키는 것 분할 규칙 완전성 : 전체 데이터를 대상으로 분할해야 함 재구성 : 분할된 데이터는 관계 연산을 활용하여 본래의 데이터로 재구성할 수 있어야 함 상호 중첩 배제 : 분할된 데이터는 서로 다른 분할의 항목에 속하지 않아야 함 주요 분할 방법 수평 분할 : 테이블을 행(Row) 단위로 분할 수직 분할 : 테이블을 열(Column) 단위로 분할 3. Allocation 할당 할당은 동일한 분할을 여러 개의 서버에 생성하는 분산 방법 중복이 없는 할당과 중복이 있은 할당으로 구분됨 비중복 할당 방식 최적의 노드를 선택해서 분산 데이터베이스의 단일 노드에서만 분할이 존재하도록 하는 방식 일반적으로 애플리케이션에는 릴레이션을 배타적 분할로 분리하기 힘든 요구가 포함되므로 분할된 테이블 간의 의존성은 무시되고 비용 증가, 성능 저하 등의 문제가 발생할 수 있음 중복 할당 방식 동일한 테이블을 다른 서버에 복제하는 방식 일부만 복제하는 부분 복제와 전체를 복제하는 완전 복제가 있음","link":"/2020/05/12/Engineer_Information_Processing/ch13_%EB%AC%BC%EB%A6%AC%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EC%84%A4%EA%B3%84/%EB%AC%BC%EB%A6%AC%EC%9A%94%EC%86%8C%EC%A1%B0%EC%82%AC%EB%B6%84%EC%84%9D/%EB%B6%84%EC%82%B0%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4/"},{"title":"물리데이터베이스 - 물리요소 조사 분석","text":"물리데이터베이스 기존 시스템을 분석하여 업무 영역과 시스템 영역으로 구분하여 용어 사전 기반으로 명명 규칙을 파악할 수 있다. 서버, 네트워크, 스토리지 자원을 조사하고, 데이터베이스가 설치될 시스템의 운영체계와 데이터베이스 버전을 확인할 수 있다. 데이터베이스 운영과 관련된 관리 요소를 파악하고, 데이터베이스 구조, 이중화 구성, 분산 구조, 접근제어, DB 암호화에 대한 시스템 조사 분석서를 작성할 수 있다. 용어사전 분산 데이터베이스 논리적으로 같은 시스템에 속하지만, 컴퓨터 네트워크를 통해 물리적으로 분산되어 있는 데이터베이스 데이터베이스 이중화 시스템 오류로 인한 데이터베이스 서비스 중단이나 물리적 손상 발생 시 이를 복구하기 위해 동일한 데이터베이스를 복제하여 관리 스토리지 시스템의 정의 스토리지는 단일 디스크로 처리할 수 없는 대용량의 데이터를 저장하기 위해 서버와 저장장치를 연결하는 기술 스토리지 종류 DAS(Direct Attached Storage) NAS(Network Attached Storage) SAN(Storage Area Network) DAS; Direct Attached Storage DAS는 서버와 저장장치를 전용 케이블로 직접 연결하는 방식 저장장치를 직접 연결하므로 속도가 빠르고 설치 및 운영이 쉬움 초기 구축 비용 및 유지보수 비용이 저렴 다른 서버에서 접근할 수 없고 파일 공유 불가능 확장성 및 유연성이 상대적이 떨어짐 NAS; Network Attached Storage NAS는 서버와 저장장치를 네트워크를 통해 연결하는 방식 별도의 파일 관리 기능이 있는 NAS Storage가 내장된 저장장치를 관리하기 때문에 서버간 스토리지, 파일 공유 용이함 DAS에 비해 확장성 및 유연성이 우수함 네트워크 환경 상태에 영향을 많이 받음 접속 증가 시 성능이 저하될 수 있음 SAN; Storage Area Network SAN은 DAS의 빠른 처리와 NAS의 스토리지 공유 장점을 합친 방식 광케이블(FC)과 광채널 스위치를 통해 근거리 네트워크 환경을 구성하여 빠른 속도로 데이터 처리 저장 장치 연결로 스토리지 공유가 가능 스토리지 시스템 중 대용량 환경의 높은 트랜잭션 처리 효과적 기존 시스템의 경우 장비 업그레이드가 필요하고, 구축비용이 비쌈","link":"/2020/05/12/Engineer_Information_Processing/ch13_%EB%AC%BC%EB%A6%AC%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EC%84%A4%EA%B3%84/%EB%AC%BC%EB%A6%AC%EC%9A%94%EC%86%8C%EC%A1%B0%EC%82%AC%EB%B6%84%EC%84%9D/%EB%AC%BC%EB%A6%AC%EC%9A%94%EC%86%8C%EC%A1%B0%EC%82%AC%EB%B6%84%EC%84%9D/"},{"title":"물리데이터베이스 - 핵심정리","text":"물리데이터베이스 1. 스토리지 스토리지는 단일 디스크로 처리할 수 없는 대용량의 데이터를 저장하기 위해 서버와 저장장치를 연결하는 기술 스토리지 종류 DAS(Direct Attached Storage) NAS(Network Attached Storage) SAN(Storage Area Network) 2. 분산 데이터베이스 논리적으로 같은 시스템에 속하지만, 컴퓨터 네트워크를 통해 물리적으로 분산되어 있는 데이터베이스 분산 데이터베이스의 4가지 투명성 위치투명성 중복투명성 병행투명성 장애투명성 분산 데이터베이스 설계 방법 테이블 위치 분산 분할 할당 3. 데이터베이스 이중화 구성 시스템 오류로 인한 데이터베이스 서비스 중단이나 물리적 손상 발생 시 이를 복구하기 위해 동일한 데이터베이스를 복제하여 관리 데이터 이중화의 분류 Eager 기법 Lazy 기법 데이터 이중화의 구성 방법 Active-Active Active-Standby 4. 데이터베이스 암호화 데이터베이스 암호화 알고리즘은 크게 대칭 키, 해시, 비대칭 키 알고리즘이 사용됨 대칭 키 암호 알고리즘 DES ARIA 128/192/256 SEED 해시 알고리즘 SHA 256/384/512 HAS-160 비대칭 키 암호 알고리즘 RSA ECDSA 데이터베이스 암호화 기법 API 방식 Plug-in 방식 Hybrid 방식 5. 접근통제 데이터베이스에 대한 사용자들의 접근을 통제함으로써 데이터를 보호하는 방법 접근통제의 3요소 접근통제 정책 접근통제 메커니즘 접근통제 보안모델","link":"/2020/05/15/Engineer_Information_Processing/ch13_%EB%AC%BC%EB%A6%AC%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EC%84%A4%EA%B3%84/%EB%AC%BC%EB%A6%AC%EC%9A%94%EC%86%8C%EC%A1%B0%EC%82%AC%EB%B6%84%EC%84%9D/%ED%95%B5%EC%8B%AC%EC%A0%95%EB%A6%AC/"},{"title":"데이터전환 - 초기데이터구축","text":"데이터전환 작성된 데이터 변환 설계서의 데이터 변환 논리를 실행 가능한 변환 프로그램으로 구현 구현된 변환 프로그램을 데이터 전환 개발환경에서 테스트하여 프로그램의 정상동작을 확인하고 성능을 최적화 초기 데이터 구축 개념 기존 운영 시스템의 이해를 바탕으로 구축 범위를 명확하게 하여 구축 초기 데이터 구축 시 발생할 수 있는 예상 문제점을 도출하여 사전 점검 사항과 해결방안을 마련 초기 데이터 구축 절차 1. 구축 전략 수집 단시일에 대량의 데이터를 전환함에 있어 신속하고 안정적인 데이터 전환을 위하여 체계적인 초기 데이터 구축 전략을 수집 2. 초기 데이터 구축 대상 파악 초기 데이터 구축에 필요한 대상을 파악 3. 초기 데이터 구축 범위 업무 협의를 통해 초기 데이터 구축 범위를 확정 4. 초기 데이터 구축 시 세부 고려사항 데이터 이관 업무 중단을 최소화하고 안정성을 확보할 수 있는 방안 마련 데이터 이관 정합성 검증을 통해 오류방지 방안을 제시하여야하며, 오류 데이터에 대한 정비방안 마련 데이터 이관 완료 후 데이터의 전후 비교를 실시한 품질과 결과 제시 개인정보에 해당되는 데이터는 개인정보보호법과 관련 기준에서 정하는 기준에 따라 암호화하여 적용","link":"/2020/05/10/Engineer_Information_Processing/ch14_%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%A0%84%ED%99%98/%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%A0%84%ED%99%98%EA%B8%B0%EC%88%A0/%EC%B4%88%EA%B8%B0%EB%8D%B0%EC%9D%B4%ED%84%B0%EA%B5%AC%EC%B6%95/"},{"title":"데이터전환 - ETL","text":"데이터전환 ETL; Extraction, Transformation, Load 프로세스 특수한 엔진에서 진행되며 종종 변환 중인 데이터가 준비 테이블에서 임시로 보유되었다가 대상에 로드 됨 일반적으로 발생하는 데이터변환에는 필터링, 정렬, 집계, 데이터 조인, 데이터 정리, 중복 제거 및 데이터 유효성 검사 등의 작업 종종 시간 절약을 위해 데이터의 추출이 완료될 때 까지 기다리지 않고 데이터가 추출 되는 동안 이미 수신된 데이터가 변환되면서 로드 준비가 진행되고 준비된 데이터에 대한 로드 프로세스가 시작되는 방식으로 3가지 ETL 단계가 동시에 진행됨 ETL 프로세스별 방법 추출 Extraction JDBC, ODBC 기술의 이용 Flat File 생성 CDC; Change Data Capture 변환 Transformation 재구성, 정제, 변환, 데이터필드 검사, Rule 적용 데이터 통합 및 정제가 과도히 요구되는 경우, ETL작업의 80%는 변환과정에서 발생 로드 Load DBMS 고유 기능 Utility(Append, Delete/Insert, Update)이용","link":"/2020/05/10/Engineer_Information_Processing/ch14_%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%A0%84%ED%99%98/%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%A0%84%ED%99%98%EA%B8%B0%EC%88%A0/ETL/"},{"title":"데이터전환 - 파일처리기술","text":"데이터전환 1. 파일 처리 기술 개념 자료 구조 이론에서 파일처리 기술은 많은 양의 자료를 각종 매체에 저장하는 기법 파일을 하드디스크에 저장할 때 기억공간을 효율적으로 사용하고 필요한 자료의 탐색을 쉽게 하기 위해 파일을 효율적으로 처리하는 기술 종류 순차파일 색인 순차파일 가상 기억 접근방식 파일 직접파일 파일 처리 기술 종류 1. Sequential File 순차파일 입력되는 데이터들을 논리적인 순서에 따라 물리적 연속 공간에 순차적으로 기록하는 방식 급여 관리 등과 같이 변동 사항이 크지 않고 기간별로 일괄처리를 주로 하는 경우 적합 주로 순차 접근이 가능한 자기 테이프에 사용 장점 기록 밀도가 높아 기억공간을 효율적으로 사용 매체 변환이 쉬워 어떠한 매체에도 적용 가능 레코드를 기록할 때 사용한 키 순서대로 레코드를 처리하는 경우, 다른 편성법보다 처리속도가 빠름 단점 파일에 새로운 레코드를 삽입-삭제하는 경우 파일 전체를 복사해야하므로 시간이 많이 소요됨 데이터 검색 시 처음부터 순차적으로 검색하기 때문에 검색 효율이 낮음 2. Indexed Sequential File 색인 순차 파일 순차 처리와 랜덤 처리가 모두 가능하도록 레코드들을 키 값 순으로 정렬시켜 기록하고 레코드의 키 항목만을 모은 색인을 구성하여 편성하는 방식 ISAM; Index Sequential Access Method 방법이라고도 함 레코드를 참조할 때 색인을 탐색한 후 색인이 가리키는 포인터를 사용하여 직접참조 자기 디스크에 많이 사용되며, 자기 테이프에는 사용 불가 장점 순차 처리와 랜덤 처리가 모드 가능하므로 목적에 따라 융통성 있게 처리 가능 효율적인 검색이 가능하고 레코드의 삽입, 삭제, 갱신이 용이함 단점 색인 구역과 오버플로 구역을 구성하기 위한 추가 기억 공간이 필요함 파일이 정렬되어 있어야 하므로 추가, 삭제가 많으면 효율이 떨어짐 색인을 이용한 액세스를 하기 때문에 액세스 시간이 랜덤 편서 파일보다 느림 3. VSAM; Virtual Storage Access Method 가상 기억 접근 방식 파일 동적 인덱스 방법을 이용한 색인 순차 파일 데이터 레코드가 저장되는 부분인 제어 구간, 몇 개의 제어 구간을 모아 놓은 제어 구역, 제어 구역에 대한 인덱스를 저장한 순차 세트, 순차 세트의 상위 인덱스의 인덱스 세트로 구성 레코드를 삭제하면 그 공간을 재사용 가능 제어 구간에 가변 길이 레코드를 쉽게 수용 가능 4. Direct File 직접 파일 파일을 구성하는 레코드를 특정 순서 없이 임의의 물리적 저장공간에 기록하는 것으로, 랜덤파일, DAM파일이라고 함 레코드에 특정 기준으로 키가 할당되며, 해시 함수를 이용하여 이 키에 대한 보조기억장치의 물리적 상대 레코드 주소를 계산한 후 해당하는 주소에 레코드를 저장 임의 접근이 가능한 자기 디스크나 자기 드럼에서 사용 데이터의 입출력이 빈번히 발생하는 곳에 응용 장점 DSAD의 물리적 주소를 통하여 파일의 각 레코드에 직접 접근하거나 기록할 수 있으며, 접근 및 기록 순서에는 제약이 없음 접근 시간이 빠르고 레코드의 삽입, 삭제, 갱신이 용이 어떤 레코드라도 평균 접근시간 내에 검색가능 단점 레코드의 주소 변환 과정이 필요하며, 이 과정으로 인해 시간이 소요됨 기억공간의 효율이 저하될 수 있음 기억장치의 물리적 구조에 대한 지식이 필요하고 복잡함 충돌이 발생할 염려가 있으므로, 기억 공간의 확보가 필요","link":"/2020/05/10/Engineer_Information_Processing/ch14_%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%A0%84%ED%99%98/%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%A0%84%ED%99%98%EA%B8%B0%EC%88%A0/%ED%8C%8C%EC%9D%BC%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%88%A0/"},{"title":"데이터전환 - 데이터검증","text":"데이터전환 데이터 검증 개념 원천 시스템의 데이터를 목적 시스템의 데이터로 전환하는 과정이 정상적으로 수행되었는지 여부를 확인하는 과정 데이터 전환 검증은 검증 방법과 검증 단계에 따라 분류됨 데이터 검증 분류 1. 데이터 검증 방법에 따른 분류 검증 방법에 따라 로그 검증, 기본항목 검증, 응용 프로그램 검증, 응용 데이터 검증, 값 검증으로 분류 로그 검증 데이터 전환 과정에서 작성하는 추출, 전환, 적재 로그를 검증 기본 항목 검증 로그 검증 외에 별도로 요청된 검증 항목에 대해 검증 응용 프로그램 검증 응용 프로그램을 통한 데이터 전환의 정합성을 검증 응용 데이터 검증 사전에 정의된 업무 규칙을 기준으로 데이터 전환의 정합성을 검증 값 검증 숫자 항목의 합계 검증, 코드 데이터의 범위 검증, 속성 변에 따른 값 검증을 수행 정합성은 아님 2. 데이터 단계에 따른 분류 원천 데이터를 추출하는 시점부터 전환 시점, DB 적재 시점, DB 적재 후 시점, 전환 완료 후 시점별로 목적과 검증 방법을 달리하여 데이터 전화의 정합성을 검증","link":"/2020/05/10/Engineer_Information_Processing/ch14_%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%A0%84%ED%99%98/%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%A0%84%ED%99%98%EC%88%98%ED%96%89/%EB%8D%B0%EC%9D%B4%ED%84%B0%EA%B2%80%EC%A6%9D/"},{"title":"데이터전환 - 데이터전환수행계획","text":"데이터전환 데이터 전환 수행 계획서의 모의 전환 일정에 따라 모의 데이터 전환 차수별 데이터 전환 계획서와 본 데이터 전환 계획서를 작성 데이터 전환 수행자가 수행할 작업 항목, 작업 내용, 예정 시작/종료 시각, 작업 담당자를 포함하는 상세 체크리스트를 작성 작성된 데이터 전환 계획서와 체크리스트에 따라 데이터 변환 프로그램들을 실행하고 정상 동작 여부 모니터링 및 전환 결과 검증 데이터 전환 관정과 데이터 검증 결과를 분석하여 데이터 전환 결과 보고서를 작성 데이터 전환 절차 요구사항 분석 단계(전환 계획 및 요건정의) 설계 단계(전환 설계) 구현 단계(전환 개발) 테스트 단계(전환 테스트 및 검증) 세부적으로 22가지 상세 단계 데이터 전환 수행 계획 1. 데이터 전환 범위 선정 전환 대상의 상세 내용, 데이터 형식, 대상 건수 파악 필요에 따라서는 전환 제외 대상 기록 2. 데이터 전환 일정 선정 팀별 업무를 분장하여 팀별 역할과 납기를 기록 전환 차수의 결정은 통합 계획 및 테스트 계획에 의해 결정 3. 데이터 전환 절차 현행(As-Is) 시스템에서 목표(To-Be)시스템으로 데이터 전환을 위한 단계를 구분하고 각 단계별 작업 내용과 사용되는 도구를 별도로 기록 원천 데이터베이스의 데이터는 백업하여 스테이징 데이터베이스로 복구 한 후 정비 및 변환 작업을 수행하며 이는 원천 데이터베이스의 손상과 변형을 막기 위한 방법 데이터 전환이 완료된 후 검증단계에서는 스테이징 데이터베이스가 아닌 원천 데이터베이스와 비교하여 데이터 오류를 확인 4. 데이터 전환 계획서 작성 계획 -&gt; 수행 &gt; 결과 데이터 전환 개요 데이터 전환 목표 간결하고 명확하게 주요 성공 요인 전체 조건 및 제약사항 데이터 전환 대상 및 범위 데이터 전환 대상 데이터 전환 범위 데이터 전환 환경 구성 원천시스템 구성도 목적 시스템 구성도 전환 단계별 DISK 사용량 데이터 전환 조직 및 역할 데이터 전환 조직도 조직별 역할 업무 분담 계획 검증할 작업자와 작업자별 역할은 최대한 상세히 정리 데이터 전환 일정 데이터 전환 및 검증 작업별 상세한 일정 데이터 전환 방안 사전 준비 데이터 전환 설계 프로그램 개발 및 테스트 데이터 전환 리허설 데이터 전환 데이터 정비 방안 데이터 정비 대상 및 방법 데이터 정비 일정 및 조직 비상계획 데이터 전환 당일 구성될 종합상황실 및 의사소통 체계 데이터 복구 계획 데이터 전환 과정 오류 발생 또는 실패 시 백업 및 복구 방안 수립 데이터 전환 개발단계 전환 개발환경 구축 전환 프로그램 개발 검증 프로그램 개발","link":"/2020/05/10/Engineer_Information_Processing/ch14_%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%A0%84%ED%99%98/%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%A0%84%ED%99%98%EC%88%98%ED%96%89/%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%A0%84%ED%99%98%EC%88%98%ED%96%89%EA%B3%84%ED%9A%8D/"},{"title":"데이터전환 - 핵심정리","text":"데이터전환 1. 초기데이터 구축 기존 운영 시스템의 이해를 바탕으로 구축 범위를 명확하게 하여 구축 초기 데이터 구축 절차 구축 전략 수집 초기 데이터 구축 대상 파악 초기 데이터 구축 범위 초기 데이터 구축 시 세부 고려사항 2. ETL 다양한 소스시스템으로 부터 필요한 데이터를 추출(Extraction)하여 새로 개발할 정보시스템에서 운영 가능하도록 변환(Transformation) 작업을 거쳐 타깃 시스템으로 전송 및 로딩(Loading)하는 일련의 과정을 뜻함 3. 파일 처리 기술 자료 구조 이론에서 파일처리 기술은 많은 양의 자료를 각종 매체에 저장하는 기법 종류 순차파일 색인 순차파일 가상 기억 접근방식 파일 직접파일","link":"/2020/05/10/Engineer_Information_Processing/ch14_%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%A0%84%ED%99%98/%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%A0%84%ED%99%98%EA%B8%B0%EC%88%A0/%ED%95%B5%EC%8B%AC%EC%A0%95%EB%A6%AC/"},{"title":"물리데이터베이스 - 접근통제","text":"물리데이터베이스 접근 통제 Access Control 개념 데이터베이스에 대한 사용자들의 접근을 통제함으로써 데이터를 보호하는 방법 접근통제는 데이터에 대해 다음과 같은 통제를 함으로써 자원의 불법적인 접근 및 파괴를 예방 비인가된 사용자의 접근 감시 접근 요구자의 사용자 식별 접근 요구의 정당성 확인 및 기록 보안 정책에 근거한 접근의 승인 및 거부 등 접근통제의 3요소 접근통제 정책 접근통제 메커니즘 접근통제 보안모델 임의 접근통제와 강제 접근 통제 임의 접근통제 DAC; Discretionary Access Control 임의 접근통제는 데이터에 접근하는 사용자의 신원에 따라 접근 권한을 부여하는 방식 통제 권한이 주체에 있어 주체가 접근통제 권한을 지정하고 제어할 수 있음 일반적으로 특정 객체에 대한 조작 권한은 데이터베이스 관리 시스템으로 부터 부여 받지만 임의 접근통제에서는 객체를 생성한 사용자가 생성된 객체에 대한 모든 권한을 부여 받고, 부여된 권한을 다른 사용자에게 허가할 수 있음 임의 접근통제에 사용되는 SQL명령어 : GRANT와 REVOKE 강제 접근통제 MAC; Mandatory Access Control 강제 접근통제는 주체와 객체의 등급을 비교하여 접근 권한을 부여하는 방식 제3자가 접근통제 권한을 지정 데이터베이스 객체별로 보안 등급을 부여할 수 있고, 사용자 별로 인가 등급을 부여할 수 있음 주체는 자신보다 보안 등급이 높은 객체에 대해 읽기, 수정, 등록이 모두 불가능하고 보안 등급이 같은 객체에 대해서는 읽기, 수정, 등록이 가능함 접근통제의 3요소 접근 통제 정책 접근통제 정책은 어떤 주체가 언제, 어디서, 어떤 객체에게, 어떤 행위에 대한 허용 여부를 정의하는 것 신분 기반 정책 주체나 그룹의 신분에 근거하여 객체의 접근을 제한. IBP나 GBP가 있음 IBP(Individual–Based Policy) : 최소 권한 정책으로, 단일 주체에게 하나의 객체에 대한 허가를 부여  GBP(Group–Based Policy) : 복수 주체에 하나의 객체에 대한 허가를 부여 규칙 기반 정책 주체가 갖는 권한에 근거하여 객체의 접근을 제한. MLP와 CBP가 있음 MLP(Multi-Level Policy) : 사용자 및 객체별로 지정된 기밀 분류에 따른 정책 CBP(Compartment-Based Policy) : 집단별로 지정된 기밀 허가에 따른 정책 역학 기반 정책 GBP의 변형된 정책으로, 주체의 신분이 아니라 주체가 맡은 역할에 근거하여 객체의 접근을 제한하는 방법 예) 인사담당자, DBA 등 접근통제 매커니즘 정의된 접근통제 정책을 구현하는 기술적인 방법으로, 접근통제 목록, 능력 리스트, 보안 등급, 패스워드, 암호화 등이 있음 접근통제 목록 객체를 기준으로 특정 객체에 대해 어떤 주체가 어떤 행위를 할 수 있는지를 기록한 목록 능력 리스트 주체를 기준으로 주체에게 허가된 자원 및 권한을 기록한 목록 보안 등급 주체나 객체 등에 부여된 보안 속성의 집합으로, 이 등급을 기반으로 접근 승인 여부가 결정됨 패스워드 주체가 자신임을 증명할 때 사용하는 인증 방 암호화 데이터를 보낼 때 지정된 수신자 이외에는 내용을 알 수 없도록 평문을 암호문으로 변환하는 것으로, 무단 도용을 방지하기 위해 주로 사용함 접근통제 보안 모델 보안 정책을 구현하기 위한 정형화된 모델로, 기밀성 모델, 무결성 모델, 접근 통제 모델이 있음 기밀성 모델 시스템 내 정보와 자원은 인가된 사용자에게만 접근이 허용되는 것 군사적인 목적으로 개발된 최초의 수학적 모델 제약조건 단순 보안 규칙 : 주체는 자신보다 높은 등급의 객체는 읽을 수 없음 스타 보안 규칙 : 주체는 자신보다 낮은 등급의 객체에 정보를 쓸 수 없음 무결성 모델 기밀성 모델에서 발생하는 불법적인 정보 변경을 방지하기 위해 무결성을 기반으로 개발된 모델 무결성 모델은 데이터의 일관성 유지에 중점을 두어 개발 무결성 모델은 기밀성 모델과 동일하게 주체와 객체의 보안 등급을 기반으로 함 제약조건 단순 조안 규칙 : 주체는 자신보다 낮은 등급의 객체를 읽을 수 없음 스타 보안 규칙 : 주체는 자신보다 높은 등급의 객체에 정보를 쓸 수 없음 접근통제 모델 접근통제 메카니즘을 보안 모델로 발전시킴. 대표적으로 접근통제 행렬이 있음 접근통제 행렬은 행은 주체, 열은 객체 즉 행과 열로 주체와 객체의 권한유형을 나타냄","link":"/2020/05/15/Engineer_Information_Processing/ch13_%EB%AC%BC%EB%A6%AC%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EC%84%A4%EA%B3%84/%EB%AC%BC%EB%A6%AC%EC%9A%94%EC%86%8C%EC%A1%B0%EC%82%AC%EB%B6%84%EC%84%9D/%EC%A0%91%EA%B7%BC%ED%86%B5%EC%A0%9C/"},{"title":"데이터전환 - 체크리스트","text":"데이터전환 체크리스트 개념 전환 프로그램의 에러, 시간의 제약, 업무 프로세스의 변경, 빈번한 데이터 요건 변경, 하드웨어 장애 등의 위험요소에 최대한 대응하기 위해 체크리스트 작성 체크리스트 기재항목 데이터 전환 수행자가 수행할 작업의 상세 항목 작업 내용 예정 시작/종료 시각 작업 담당자 기재 데이터 전환 체크리스트 예시 작업프로세스는 포함 안됨","link":"/2020/05/10/Engineer_Information_Processing/ch14_%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%A0%84%ED%99%98/%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%A0%84%ED%99%98%EC%88%98%ED%96%89/%EC%B2%B4%ED%81%AC%EB%A6%AC%EC%8A%A4%ED%8A%B8/"},{"title":"데이터전환 - 데이터품질분석","text":"데이터전환 원천 데이터 품질 분석의 개념 원천 데이터의 품질이 보장되지 않으면 전환 후의 데이터도 정확하지 않으며, 전환 후의 데이터 정합성 검증 시 오류가 발생할 때 그 원인을 찾기도 어려움 따라서 전환 전에 원천 데이터의 품질을 검증함으로써 전환의 정확성을 보장할 수 있으며, 이전에 미처 발견하지 못한 데이터의 오류도 찾아낼 수 있음 원천 데이터 품질 검증을 위한 대표적인 정합성 항목 필수 항목의 데이터가 모두 존재하는가? 데이터의 유형이 정확하게 관리되고 있는가? 날짜의 경우 날짜로서 유효한 형태를 가지고 있는가? 금액의 경우 유효한 값의 범위인가? 계좌 번호 등이 정해진 법칙에 따른 번호인가? 영업점이 실제로 존재하는 영업점인가? 코드 값이 정해진 범위에 속하는가? 개설 일자, 해지 일자 등 모든 일자의 시점이 업무 규칙에 위배되지 않고 정확하게 설정되어 있는가? 업무 규칙에 위배되는 잘못된 정보가 존재하는가? 잔액의 총합이 회계정보와 동일한가? 보고서 값과 실제 데이터 값이 일치하는가? 목적 데이터 품질 분석 원천 데이터와 목적 데이터베이스 속성(Column)간 대응 관계는 1:1대응보다 N:M대응 관계가 더 많기 때문에 양자 간의 대응 관계를 정확히 표현하기 위해서는 데이터 레이아웃을 정확하게 파악하고 품질 검증 진행 목적 데이터베이스 전환 데이터 검증 고려 사항 현재 업무에서 사용하는 보고서나 통계용 정보를 사전에 조사하여 검증에 필요한 내용을 선정하고, 현재의 원장을 바탕으로 검증용 정보 도출 전환 데이터 검증은 데이터 전환 팀 인원 뿐만 아니라, 현업 인원도 함께 검증을 수행함으로써 검증의 정확성을 높이고 시간을 단축시키는 것이 중요함 전환 데이터의 대표적인 정합성 검증 항목 과목별 좌수 및 잔액 특정 기준으로 분류된 좌수 및 잔액 보고서 항목 또는 통계 수치 계좌 및 고객을 Sampling하여 해당 사항을 모두 검증 특수 관계가 있는 고객을 추출하여 관련된 데이터가 정확한지 검증","link":"/2020/05/10/Engineer_Information_Processing/ch14_%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%A0%84%ED%99%98/%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%A0%95%EC%A0%9C/%EB%8D%B0%EC%9D%B4%ED%84%B0%ED%92%88%EC%A7%88%EB%B6%84%EC%84%9D/"},{"title":"데이터전환 - 데이터정제","text":"데이터전환 원천 데이터와 전환된 목적 데이터베이스 데이터의 품질을 분석하여 정상 데이터와 오류 데이터를 정량적으로 측정 발견된 오류를 분석하여 오류의 원인을 파악하고 원천 데이터와 응용 프로그램의 정제 필요 여부를 결정 정제가 필요한 원천 데이터와 오류를 생성하는 원천 프로그램을 수정하기 위한 데이터 정제요청서를 작성 정제된 원천 데이터를 확이하여 데이터 정제 수행 결과를 검증하고, 데이터 정제보고서를 작성 데이터 품질 분석 -&gt; 오류 데이터 측정 -&gt; 오류 데이터 정제 단계별 데이터 정제 방안 1. 1단계 전환 테스트 전 정합성 마비 데이터 상호 간의 정합성이 유지될 수 있도록 데이터 보관 조건 업무 규칙을 적용한 정당한 값 또는 데이터 선별 불필요한 데이터 필드 사용하는 데이터의 경우 매핑을 수행 사용하지 않을 경우에는 해당 테이블 삭제 손실된 데이터 손실된 데이터를 정당한 값으로 복원 조건 손실된 데이터의 정당한 값을 알아야 함 맞지 않는 타입 정당한 타입의 데이터로 수정 조건 해당 데이터를 정당한 타입의 필드로 이전 오류 데이터 오류 데이터를 정당한 데이터로 변경 불필요한 데이터를 삭제 또는 초기화 조건 정당한 데이터의 기준 정의 2. 2단계 전환 테스트 시 전환 테스트 결과 발견된 오류 데이터 사전에 업무 규칙을 적용하여 정의한 정당한 데이터 값으로 정비 동일한 타입으로 전환 1단계 정제 대상 항목의 정제 내용과 동일하게 정제 조건 테스트 결과를 이용하여 정제 조건 결정 테스트 수행 과정에서 정제 대상 리스트 제시 3. 3단계 최종 전환 최종 전환 과정에서 정제 매핑 정의서에 작성된 전환 규칙을 이용하여 전환 프로그램에 해당 내용 추가하여 프로그램 수행 시 정제 조건 테스트 결과를 이용하여 정제 조건 결정 사전에 매핑 과정에서 정제 대상 및 정제 조건을 명확하게 제시","link":"/2020/05/10/Engineer_Information_Processing/ch14_%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%A0%84%ED%99%98/%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%A0%95%EC%A0%9C/%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%A0%95%EC%A0%9C/"},{"title":"데이터전환 - 핵심정리","text":"데이터전환 1. 데이터 전환 수행 계획 데이터 전환 절차는 전환 계획 및 요건정의, 전환 설계, 전환 개발, 전환 테스트 및 검증으로 구분할 수 있음 데이터 전환 수행 계획 작성을 위해서는 데이터 전환 범위, 전환 일정, 전환 절차를 명확히 해야 함 데이터 전환 계획서의 주요 항목 데이터 전환 개요, 데이터 전환 대상 및 범위 데이터 전환 환경구성, 데이터 전환 조직 및 역할 데이터 전환 일정, 데이터 전환 방안 데이너 정비 방안, 비상계획 2. 체크리스트 전환 프로그램의 에러, 시간의 제약, 업무 프로세스의 변경, 빈번한 데이터 요건 변경, 하드웨어 장애 등의 위험요소에 최대한 대응하기 위해 체크리스트 작성 체크리스트 기재항목 데이터 전환 수행자가 수행할 작업의 상세 항목 작업 내용 예정 시작/종료 시각 작업 담당자 기재 3. 데이터 검증 원천 시스템의 데이터를 목적 시스템의 데이터로 전환하는 과정이 정상적으로 수행되었는지 여부를 확인하는 과정 검증 방법에 따른 분류 로그 검증 기본 항목 검증 응용 프로그램 검증 응용 데이터 검증 값 검증 데이터 단계에 따른 분류 추출 전환 DB 적재 DB 적재 후 전환 완료 후","link":"/2020/05/10/Engineer_Information_Processing/ch14_%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%A0%84%ED%99%98/%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%A0%84%ED%99%98%EC%88%98%ED%96%89/%ED%95%B5%EC%8B%AC%EC%A0%95%EB%A6%AC/"},{"title":"서버프로그램구현 - 개발환경구축","text":"서버프로그램구현 응용소프트웨어 개발에 필요한 하드웨어 및 소프트웨어의 필요 사항을 검토하고, 이에 따라 개발환경에 필요한 준비를 수행 응용소프트웨어 개발에 필요한 하드웨어 및 소프트웨어를 설치하고 설정하여 개발환경을 구축 사전에 수립된 형상관리 방침에 따라 운영 정책에 부합하는 형상관리 환경을 구축 용어사전 구현도구 프로그램을 개발할 때 가장 많이 사용되는 도구로서 코드의 작성 및 편집, 디버깅 등과 같은 다양한 작업이 가능 클라이언트 시스템에서 제공하는 서버를 활용하기 위해 거래를 발생시키는 하드웨어 형상관리 소프트웨어 개발 과정에서 소프트웨어의 변경사항을 관리하기 위해 개발된 일련의 활동 개발환경 구축의 개념 해당 프로젝트의 목적과 구축 설계에 대한 명확한 이해가 필요 이에 맞는 하드웨어 소프트웨어 선정이 필요 제품들의 성능과 라이선스 그리고 사용 편의성 등에 대한 내용 파악도 필요 개발 하드웨어 환경 1. Client 클라이언트 환경 구성 서버 시스템에서 제공하는 서비스를 활용하기 위해 사용자와의 인터페이스를 제공하는 하드웨어 종류 PC 웹 브라우저 화면 모바일 앱 2. Server 서버 환경 구성 Web 웹 서버 클라이언트에서 요청하는 서비스의 속도를 향상시키기 위해 정적파일들을 제공하는 웹 서버 애플리케이션이 설치되는 하드웨어 WAS; Web Application Server 웹 애플리케이션 서버 동적 웹 서비스를 제공하기 위해 Tomcat, Underflow, IIS 등 미들웨어인 WAS와 서비스에 관련된 애플리케이션이 설치되는 하드웨어 Database 데이터베이스 서버 MySQL, Oracle 파일 서버 서비스 제공을 위해 파일을 저장하고, 공유하기 위한 파일 저장 하드웨어 개발 소프트웨어 환경 1. 시스템 소프트웨어 OS; Operation System 운영체제 종류 Windows Linux UNIX JVM; Java Virtual Machine Java 관련 응용프로그램을 가동하기 위한 인터프리터 환경 Web Server 정적 웹 서비스를 수행하는 미들웨어로서 웹 브라우저 화면에서 요청하는 정적파일 제공 종류 Apache Nginx IIS GWS WAS; Web Application Server 웹 애플리케이션을 수행하는 미드뤠어로서 웹서버와 JSP/Servlet 애플리케이션 수행을 위한 엔진으로 구성 종류 Tomcat Undertow JEUS Weblogic Websphere DBMS; Database Management System 데이터 저장과 관리를 위한 데이터베이스 소프트웨어 종류 Oracle DB2 Sybase SQL Server MySQL 2. 개발 소프트웨어 요구사항 관리도구 목표 시스템의 기능과 제약 조건 등 고객의 요구사항을 수집, 분석, 추적을 쉽게 할 수 있게 지원 종류 JFeature JRequisite OSRMT Trello 설계/모델링 도구 기능을 논리적으로 결정하기 위해 통합 모델링한 언어(UML)지원 Database 설계 지원 종류 ArgoUML DB Designer StarUML 구현 도구 문제 해결방법을 소프트웨어 언어를 통해 구현 및 개발을 지원하는 도구 종류 Eclipse Intelli J Vistual Studio 테스터 도구 구현및 개발된 모듈들에 대하여 요구 사항에 적합하게 구현되어 있는지 테스트를 지원하는 도구 종류 JUnit CppUnit Jmeter SpringTest 형상관리 도구 산출물의 변경 사항을 버전별로 관리하여 목표 시스템의 품질 향상을 지원하는 도구 종류 CSV SVN Git 개발환경 구축 순서 1. 목표시스템의 환경 및 요구사항 분석 제안 요청서, 제안서, 사업 수행 계획서, 요구사항 정의서, 시스템 아키텍처, 애플리케이션 아키텍처 등 분석 및 설계시의 산출물을 분석하여 개발환경 준비 목표시스템의 환경 예시 목표시스템 개발언어 개발인원 및 기간 사양관련 2. 개발언어 설정 기준 적정성 대상 업무의 성격 개발하고자 하는 시스템이나 응용 프로그램의 목적에 적합 효율성 프로그래밍의 효율성이 고려 이식성 일반적인 PC 및 OS에 개발환경이 설치 가능 친밀성 프로그래머가 그 언어를 이해하고 사용할 수 있음 범용성 관거 개발 실적이나 사례가 존재하고, 광범위한 분야에서 사용되고 있어야 함 3. 통합 개발환경 선정 4. 프로그램의 배포 및 라이브러리 관리를 위한 빌드 도구 선정 빌드 도구의 선정 프로젝트 팀원의 빌드 도구의 친밀도와 숙련도에 따라 결정 형상관리 도구를 고려하여 빌드 도구 선정 통합 개발 도구와 호환이 가능한 빌드 도구 선정 5. 개발 인원을 고려한 형상관리 도구를 선정 종류 CVS SVN Git 목표 시스템 환경 등을 고려하여 선정 통합 개발 도구와 호환이 가능한 빌드 도구를 선정 6. 프로젝트 검증에 적합한 테스트 도구를 선정 통합 개발 도구와 호환이 가능하고 널리 사용되는 테스트 자동화 도구를 선정","link":"/2020/05/08/Engineer_Information_Processing/ch15_%EC%84%9C%EB%B2%84%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8%EA%B5%AC%ED%98%84/%EA%B0%9C%EB%B0%9C%ED%99%98%EA%B2%BD%EA%B5%AC%EC%B6%95/%EA%B0%9C%EB%B0%9C%ED%99%98%EA%B2%BD%EA%B5%AC%EC%B6%95/"},{"title":"데이터전환 - 핵심정리","text":"데이터전환 1. 데이터 정제 데이터 정제 항목을 정제 시점에 따라 전환 테스트 전, 중, 최종전환 3단계로 구분하여 데이터 정제 작업을 수행 2. 데이터 품질 분석 데이터 품질 관리는 기관이나 조직 내외부의 정보시스템 및 DB사용자의 기대를 만족시키기 위해 지속적으로 수행하는 데이터 관리 및 개선활동 원천 데이터와 전환된 목적 데이터베이스의 품질 분석 원천 데이터와 전환 데이터의 정합성 검증 항목 3. 오류 데이터 측정 데이터 중 정상 데이터와 오류 데이터를 정량적으로 측정 오류 목록의 내용을 확인하고 오류 해결 방안을 참조하여 원천 데이터의 정제를 요청할 것인지, 아니면 전환 프로그램을 수정할 것인지 데이터 정제 여부를 결정","link":"/2020/05/10/Engineer_Information_Processing/ch14_%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%A0%84%ED%99%98/%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%A0%95%EC%A0%9C/%ED%95%B5%EC%8B%AC%EC%A0%95%EB%A6%AC/"},{"title":"서버프로그램구현 - 서버개발프레임워크","text":"서버프로그램구현 Framework 프레임워크의 개념 사전적으로 뼈대, 골조를 의미하며 소프트웨어에서는 특정 기능을 수행하기 위해 필요한 클래스나 인터페이스 등을 모다운 집합체 프레임워크의 특징 Modularity 모듈화 캡슐화를 통해 모듈화를 강화하고 설계와 구현의 변경에 따른 영향을 최소화하여 소프트웨어의 품질을 향상시킴 Reusability 재사용성 재사용 가능한 모듈들을 제공함으로써 개발자의 생산성을 향상시킴 Extensibility 확장성 프레임워크는 다형성을 통해 인터페이스의 확장이 가능하여 다양한 형태와 기능을 가진 애플리케이션 개발이 가능함 Inversion of Control 제어의 흐름 프레임워크 코드가 전체 애플리케이션의 처리 흐름을 제어하여 특정한 이벤트가 발생할 때 다형성을 통해 애플리케이션의 확장한 메소드를 호출함으로써 제어가 프레임워크로부터 애플리케이션으로 거꾸로 흐르게 함 서버 개발 프레임워크 1. 서버 개발 프레임워크의 개념 서버 프로그램 개발 시 다양한 네트워크 설정, 요청 및 응답처리, 아키텍처 모델 구현등을 손쉽게 처리할 수 있도록 클래스나 인터페이스를 제공하는 소프트웨어 서버 개발 프레임워크에 따라 지원하는 프로그래밍 언어가 제한적이므로 선정할 수 있는 프레임워크도 제한적 서버 개발 프레임워크의 대부분은 모델-뷰-컨트롤러MVC패턴을 기반으로 개발됨 2. 서버 개발 프레임워크의 종류 Spring JAVA를 기반으로 만들어진 프레임워크로, 전자정부 표준 프레임워크의 기반 기술로 사용되고 있음 Node.js JavaScript를 기반으로 만들어진 프레임워크로, 비동기 입,출력 처리와 이벤트 위주의 높은 성능을 갖고 있어 실시간으로 입/출력이 빈번한 애플리케이션 Django Python을 기반으로 만들어진 프레임워크로, 컴포넌트의 재사용과 플러그인화를 강조하여 신속한 개발이 가능하도록 지원 Ruby on Rails Ruby를 기반으로 만들어진 프레임워크로, 테스트를 위한 웹서버를 지원하며 데이터베이스 작업을 단순화, 자동화시켜 개발 코드의 길이가 짧아 신속한 개발이 가능","link":"/2020/05/08/Engineer_Information_Processing/ch15_%EC%84%9C%EB%B2%84%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8%EA%B5%AC%ED%98%84/%EA%B0%9C%EB%B0%9C%ED%99%98%EA%B2%BD%EA%B5%AC%EC%B6%95/%EC%84%9C%EB%B2%84%EA%B0%9C%EB%B0%9C%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC/"},{"title":"서버프로그램구현 - 핵심정리","text":"서버프로그램구현 1. 개발환경 구축 응용소프트웨어 개발에 필요한 하드웨어 및 소프트웨어의 필요 사항을 검토하고, 이에 따라 개발환경에 필요한 준비를 수행 개발 하드웨어 환경 클라이언트 서버 개발 소프트웨어 환경 시스템소프트웨어 개발 소프트웨어 요구사항 관리 도구 설계/모델링 도구 구현 도구 빌드 도구 테스트 도구 형상 관리 도구 2. 서버 개발 프레임워크 서버 프로그램 개발 시 다양한 네트워크 설정, 요청 및 응답처리, 아키텍처 모델 구현등을 손쉽게 처리할 수 있도록 클래스나 인터페이스를 제공하는 소프트웨어 종류 Spring Node.js Django Codeigiter Ruby on Rails","link":"/2020/05/08/Engineer_Information_Processing/ch15_%EC%84%9C%EB%B2%84%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8%EA%B5%AC%ED%98%84/%EA%B0%9C%EB%B0%9C%ED%99%98%EA%B2%BD%EA%B5%AC%EC%B6%95/%ED%95%B5%EC%8B%AC%EC%A0%95%EB%A6%AC/"},{"title":"데이터전환 - 오류데이터측정","text":"데이터전환 정상 데이터와 오류 데이터 정량적 측정 1. 정상 데이터의 건수를 정량적으로 측정 전환 대상 범위의 데이터를 업무 영역별, 테이블별로 세분화하여 정상 데이터의 수량을 정확히 측정하고 기록 2. 오류 데이터의 유형과 건수를 정량적으로 측정 원천 데이터의 정합성 기준을 근거로 업무별로 오류 위치와 유형을 파악하고 그 수량을 정확히 측정하여 기록 3. 원천 데이터 오류 관리 목록 예시 오류 원인 파악 및 정제 여부 결정 1. 발견된 데이터 오류를 분석하고 원인 파악 해결방안 오류의 내용과 원인을 분서갛여 해결 가능한 오류는 향후 처리 방침을 기술하고, 해결 불가한 오류는 고객과 협의한 내용을 기술 심각도 상 더 이상 데이터 이행을 진행할 수 없게 만드는 오류 중 데이터 이행 전반에 영향을 미치는 오류 하 데이터 이행의 흐름에는 영향을 미치지 않는 오류이나 상황에 맞지 않는 용도 및 배치 오류 상태 Open 오류가 보고되었지만 아직 분석되지 않은 상태 Assigned 영향 분석 및 수정을 위해 오류를 개발자에게 할당한 상태 Fixed 개발자가 오류를 수정한 상태 Closed 오류가 수정되었는지 확인하고 재테스트 시 오류가 발견되지 않은 상태 Deferred 오류 우선 순위가 낮게 분류되었기 때문에 오류 수정을 연기한 상태 Classified 보고된 오류가 프로젝트 팀에 의해 오류가 아니라고 판단한 상태 2. 원천 데이터와 전환 프로그램의 정제 필요 여부 결정 파악된 오류 원인을 기반으로 해결방안 협의 무시해야하는 오류가 아닌 경우에는 원천 데이터의 정제를 통해 해결해야할 것인지, 전환 프로그램을 수정할 것인지 결정","link":"/2020/05/10/Engineer_Information_Processing/ch14_%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%A0%84%ED%99%98/%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%A0%95%EC%A0%9C/%EC%98%A4%EB%A5%98%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%B8%A1%EC%A0%95/"},{"title":"서버프로그램구현 - 모델화","text":"서버프로그램구현 모듈화 개념 해결하기 어려운 큰 문제를 작은 단위로 쪼개어 하나씩 해결하는 것처럼, 소프트웨어 개발 작업을 실제로 개발할 수 있는 작은 단위로 나누는 것 모듈화의 장점 분할과 정복의 원리가 적용되어 복잡도 감소 문제를 이해하기 쉽게 만듦 변경하기 쉽고, 변경으로 인한 영향으로 적음 유지보수 용이 프로그램을 효율적으로 관리 오류로 인한 파급효과를 최소화 설계 및 코드 재사용 모듈화 측정 척도 Cohesion 응집도 인터페이스의 요청을 처리함에 있어서 공통 모듈 내의 클래스들 간에 얼마나 유기적으로 협업하여 처리하는 가에 관한 정도 높여야 함 Couplling 결합도 어떤 모듈이 다른 모듈에 의존하는 정도 낮춰야 함 응집도 개념 공통 모듈 내의 클래스들이 외부의 기능을 수행함에 있어서 얼마나 서로 클래스들끼리 내부적으로 연계되어 수행되는지에 대한 정도 응집도의 유형과 품질 기능은 순차적으로 통신해야, 절차적 시간이 논리적이 되고 우연이 낮음 결합도 개념 프로세스를 처리 함에 있어서 각각의 공통 모듈이 서로 연계되어 있는 정도 결합도 유형과 품질 높은 내용은 공통적인 것을 외부로부터 제어한 후 도장찍은 자료이다","link":"/2020/05/09/Engineer_Information_Processing/ch15_%EC%84%9C%EB%B2%84%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8%EA%B5%AC%ED%98%84/%EA%B3%B5%ED%86%B5%EB%AA%A8%EB%93%88%EA%B5%AC%ED%98%84/%EB%AA%A8%EB%93%88%ED%99%94/"},{"title":"서버프로그램구현 - 재사용","text":"서버프로그램구현 공통 모듈의 상세 설계를 기반으로 프로그래밍 언어와 도구를 활용하여 업무 프로세스 및 서비스의 구현에 필요한 공통 모듈을 작성 소프트웨어 측정 지표 중 모듈 간의 결합도는 줄이고 개별 모듈들의 내부 응집도를 높인 공통 모듈을 구현 공통 개발된 공통 모듈의 내부 기능과 제공하는 인터페이스에 대해 테스트할 수 있는 테스트 케이스를 작성하고 단위 테스트를 수행하기 위한 테스트 조건을 명세화 용어사전 Cohesion 응집도 모듈 내부에 존재하는 구성 요소들 사이의 밀접한 정도로, 응집도가 높을수록 구성 요소들이 꼭 필요한 것으로만 모여 있음 Coupling 결합도 모듈과 모듈 사이의 관계에서 관련 정도를 나타내며 모듈 간에는 관련이 적을수록 상호 의존성이 줄어 모듈의 독립성이 높아지고 독립성이 높으면 모듈 간에 영향이 적어 좋은 설계가 됨 공통 모듈 Reuse 재사용의 개념 공통모듈은 정보시스템 구축 시 자주 사용하는 기능들로서 재사용이 가능하게 패키지(클래스, 라이브러리, 컴포넌트, 프레임워크)로 제공하는 독립된 모듈을 의미 재사용은 목표 시스템의 개발 시간 및 비용 절감을 위하여 검증된 기능을 파악하고 재구성하여 시스템에 응용하기 위한 최적화 작업 재사용 범위에 따른 분류 함수와 객체 재사용 함수나 클래스 단위로 구현한 소스코드를 재사용 컴포넌트 재사용 컴포넌트 단위로 재사용하며, 컴포넌트의 인터페이스를 통해 통신 애플리케이션 사용 공통된 기능을 제공하도록 구현된 애플리케이션과의 통신으로 기능을 공유하여 재사용 재사용의 이점 생산성 증가 소프트웨어 품질 향상 프로젝트 문서 공유 새로운 개발 방법론 도입은 어렵게 함","link":"/2020/05/09/Engineer_Information_Processing/ch15_%EC%84%9C%EB%B2%84%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8%EA%B5%AC%ED%98%84/%EA%B3%B5%ED%86%B5%EB%AA%A8%EB%93%88%EA%B5%AC%ED%98%84/%EC%9E%AC%EC%82%AC%EC%9A%A9/"},{"title":"서버프로그램구현 - 핵심정리","text":"서버프로그램구현 1. 재사용 목표 시스템의 개발 시간 및 비용 절감을 위하여 검증된 기능을 파악하고 재구성하여 시스템에 응용하기 위한 최적화 작업 분류 함수와 객체 재사용 컴포넌트 재사용 애플리케이션 재사용 2. 모듈화 스프트웨어 개발 작업을 실제로 개발할 수 있는 작은 단위로 나누는 것 측정 척도 응집도 결합도 관계 응집도는 높게 결합도는 낮게","link":"/2020/05/09/Engineer_Information_Processing/ch15_%EC%84%9C%EB%B2%84%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8%EA%B5%AC%ED%98%84/%EA%B3%B5%ED%86%B5%EB%AA%A8%EB%93%88%EA%B5%AC%ED%98%84/%ED%95%B5%EC%8B%AC%EC%A0%95%EB%A6%AC/"},{"title":"서버프로그램구현 - 배치프로그램","text":"서버프로그램구현 애플리케이션 설계를 기반으로 프로그래밍 언어와 도구를 활용하여 배치 프로그램 구현 기술에 부합하는 배치 프로그램을 구현 목표 시스템을 구성하는 하위 시스템 간의 연동시 안정적이고 안전하게 동작할 수 있는 배치 프로그램을 구현 개발된 배치 프로그램의 테스트를 수행 배치 프로그램의 개념 사용자의 상호 작용 없이 일련의 작업들을 작업 단위로 묶어 정기적으로 반복 수행하거나 정해진 규칙에 따라 일괄처리하는 것 배치 프로그램의 필수 요소 대용량 데이터 대용량의 데이터를 처리할 수 있어야 함 자동화 심각한 오류 상황 외에는 사용자의 개입 없이 동작해야 함 견고함 유효하지 않은 데이터의 경우도 처리해서 비정상적인 동작 중단이 발생하지 않아야 함 안정성 어떤 문제가 생겼는지, 언제 발생했는지 등을 추적할 수 있어야 함 성능 주어진 시간 내에 처리를 완료할 수 있어야 하고, 동시에 동작하고 있는 다른 애플리케이션을 방해하지 말아야 함 배치 스케줄러의 개념 일괄처리(Batch Processing)를 위해 주기적으로 발생하거나 반복적으로 발생하는 작업을 지원하는 도구 특정 업무를 원하는 시간에 처리할 수 있도록 지원하는 특성 때문에 잡 스케줄러 라고 함 종류 Spring Batch Quartz 배치 스케줄러의 종류 Spring Batch 스프링 배치 Spring Source사와 Accenture사가 2007년에 공동으로 개발한 오픈소스 프레임워크 아키텍처 Run Tier 배치의 실행을 담당 Job Tier XML로 기술된 Job내의 각 Step들을 순차적으로 실행 Application Tier Job을 수행하는데 필요한 Item Reader, Item Writer, Item Processor 등의 컴포넌트로 구성 파일 혹은 데이터베이스로부터 읽고 쓰는 기능을 수행 Data Tier Database, File, Queue 등 물리적 데이터소스와의 결합이 이루어지는 영역 핵심 컴포넌트 Job Repository Job Execution 관련 메타데이터를 저장하는 기반 컴포넌트 Job Launcher Job Execution 실행하는 기반 컴포넌트 JPA; Java Persistence API 페이징 기능 제공 Job 배치 처리를 의미하는 애플리케이션 컴포넌트 Step Job의 각 단계를 의미하며, Job은 일련의 연속된 Step으로 구성 Item Data Source로부터 읽거나 저장하는 각 레코드 Chunk 특정크기를 갖는 아이템 목록을 의미 Item Reader 데이터소스로부터 아이템을 읽어 들이는 컴포넌트 Item Processor Item Reader로 읽어 들인 아이템을 Item Writer를 사용해 저장하기 전에 처리하는 컴포넌트 Item Writer Item Chunk를 데이터 소스에 저장하는 컴포넌트 핵심기능 스프링 프레임워크 기반 DI; Dependency Injection, AOP; Aspect Oriented Programming 및 다양한 엔터프라이즈 지원 기능 사용 자체 제공 컴포넌트 배치처리(데이터베이스나 파일로부터 데이터를 읽거나 쓰는 등) 시 공통적으로 필요한 컴포넌트를 제공 견고함과 안정성 선언적 생략과 처리 실패 후 재시도 설정을 제공 Quartz 스케줄러 Spring Framework에 플러그인되어 수행하는 Job과 실행스케줄을 정의하는 Trigger를 분리하여 유연성을 제공하는 오픈소스 스케줄러 구성요소 Scheduler Quartz 실행환경을 관리하는 핵심개체 Job 사용자가 수행할 작업을 정의하는 인터페이스로서 Trigger 개체를 이용하여 스케줄 할 수 있음 JobDetail 작업명과 작업 그룹과 같은 수행할 Job에 대한 상세 정보를 정의하는 개체 Trigger 정의한 Job 개체의 실행 스케줄을 정의하는 개체로서 Scheduler 개체에게 Job 수행 지점을 알려주는 개체 유닉스의 크론 명령어와 유사한 오픈소스 배치 스케줄러 배치 프로그램 구현 1. 애플리케이션 설계를 기반으로 배치 프로그램 확인 프로그램 관리 대장을 확인 배치 설계서를 확인 프로그램 관리 대장의 ID와 일치하는 배치 설계를 확인 2. 애플리케이션 설계를 기반으로 배치 프로그램 구현 배치 프로그램을 구현하기 위한 SQL을 작성 배치 프로그램을 구현하기 위한 I/O 오브젝트(DTO; Data Transfer Object, VO; Value Object)를 정의 배치 프로그램을 구현하기 위한 데이터 접근 오브젝트(DAO; Data Access Object) 작성 배치 프로그램을 구현하기 위한 스케줄러 클래스를 작성 배치 설계서는 작성하지 않음","link":"/2020/05/10/Engineer_Information_Processing/ch15_%EC%84%9C%EB%B2%84%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8%EA%B5%AC%ED%98%84/%EB%B0%B0%EC%B9%98%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8%EA%B5%AC%ED%98%84/%EB%B0%B0%EC%B9%98%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8/"},{"title":"서버프로그램구현 - 핵심정리","text":"서버프로그램구현 1. 배치 프로그램 사용자의 상호 작용 없이 일련의 작업들을 작업 단위로 묶어 정기적으로 반복 수행하거나 정해진 규칙에 따라 일괄처리하는 것 일괄처리(Batch Processing)를 위해 주기적으로 발생하거나 반복적으로 발생하는 작업을 지원하는 도구 종류 Spring Batch Quartz","link":"/2020/05/10/Engineer_Information_Processing/ch15_%EC%84%9C%EB%B2%84%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8%EA%B5%AC%ED%98%84/%EB%B0%B0%EC%B9%98%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8%EA%B5%AC%ED%98%84/%ED%95%B5%EC%8B%AC%EA%B8%B0%EB%8A%A5/"},{"title":"서버프로그램구현 - API","text":"서버프로그램구현 API; Application Programming Interface 개념 운영체제나 프로그래밍 언어 등에 있는 라이브러리를 이용할 수 있도록 규칙 등을 정해 놓은 인터페이스 프로그래밍 언어에서 특정한 작업을 수행하기 위해 사용하거나 운영체제의 파일 제어, 화상 처리, 문자 제어 등의 기능을 활용하기 위해 사용 개발에 필요한 여러 도구를 제공하기 때문에 이를 이용하면 원하는 기능을 쉽고 효율적으로 구현 가능 종류 Windows API 단일 유닉스 규격 Java API 웹 API Open API API 종류 1. Windows API 마이크로소프트 윈도우 운영체제에서 사용하는 API C/C++ 프로그램에서 직접 운영체제와 상호 작용할 수 있도록 만들어졌으며, 그 보다 낮은 수준의 제어는 Ntdll.dll을 사용 윈도우 API 서비스 기본 서비스 고급 서비스 그래픽장치 인터페이스 사용자 인터페이스 공통 대화 상자 라이브러리 공통 컨트롤 라이브러리 윈도 셀 네트워크 서비스 웹 2. SUS; Single UNIX Specification 단일 유닉스 규격 유닉스를 사용하기 위해 지켜져야 하는 표준 규격의 총칭 SUS 는 전기전자기술자협회와 오픈 그룹의 표준화 작업 결과물에 바탕을 두고 있으며, 오스틴 그룹이 개발 및 유지 관리를 담당 3. Java API Java를 사용하기 쉽게 구현할 수 있도록 한 클래스 라이브러리의 집합 Java 언어를 사용하여 사용자의 부담을 최소화하는 반면에 입출력, 화면 구성, 이미지, 네트워크와 같이 복잡하지만 필요한 클래스들을 미리 구현하여 사용자가 쉽게 구현하도록 하는 API 4. 웹 API 웹 어플리케이션 개발에서 다른 서비스에 요청을 보내고 응답을 받기 위해 정의된 명세 블로그 API는 블로그에 접속하지 않고도 워드 아래한글에서 글을 작성하여 올릴 수 있음 우체국의 우체국 API, 구글과 네이버 지도 API등 다양한 API가 서비스 되고 있음","link":"/2020/05/10/Engineer_Information_Processing/ch15_%EC%84%9C%EB%B2%84%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8%EA%B5%AC%ED%98%84/%EC%84%9C%EB%B2%84%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8%EA%B5%AC%ED%98%84/API/"},{"title":"서버프로그램구현 - 보안취약성식별","text":"서버프로그램구현 업무 프로세스 맵과 세부 업무 프로세스를 확인 세부 업무 프로세스를 기반으로 프로그래밍 언어와 도구를 활용하여 서비스의 구현에 필요한 업무 프로그램 구현 개발하고자 하는 목표 시스템의 잠재적 보안 취약성이 제거될 수 있도록 서버 프로그램을 구현 개발된 업무 프로그램의 내부 기능과 제공하는 인터페이스에 대해 테스트 수행 용어사전 API; Application Programming Interface 응용 프로그램 개발 시 운영체제나 프로그래밍 언어 등에 있는 라이브러리를 이용할 수 있도록 규칙을 정의해 놓은 인터페이스 소프트웨어 개발 보안의 개념 개발자의 실수, 논리적 오류 등으로 인해 발생할 수 있는 보안 취약점을 최소화하고, 사이버보안 위협에 대응할 수 있는 안전한 소프트웨어 개발하기 위한 일련의 보안 활동 데이터의 Confidentiality 기밀성, Integrity 무결성, Availability 가용성 유지를 목표 소프트웨어 개발 보안 가이드 구성 입력 데이터 검증 및 표현 프로그램 입력 값에 대한 검증 누락 또는 부적절한 검증, 데이터의 잘못 된 형식 지정으로 인해 발생할 수 있는 보안 약점 SQL 삽입 자원 삽입 크로스 사이트 스크립트 등 보안 기능 보안 기능(인증, 접근제어, 기밀성, 암호화, 권한 관리)을 적절하지 않게 구현 시 발생할 수 있는 보안 약점 부적절한 인가 중요 정보 펭문 저장 등 시간 및 상태 동시 또는 거의 동시 수행을 지원하는 병렬 시스템, 하나 이상의 프로세스가 동작하는 환경에서 시간 및 상태를 부적절하게 관리하여 발생할 수 있는 보안 약점 경쟁 조건 제어문을 사용하지 않은 재귀 함수 등 에러 처리 에러를 처리하지 않거나, 불충분하게 처리하여 에러 정보에 중요 정보가 포함될 때 발생할 수 있는 보안 약점 취약한 패스워드 요구 조건 오류 메시지를 통한 정보 노출 등 코드 오류 타입 변환 오류, 자원의 부적절한 반환 등과 같이 개발자가 범할 수 있는 코딩 오류로 인해 유발되는 보안 약점 널 포인터 역참조 부적절한 자원 해제 등 캡슐화 중요한 데이터 또는 기능성을 불충분하게 캡슐화하였을 때 인가되지 않는 사용자에게 데이터 누출이 가능해지는 보안 약점 제거되지 않고 남은 디버그 코드 시스템 데이터 정보 노출 등 API 오용 의도된 사용에 반하는 방법으로 API를 사용하거나, 보안에 취약한 API를 사용하여 발생할 수 있는 보안 약점 DNS Lookup에 의존한 보안 결정 Null 매개 변수 미조사 등","link":"/2020/05/09/Engineer_Information_Processing/ch15_%EC%84%9C%EB%B2%84%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8%EA%B5%AC%ED%98%84/%EC%84%9C%EB%B2%84%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8%EA%B5%AC%ED%98%84/%EB%B3%B4%EC%95%88%EC%B7%A8%EC%95%BD%EC%84%B1%EC%8B%9D%EB%B3%84/"},{"title":"기본개발환경구축 - DB서버","text":"기본개발환경구축 DB서버 정의 사용자, 다른 어플리케이션, 데이터베이스와 상호작용하여 데이터를 저장하고 분석하기 위한 컴퓨터 소프트웨어 주요기능 데이터베이스 생성 조회 변경 DB서버 종류 및 특징 대규모 데이터의 안정적 처리 Oracle 저작자 : Oracle 상용 DB2 저작자 : IBM 상용 중소 규모 데이터의 안정적 처리 Microsoft SQL Server 저작자 : Microsoft 상용 오픈소스 MySQL 저작자 : MySQLAB 상용 또는 GPL 오픈소스 RDBMS Mongo DB 저작자 : MongoDB Inc GNU AGPL v3.0 NoSQL 데이터베이스 Redis 저작자 : Salvatore Sanfilippo BSD 메모리 키-값 데이터베이스 임베디드 데이터베이스 SQLite 저작자 : D.Richard Hipp Public Domain Query Caching 기능 DB서버 고려사항 가용성 장기간 시스템을 운영할 때 장애 발생 가능성 DBMS의 버그 등으로 인한 패치 설치를 위한 재가동 백업 및 복구 편의성 DBMS 이중화 및 복제 지원 성능 대규모 데이터 처리 기능 대량 거래 처리 기능 다양한 튜닝 옵션 지원 비용 기반 최적화 지원 및 설정의 최소화 기술 지원 공급 벤더들의 안정적인 기술 지원 다수의 사용자들 간의 정보 공유 오픈 소스 여부 상호 호환성 설치 가능한 운영체제 종류 다양한 운영체제에 지원되는 JDBC, ODBC 구축 비용 라이선스 정책 및 비용 유지 및 관리 비용 총 소유 비용 : TCO DB구성의 장점 데이터 중복의 최소화 여러 사용자에 의한 데이터 공유 데이터 내용의 일관성 유지","link":"/2020/05/07/Engineer_Information_Processing/ch17_%EC%9D%91%EC%9A%A9SW%EA%B8%B0%EC%B4%88%EA%B8%B0%EC%88%A0%ED%99%9C%EC%9A%A9/%EA%B8%B0%EB%B3%B8%EA%B0%9C%EB%B0%9C%ED%99%98%EA%B2%BD%EA%B5%AC%EC%B6%95/DB%EC%84%9C%EB%B2%84/"},{"title":"서버프로그램구현 - 핵심정리","text":"서버프로그램구현 1. 보안 취약성 식별 개발자의 실수, 논리적 오류 등으로 인해 발생할 수 있는 보안 취약점을 최소화하고, 사이버보안 위협에 대응할 수 있는 안전한 소프트웨어 개발하기 위한 일련의 보안 활동 보안 점검 항목 입력 데이터 검증 및 표현 보안 기능 시간 및 상태 에러 처리 코드 오류 캡슐화 API 오용 2. API 운영체제나 프로그래밍 언어 등에 있는 라이브러리를 이용할 수 있도록 규칙 등을 정해 놓은 인터페이스 종류 Windows API 단일 유닉스 규격(SUS) Java API 웹 API","link":"/2020/05/10/Engineer_Information_Processing/ch15_%EC%84%9C%EB%B2%84%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8%EA%B5%AC%ED%98%84/%EC%84%9C%EB%B2%84%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8%EA%B5%AC%ED%98%84/%ED%95%B5%EC%8B%AC%EC%A0%95%EB%A6%AC/"},{"title":"기본개발환경구축 - 웹서버","text":"기본개발환경구축 웹 서버, DB 서버등 응용개발에 필요한 기반 서버를 설치하고 운용 패키지 개발 방식의 개념과 장단점을 이해하고 구축 및 운영 절차를 이해 용어사전 Package 패키지 개발 여러 성공사례의 노하우를 기반으로 개발된 제품을 이용하여 시스템을 구축하는 방식 웹서버 정적(Static)과 동적(Dynamic) 웹 페이지 Static Pages Web Server는 파일 경로 이름을 받아 경로와 일치하는 File Contents를 반환하며 항상 동일한 페이지를 반환 image, html, css, javascript 파일 등 웹서버 저장 파일 Dynamic Pages 인자의 내용에 맞게 동적인 Contents를 반환 Client의 request를 해석, 데이터를 가공한 페이지 response Web Server 웹 서버 개념 하드웨어 : Web Server가 설치되어 있는 컴퓨터 소프트웨어 : 웹 브라우저 클라이언트로부터 HTTP request를 받아 정적인 contents를 제공하는 프로그램 기능 HTTP 프로토콜을 기반으로 하여 클라이언트의 요청을 서비스 WAS를 거치지 않음 -&gt; 저장되어 있는 정적 contents를 제공 WAS를 거침 -&gt; 동적인 contents를 제공을 위해 ASP, JSP, PHP등 서버 사이트 스크립트 언어가 request를 WAS에 전달하고, 처리한 결과를 Client에게 Response 주요 제품 Apache Nginx MS-IIS Google-GWS WAS; Web Application Server 서버 개념 DB 조회나 다양한 로직 처리를 요구하는 동적인 contents를 제공하기 위한 Application Server HTTP를 통해 어플리케이션을 수행해주는 미들웨어 WAS = Web Server + Web Container 기능 ASP, JSP, PHP, Python 등 서버 사이드 스크립트 언어 활용 프로그램 실행 환경과 DB 접속 기능 다수의 트랜잭션 관리 기능 다양한 로직 수행 주요 제품 Tomcat Undertow JEUS Weblogic Websphere 스크립트 언어 종류 ASP; Active Server Page IIS 서버 측에서 동적으로 수행하는 페이지를 만들기 위해 마이크로소프트에서 개발 Window 운영체제에서만 실행 가능한 프로래밍 언어 JSP; Java Server Page JAVA로 만들어진 서버용 스크립트 언어 Window, Linux 등 다양한 운영체제에서 사용 가능 PHP; Professinal Hypertext Preprocessor 서버용 스크립트 언어 Window, Linux, Unix 운영체제에서 사용 가능 배우기 쉬움 Python 객체지향 기능을 지원하는 대화형 인터프리터 언어로 플랫폼이 독립적이고 문법이 간단","link":"/2020/05/07/Engineer_Information_Processing/ch17_%EC%9D%91%EC%9A%A9SW%EA%B8%B0%EC%B4%88%EA%B8%B0%EC%88%A0%ED%99%9C%EC%9A%A9/%EA%B8%B0%EB%B3%B8%EA%B0%9C%EB%B0%9C%ED%99%98%EA%B2%BD%EA%B5%AC%EC%B6%95/%EC%9B%B9%EC%84%9C%EB%B2%84/"},{"title":"기본개발환경구축 - 핵심정리","text":"기본개발환경구축 1. 웹서버 웹 브라우저 클라이언트로부터 HTTP request를 받아 HTML과 같은 정적인 contents를 제공하는 프로그램과 해당 애플리케이션 서버가 설치된 컴퓨터 종류 Apache Nginx IIS GWS WAS 서버는 DB조회나 다양한 로직 처리를 요구하는 동적인 contents를 제공하기 위한 Application Server 종류 Tomcat Undertow JEUS Weblogic Websphere 2. DB서버 사용자, 다른 어플리케이션, 데이터베이스와 상호작용하여 데이터를 저장하고 분석하기 위한 컴퓨터 소프트웨어 종류 Oracle DB2 Microsoft SQL Server MySQL MongoDB DB서버 고려사항 가용성 성능 기술지원 상호호환성 구축비용 3. 패키지 패키지 방식 개발은 여러 성공사례 노하우를 기반으로 만들어진 개발된 제품을 이용하여 시스템을 구축하는 방식 장점 국제 및 산업계 표준으로 장착된 비즈니스 프로세스 적용 품질이 검증된 안정적인 시스템 구축 가능 개발 기간의 단축으로 비용절감 효과 단점 사용자 요구사항에 대한 대처가 쉽지 않음 사용자의 프로세스 개선의 저항 발생","link":"/2020/05/07/Engineer_Information_Processing/ch17_%EC%9D%91%EC%9A%A9SW%EA%B8%B0%EC%B4%88%EA%B8%B0%EC%88%A0%ED%99%9C%EC%9A%A9/%EA%B8%B0%EB%B3%B8%EA%B0%9C%EB%B0%9C%ED%99%98%EA%B2%BD%EA%B5%AC%EC%B6%95/%ED%95%B5%EC%8B%AC%EC%A0%95%EB%A6%AC/"},{"title":"기본개발환경구축 - 패키지","text":"기본개발환경구축 Package 패키지의 개녕 패키지 방식 개발은 여러 성공사례 노하우를 기반으로 만들어진 개발된 제품을 이용하여 시스템을 구축하는 방식 사용자의 기능 요구사항을 70%이상 충족시키는 패키지SW가 있을 경우 패키지 SW방식이 적합 현존 시스템과 상호 연동 및 연계를 고려해야 함 패키지를 통한 응용시스템 개발은 패키지 커스터마이징 방법론에 따라 진행 패키지 개발의 장점 기본적으로 필요한 기능이 사전에 모두 제공되며 국제 및 산업계 표준으로 장착된 비즈니스 프로세스 적용이 가능 품질이 검증된 우수한 패키지 SW의 사용으로 안정적인 시스템 구축 전문업체의 지속적인 업그레이드로 최신의 제품과 기능을 사용 개발 기간의 단축으로 비용절감 효과 패키지SW 개발업체 관리가 용이 패키지 개발의 단점 요구사항을 패키지SW가 모두 수용하지 않기 때문에 사용자 요구사항에 대한 대처가 쉽지 않음 사용자의 업무 프로세스를 패키지SW의 업무프로세스에 맞춰야 할 경우 프로세스 개선의 저항발생으로 이어질 가능성 존재 고객 요구사항이 까다롭거나 특수조건일 경우 &quot;Buy &amp; Build&quot;형식으로 구축할 수 있음 구축 및 운영 절차 1. 패키지 방식의 구축 절차 요구사항에 맞춰 커스터마이징 수행 개별단위별 단계쩍 개발 방법 적용 고객의 검수와 공식적 통합테스트 수행 매뉴얼 작성 및 패키지 전개계획 수립 2. 패키지 방식의 운영 절차 패키지를 운영 환경에 전개 사용자 테스트를 준비/시정요구사항 조치 유지보수 운영 매뉴얼 작성 프로젝트 종료 위한 개발완료보고서 작성","link":"/2020/05/07/Engineer_Information_Processing/ch17_%EC%9D%91%EC%9A%A9SW%EA%B8%B0%EC%B4%88%EA%B8%B0%EC%88%A0%ED%99%9C%EC%9A%A9/%EA%B8%B0%EB%B3%B8%EA%B0%9C%EB%B0%9C%ED%99%98%EA%B2%BD%EA%B5%AC%EC%B6%95/%ED%8C%A8%ED%82%A4%EC%A7%80/"},{"title":"응용SW기초기술활용 - IP","text":"응용SW기초기술활용 IP; Internet Protocol 의 개념 OSI 7 계층의 네트워크 계층에서 호소트의 주소지정과 패킷분할 및 조립기능 담당 데이터그램을 기반으로 비연결형 서비스 제공 비연결형통신 송수신 측간에 논리적 연결 없이 데이터를 독립적으로 전송하는 방식 IP 헤더의 길이는 최소 20Byte ~ 60Byte IP 헤더 포함 정보 Version Header Length Total Packet Length Header Checksum Source IP Address Destination IP 주소 IPv4 와 IPv6 주소 비교 Subnetting 서브네팅 할당된 네트워크 주소를 다시 여러 개의 작은 네트워크로 나누어 사용 IPv4기준으로 4Byte 주소 중 네트워크 주소와 호스트 주소를 구분하기 위한 비트를 Subment Maks 서브넷 마스크라고 함 Domain Name 도메인 네임 숫자로 된 IP주소를 사람이 이해하기 쉬운 문자 형태로 표현 한 것 호스트 컴퓨터이름.소속기관이름.소속기관종류.소속국가명 순으로 구성되며 왼쪽에서 오른쪽으로 갈수록 상위 도메인 문자로 된 도메인 네임을 IP주소로 변환하는 역할을 담당하는 시스템은 DNS; Domain Name System 서버","link":"/2020/05/05/Engineer_Information_Processing/ch17_%EC%9D%91%EC%9A%A9SW%EA%B8%B0%EC%B4%88%EA%B8%B0%EC%88%A0%ED%99%9C%EC%9A%A9/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC%EA%B8%B0%EC%B4%88%ED%99%9C%EC%9A%A9/IP/"},{"title":"응용SW기초기술활용 - TCP/UDP","text":"응용SW기초기술활용 TCP; Transmission Control Protocol 의 개념 OSI 7계층의 전송계층에서 CRC체크와 재전송 기능을 통해 신뢰성있는 연결형 서비스 제공 연결형 서비스 송수신 측간을 논리적으로 연결한 후 데이터를 전송하는 방식 Flow Control 기능을 수행하여 단계별 데이터 전송 상황을 체크 논리적인 1:1 가상 회선을 지원하여 해당 경로로만 데이터 전달 기능 패킷의 다중화 순서 제어 오류 제어 흐름 제어 대표서비스 FTP Telnet Http SMTP POP IMAP TCP 헤더 정보 Souce/Destination Port Sequence Number Acknowledge Number Cheksum UDP; User Datagram Protocol의 개념 OSI 7계층의 전송계층에서 데이터 전송 전에 연결을 설정하지 않는 비연결형 서비스를 제공 비신뢰성 데이터 전송 하나의 송신 정보를 다수의 인원이 수신해야할 경우 UDP 사용 대표 서비스 SNMP DNS TFTP NFS NETBIOS 인터넷 게임 UDP 헤더 포함 정보 Source Destination Port Length Cheksum TCP와 UDP 차이점 TCP 데이터 전송 전 연결설정 1:1 전송 단계별 데이터 전송 신뢰성있는 데이터 전송 등기 우편물 UDP 데이터 전송 전 연결 미설정 1:다 전송 데이터 전송 비 신뢰성 데이터 전송 소포 우편물","link":"/2020/05/05/Engineer_Information_Processing/ch17_%EC%9D%91%EC%9A%A9SW%EA%B8%B0%EC%B4%88%EA%B8%B0%EC%88%A0%ED%99%9C%EC%9A%A9/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC%EA%B8%B0%EC%B4%88%ED%99%9C%EC%9A%A9/TCP_UDP/"},{"title":"응용SW기초기술활용 - 인터넷 구성의 개념","text":"응용SW기초기술활용 네트웤크 계층 구조에서 각 층의 역할을 이해 응용의 특성에 따라 TCP와 UDP를 구별하여 적용 패킷 스위칭 시스템 이해하고, 다양한 라우팅 알고리즘과 IP 프로토콜을 설명 용어사전 OSI 7 Layer 국제표준화 기구인 ISO(International Standard Organization)에서 다른 시스템간 통신을 위해 네트워크 구조를 제시한 기본 모델로 7계층 구조 Protocol 프로토콜 서로 다른 기기들 간의 데이터 교환을 원활하게 수행할 수 있도록 표준화시켜 놓은 통신 규약 인터넷의 개념 TCP/IP 프로토콜을 기반으로 전세계 수 많은 네트워크들이 연결된 광범위한 컴퓨터 통신망 1969년 미 국방성의 ARPANET에서 시작 유닉스 운영체제를 기반으로 함 인터넷에 연결된 모든 컴퓨터는 고유한 IP주소를 가짐 동시에 여러 사람이 인터넷을 이용하여 데이터 송수신 할 수 있도록 패킷 단위로 데이터를 분할하여 전송하는 패킷교환 방식을 사용 컴퓨터 또는 네트워크로 서로 연결하기 위해 게이트 웨이, 라우터, 브리지, 허브 등 네트워크 장비가 필요 증폭기는 아날로그 신호 증폭을 위한 장비로 인터-네트워킹과는 무관 네트워크 관련 장비 1. Gateway 게이트웨이 LAN에서 서로 다른 프로토콜의 네트워크에 데이터를 보내거나 다른 네트워크로 부터 데이터를 받아들이는 출입구 역할 수행 역할 데이터 형식 변환 주소 변환 프로토콜 변환 2. Router 라우터 서로 다른 프로토콜의 LAN이나 LAN과 WAN의 연결 기능에 데이터 전송의 최적의 경로를 선택할 수 있는 기능 추가 3. Repeater 리피터 전송되는 신호가 전송 선로의 특성 및 외부 충격 등 요인으로 원래의 형태와 다르게 왜곡되거나 약해질 경우 원래의 신호 형태로 재생하여 다시 전송하는 역할 수행 4. Hub 허브 사무실이나 가까운 거리의 컴퓨터들을 연결하는 장치로 각 회선을 통합적으로 관리하며 신호 증폭 기능의 리피터 역할도 포함 종류 더미 허브 LAN이 보유한 대역폭을 연결된 컴퓨터 수 만큼 나누어 제공 100MB 대역폭 5대 연결시 20MB 대역폭으로 속도 낮아짐 스위칭 허브 네트워크 상에 흐르는 데이터의 유무 및 흐름을 제어하며, 연결된 컴퓨터 수에 상관없이 LAN의 최대 대역폭을 사용할 수 있도록 신호 증폭 기능을 제공하는 허브 5. NIC; Network Interface Card 랜 카드 컴퓨터가 네트워크에 연결되도록 하는 접촉 점 역할 장치로, 이더넷 카드 혹은 네트워크 어댑터라고 함 6. Bridge 브리지 동일한 프로토콜을 사용하는 LAN과 LAN을 연결하거나 LAN 안에서 컴퓨터 그룹을 연결하는 기능을 수행 네트워크를 분산적으로 구성하여 보안성을 높일 수 있음 7. Switch 스위치 브리지와 같이 LAN과 LAN을 연결하여 훨씬 더 큰 LAN을 만드는 장치 하드웨어를 기반으로 처리하므로 전송 속도가 빠름 포트마다 각기 다른 전송 속도를 지원하도록 제어할 수 있고 수십에서 수백 개의 포트 제공 네트워크 규모에 따른 분류 LAN; Local Area Network 근거리 통신망 MAN; Metropolitan Area Network 대도시 통신망 WAN; Wide Area Network 광대역 통신망","link":"/2020/05/05/Engineer_Information_Processing/ch17_%EC%9D%91%EC%9A%A9SW%EA%B8%B0%EC%B4%88%EA%B8%B0%EC%88%A0%ED%99%9C%EC%9A%A9/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC%EA%B8%B0%EC%B4%88%ED%99%9C%EC%9A%A9/%EC%9D%B8%ED%84%B0%EB%84%B7%EA%B5%AC%EC%84%B1%EC%9D%98%EA%B0%9C%EB%85%90/"},{"title":"응용SW기초기술활용 - 네트워크 7계층","text":"응용SW기초기술활용 OSI; Open System Interconnection 참조 모델 개요 국제 표준화 기구인 ISO에서 다른 시스템간 통신을 위해 네트워크 구조를 제시한 기본 모델 데이터 통신 시 필요한 장비 및 처리 방법 등을 7단계로 표준화 OSI 참조 모델의 목적 서로 다른 시스템 간을 상호 접속하기 위한 개념 규정 OSI 규격을 개발하기 위한 범위 정립 관련 규정의 적합성을 조절하기 위한 공통적인 기반 제공 OSI 참조 모델의 계층별 데이터 단위 프로토콜 데이터 단위 PDU; Protocol Data Unit 7계층 응용 계층 : 메시지(Message) 6계층 표현 계층 : 메시지(Message) 5계층 세션 계층 : 메시지(Message) 4계층 전송 계층 : 세그먼트(Segment) 3계층 네트워크 계층 : 패킷(Packet) 2계층 데이터링크 계층 : 프레임(Frame) 1계층 물리 계층 : 비트(bit) OSI 7 Layer 계층별 기능 1. Physical Layer 물리 계층 전송에 필요한 두 장치 간의 실제 접속과 절단 등 기계적, 전기적, 기능적, 절차적 특성에 대한 규칙을 정의 물리적 전송매체와 전송 신호방식을 정의 관련 장비 허브 리피터 2. Data Link Layer 데이터링크 계층 두 개의 개발 시스템들 간 속도 차이를 해결하기 위한 흐름 제어 프레임의 시작과 끝을 구분하기 위한 프레임의 동기화 오류의 검출과 회복을 위한 오류 제어 프레임의 순서적 전송을 위한 순서 제어 관련 장비 랜카드 브리지 스위치 3. Network Layer 네트워크 계층 개방 시스템들 간의 네트워크 연결을 설정, 유지, 해제하는 기능과 경로 설정, 데이터 교화 및 중계, 트래픽 제어, 패킷 정보 전송 관련 장비 라우터 4. Transport Layer 전송 계층 논리적 안정과 균일한 데이터 전송 서비스를 제공함으로써 종단시스템간에 투명한 데이터 전송을 가능하게 함 종단 시스템간 전송 연결설정, 데이터 전송, 연결해제 기능과 오류 제어, 흐름제어 수행 TCP, UDP의 표준 관련 장비 게이트웨이 5. Session Layer 세션 계층 송/수신 측 간의 관련성을 유지하고 대화 제어 담당 6. Presentation Layer 표현 계층 응용계층으로부터 받은 데이터를 세션 계층에 보내기 전에 통신에 적당한 형태로 변환하고, 세션 계층에서 받은 데이터는 응용 계층에 맞게 변환하는 기능 코드변환, 데이터 암호화, 데이터 압축, 구문 검색, 정보형식 변환 7. Application Layer 응용 계층 응용 프로세스와 직접 관계하여 일반적인 응용 서비스를 수행 정보 교환, 파일 전송, 가상 터미널","link":"/2020/05/05/Engineer_Information_Processing/ch17_%EC%9D%91%EC%9A%A9SW%EA%B8%B0%EC%B4%88%EA%B8%B0%EC%88%A0%ED%99%9C%EC%9A%A9/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC%EA%B8%B0%EC%B4%88%ED%99%9C%EC%9A%A9/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC7%EA%B3%84%EC%B8%B5/"},{"title":"응용SW기초기술활용 - 핵심정리","text":"응용SW기초기술활용 1. 인터넷 구성의 개념 TCP/IP 프로토콜을 기반으로 전세계 수 많은 네트워크들이 연결된 광범위한 컴퓨터 통신망 장비 종류 게이트웨이 라우터 리피터 허브 랜 카드 브리지 스위치 2. 네트워크 7계층 국제 표준화 기구인 ISO에서 다른 시스템간 통신을 위해 네트워크 구조를 제시한 기본 모델 3. 네트워크 프로토콜 프로토콜은 서로 다른 기기들 간의 데이터 교환을 원활하게 수행할 수 있도록 표준화 시켜 놓은 통신 규약 TCP/IP 4계층 네트워크 액세스 인터넷 전송 응용 프로토콜의 기본 요소 구문 의미 시간 라우팅 프로토콜 RIP IGRP OSPF BGP 4. IP OSI 7 계층의 네트워크 계층에서 호소트의 주소지정과 패킷분할 및 조립기능 담당 5. TCP/UDP OSI 7계층의 전송계층에서 CRC체크와 재전송 기능을 통해 신뢰성있는 연결형 서비스 제공 TCP 대표 서비스 FTP Telnet Http SMTP POP IMAP UDP는 비연결성이고 신뢰성 없는 데이터 전송 UDP는 대표 서비스 SNMP DNS TFTP NFS NETBIOS 인터넷 게임","link":"/2020/05/05/Engineer_Information_Processing/ch17_%EC%9D%91%EC%9A%A9SW%EA%B8%B0%EC%B4%88%EA%B8%B0%EC%88%A0%ED%99%9C%EC%9A%A9/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC%EA%B8%B0%EC%B4%88%ED%99%9C%EC%9A%A9/%ED%95%B5%EC%8B%AC%EC%A0%95%EB%A6%AC/"},{"title":"응용SW기초기술활용 - Shell Script","text":"응용SW기초기술활용 운영체제 기본 명령어 개요 Shell은 사용자의 명령어를 수행하는 명령어 해석기 운영체제를 제어하는 방법 GUI Graphic User Interface 마우스로 아이콘이나 메뉴를 선택하여 작업 CLI Command Line Interface 키보드로 명령어를 직접 입력하여 작업 윈도우 CLI 기본 명령어 명령어 기능 ATTRIP 파일의 속성을 변경 CD 디렉토리의 위치 변경 CHKDSK 디스크 상태 점검 CLS 화면의 내용을 지움 COPY 파일 복사 DEL 파일 삭제 DIR 파일의 목록 표시 FIND 파일 검색 FORMAT 디스크 표면을 트랙과 섹터로 초기화 MD 디렉토리 생성 MOVE 파일 이동 REN 파일 이름 변경 TYPE 파일의 내용 표시 UNIX와 LINUX 기본 명령어 명령어 기능 cat 파일 내용을 화면에 표시 chdir 디렉토리 위치 변경 chmod 파일의 사용 허가 지정 chown 소유자 변경 cp 파일 복사 exec 새로운 프로세스 수행 find 파일 검색 fork 새로운 프로세스를 생성 fsck 파일시스템을 검사하고 보수 getpid 자신의 프로세스 아이디를 얻음 ls 현재 디렉토리 내의 파일 목록을 표시 rm 파일 삭제 wait fork 후 exec에 의해 실행되는 프로세스의 상위 프로세스가 하위 프로세스 종료 등의 event를 기다림","link":"/2020/05/05/Engineer_Information_Processing/ch17_%EC%9D%91%EC%9A%A9SW%EA%B8%B0%EC%B4%88%EA%B8%B0%EC%88%A0%ED%99%9C%EC%9A%A9/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EA%B8%B0%EC%B4%88%ED%99%9C%EC%9A%A9/ShellScript/"},{"title":"응용SW기초기술활용 - 메모리관리","text":"응용SW기초기술활용 메모리 관리 개념 프로그램의 실행이 종료될 때 까지 메로리를 가용한 상태로 유지 및 관리하는 것 다수의 프로그램 실행 중 메모리가 꽉 차게 되면 시스템의 속도가 느려지고 멈추는 현상이 발생 CPU와 지속적으로 데이터를 송수신하는 상황에서 어떤 부분의 메모리가 현재 사용되는지 어떤 순서로 메모리에 입출력되어야 하는지, 메모리 공간이 필요할 경우 어떻게 확보 및 제거 할지에 대한 종합적인 관리 기억장치 계층 구조의 특징 기억장치 계층 구조의 상위 장치일 수 록 접근속도와 접근 시간이 빠르지만 기억용량이 적고 고가 주기억장치는 각기 자신의 주소를 갖는 워드 또는 바이트들로 구성되어 있으며 주소를 이용하여 액세스 가능 보조기억장치의 데이터는 주기억장치에 적재된 후 CPU에 의해 액세스 가능 기억장치 관리 전략 보조기억장치의 프로그램이나 데이터를 주기억장치에 적재시키는 시기, 적재 위치 등을 지정하여 한정도니 주기억장치의 공간을 효율적으로 사용하기 위한 것 종류 반입(Fetch) 전략 : 언제 적재? 배치(Placement) 전략 : 어디에 위치? 교체(Replacement) 전략 : 어느 영역 교체? 1. Fetch 전략 보조기억장치에 보관 중인 프로그램이나 데이터를 언제 주기억 장치로 적재할 것인지를 결정 Demand Fetch 요구 반입 실행 중인 프로그램이 특정 프로그램이나 데이터 등의 참조를 요구할 때 적재 Anticipatory Fetch 예상 반입 실행 중인 프로그램에 의해 참조될 프로그램이나 데이터를 미리 예상하여 적재 2. Placement 전략 새로 반입되는 프로그램이나 데이터를 주기억장치의 어디에 위치시킬 것인지를 결정 First Fit 최초 적합 프로그램이나 데이터가 들어갈 수 있는 크기의 빈 영역 중에서 첫번째 분할 영역에 배치 Best Fit 최적 적합 프로그램이나 데이터가 들어갈 수 있는 크기의 빈영역 중에서 빈 기억공간을 가장 작게 남기는 분할 영역에 배치 Worst Fit 최악 적합 프로그램이나 데이터가 들어갈 수 있는 크기의 빈영역 중에서 빈 기억공간을 가장 많게 남기는 분할 영역에 배치 3. Replacement 전략 Swapping 스와핑 기법 주기억장치의 모든 영역이 이미 사용중인 상태에서 새로운 프로그램이나 데이터를 주기억장치에 배치하려고할 때 사용중인 어느 영역을 교체하여 사용할 것인지 결정 Swap Out 주기억장치의 프로그램이 보조기억장치로 이동 Swap In 보조기억장치에서 주기억장치로 이동 스와핑 기법은 가상 기억장치의 페이징 기법으로 발전 FIFO; First In First Out, 선입선출 OPT; OPTimeal replacement, 최적교체 LRU; Least Recently Used, 최근 오래 사용 않은 페이지 교체 LFU; Least Frequently Used, 사용 빈도가 가장 작은 페이지 NUR; Not Used Recently, 최근 사용 않은 페이지 교체 SCR; Second Chance Replacement, 2차 기회 교체 주기억장치 할당 기법의 개념 프로그램이나 데이터를 실행시키기 위해 주기억장치에 어떻게 할당할 것인지에 대한 내용 주기억장치 할당 기법의 종류 연속 할당 기법 프로그램을 주기억장치에 연속적으로 할당하는 기법 단일 분할 할당 기법 운영체제영역과 단일 사용자 영역으로 분할 오버레이 주기억장치보다 큰 프로그램 실행 기법 스와핑 주기억장치 프로그램을 보조기억장치 이동 다중 분할 할당 기법 사용자 영역을 여러 개의 고정된 크기로 분할 고정 분할(정적) 할당 사용자 영역을 여러 개의 고정된 크기로 분할 가변 분할(동적) 할당 프로그램의 필요한 크기로 영역 분할, 고정 분할 할당 기법의 영역 내의 단편화 해결 분산 할당 기법 가상기억장치의 내용을 특정 단위의 조각으로 나누어 주기억장치 내에 분산하여 할당하는 기법 페이징 기법 세그먼트 기법 가상기억장치의 개념 VMU; Virtual Memory Unit 보조기억장치의 일부를 주기억장치처럼 사용하는 것 주기억장치의 용량 보다 큰 프로그램을 실행하기 위해 사용 주기억장칭의 이용률과 다중 프로그래밍의 효율성 제고 가상기억장치에 저장된 프로그램을 실행하려면 가상기억장치의 주소를 기억장치의 주소로 바꾸는 주소 변환 작업이 필요 블록 단위로 나누어 사용하므로 연속 할당 방식에서 발생할 수 있는 단편화를 해결할 수 있음 프로그램을 여러 개의 작은 블록 단위로 나누어서 가상기억장치에 보관해놓고, 프로그램 실행시 요구되는 블록만 주기억장치에 불연속적으로 할당하여 처리 1. Paging 페이징 기법 가상기억장치에 보관되어있는 프로그램과 주기억장치의 영역을 동일한 크기로 나눈 후 나눠진 가상기억장치의 프로그램을 주기억장치의 영역인 페이지 프레임에 적재시켜 실행하는 기법 페이지 크기 1 ~ 4KB 외부 단편화는 발생하지 않으나 내부 단편화 발생 내부 단편화 사용할 프로그램이 16KB일 때 페이지 크기를 4KB씩 나누면 2KB 단편화 발생 주소 변환을 위해서는 페이지의 위치 정보를 가지고 있는 페이지 맵 테이블(Page Map Table)이 필요 페이징에서 가상주소는 (p,d)로 표현하며, p는 참조하는 항목이 잇는 가상메모리의 페이지, d는 페이지 안에서 참조하는 항목이 위치한 변위 실제 주소 변환은 페이지 프레임 크기가 ps일 때 p`*ps+d 2. Segmentation 세그멘테이션 기법 가상기억장치에 보관되어 있는 프로그램을 다양한 크기의 논리적인 단위로 나눈 후 주기억장치에 적재시켜 실행시키는 방법 내부 단편화는 발생하지 않으나 외부 단편화가 발생 세그먼트가 주기억장치에 적재될 때 다른 세그먼트에게 할당된 영역을 침범할 수 없으며, 이를 위해 기억장치보호키가 필요 주소 변환을 위해서는 세그먼트가 존재하는 위치 정보를 가지고 있는 세그먼트 맵 테이블 이 필요 세그먼테이션 가상주소는 (s,d)로 표현하며, s는 참조하는 항목이 있는 가상메모리의 세그먼트 번호, d느 세그먼트 s에서 참조하는 항목부터 있는 곳까지의 변위 실제 주소 변환은 세그먼트 번호의 주기억장치 시작주소가 s`일 때 s` +d 페이지 교체 알고리즘 개념 CPU가 액세스한 가상 페이지가 주기억장치에 없는 페이지 부재 Page Fault가 발생했을 때, 가상기억장치의 필요한 페이지를 주기억장치에 적재해야 함 주기억장치의 모든 페이지 프레임이 사용 중 이라면 어떤 페이지 프레임을 선택하여 교체할 것인지 결정 페이지 교체 알고리즘 종류 1. FIFO; First In First Out, 선입선출 각 페이지가 주기억장치에 적재될 때마다 그때의 시간을 기억시켜 가장 먼저 들어와서 가장 오래 있었던 페이지를 교체하는 기법 ex) 2개의 프레임을 수용할 수 있는 주기억장치에서 FIFO 알고리즘을 사용할 경우 페이지 결함의 발생횟수는? 페이지 참조 순서 : 1, 2, 1, 3, 2, 4 답 : 4 해설 - 2개의 프레임에는 1, 2 가 들어가면서 결함 발생 합 2회 (1, 2) - 1은 그대로 (1, 2, 1) - 가장 오래된 것은 첫 번째 프레임이므로 여기에 3이 들어가면서 결함 발생 3회 (1, 2, 1, 3) - 2는 그대로 (1, 2, 1, 3, 2) - 2가 3보다 오래 있었으므로 여기에 4가 들어가면서 결함 발생 4회 (1, 2, 1, 3, 2, 4) - 2. LRU(Least Recently Used) 최근에 가장 오랫동안 사용하지 않은 페이지를 교체 각 페이지마다 계수기 counter 나 스택 stack 을 두어 현 시점에서 가장 오랫동안 사용하지 않은 페이지를 교체 ex) 2개의 프레임을 수용할 수 있는 주기억장치에서 LRU 알고리즘을 사용할 경우 페이지 결함의 발생횟수는? 페이지 참조 순서 : 1, 2, 1, 3, 2, 4 답 : 5 해설 - 2개의 프레임에 1, 2 가 들어가면서 결함 발생 합 2회 (1, 2) - 1 그대로 (1, 2, 1) - 1은 최근에 들어왔으므로 3은 두 번째 프레임에 들어가면서 결함 발생 3회 (1, 2, 1, 3) - 3은 최근에 들어왔으므로 2는 첫 번째 프레임에 들어가면서 결함 발생 4회 (1, 2, 1, 3, 2) - 2는 최근에 들어왔으므로 4는 두 번 째 프레임에 들어가면서 결함 발생 5회 (1, 2, 1, 3, 2, 4) - 3. NUR(Not Used Recently) 최근에 사용하지 않은 페이지를 교체하는 기법 최근에 사용 여부를 확인하기 위해서 각 페이지마다 참조 비트와 변형 비트 2개의 비트를 사용 Reference Bit : 페이지 호출될 때1, 호출되지 않을 때 0 지정 Modified Bit : 페이지 내용 변경될 때1, 변경되지 않을 때 0 지정 참조비트와 변경비트의 값에 따른 교체될 페이지 순서가 결정됨 ![NUR]](/images/정보처리기사/0504_11.png) 4. OPT; OPTimal Replacement, 최적 교체 앞으로 가장 오랫동안 사용하지 않을 페이지를 교체하는 기법 페이지 부재 횟수가 가장 적게 발생하는 가장 효율적인 알고리즘 5. LFU; Least Frequently Used 사용 빈도가 가장 적은 페이지를 교체하는 기법 활발하게 사용되는 페이지는 사용 횟수가 많아 교체하지 않고 사용 6. SCR; Second Chance Replacement 가장 오랫동안 주기억장치에 있던 페이지 중 자주 사용되는 페이지의 교체를 방지하면 FIFO 기법의 단점을 보완하는 기법 가상기억장치의 기타 관리 1. Locality 지역성, 구역성 프로세스가 실행되는 동안 주기억장치를 참조할 때 일부페이지만 집중적으로 참조하는 성질 Temporal Locality 시간 구역성 프로세스가 실행되면서 하나의 페이지를 일정 시간 동안 집중적으로 액세스하는 현상 기억장소 Loop Stack Sub Routine Counting Spatial Locality 공간 구역성 프로세스 실행시 일정 위치의 페이지를 집중적으로 액세스하는 현상 차몾한 페이지의 근처에 있는 페이지를 참조할 가능성이 높음 기억장소 Array Traversal 순차적 코드의 실행 2. Working Set 워킹 셋 프로세스가 일정 시간 동안 자주 참조하는 페이지들의 집합 자주 참조되는 워킹 셋을 주기억장치에 상주시킴으로써 페이지 부재 및 페이지 교체 현상이 줄어듦 시간이 지남에 따라 자주 참조하는 페이지의 집합이 변화하기 때문에 워킹 셋도 시간에 따라 변경됨 3. Thrashing 스래싱 프로세스의 처리 시간 보다 페이지 교체에 소요되는 시간이 더 많아 지는 현상 프로세스들 간의 메모리 경쟁으로 지나치게 페이지 폴트가 발생하여 전체 시스템의 성능이 저하되는 현상 다중 프로그래밍 시스템이나 가상기억장치를 사용하는 시스템에서 하나의 프로세스 수행 과정 중 자주 페이지 부재가 발생함으로써 나타나는 현상으로, 전체 시스템의 성능이 저하됨 스래싱 현상 방지 방법 다중 프로그래밍 정도를 적정 수준으로 유지 페이지 부재 빈도를 조절하여 사용 워킹 셋을 유지 부족한 자원을 증설하고, 일부 프로세스를 중단시킴 CPU 성능에 대한 자료의 지속적인 관리 및 분석으로 임계치를 예상하여 운영","link":"/2020/05/04/Engineer_Information_Processing/ch17_%EC%9D%91%EC%9A%A9SW%EA%B8%B0%EC%B4%88%EA%B8%B0%EC%88%A0%ED%99%9C%EC%9A%A9/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EA%B8%B0%EC%B4%88%ED%99%9C%EC%9A%A9/%EB%A9%94%EB%AA%A8%EB%A6%AC%EA%B4%80%EB%A6%AC/"},{"title":"응용SW기초기술활용 - 운영체제","text":"응용SW기초기술활용 응용소프트웨어를 개발하기 위하여 다양한 운영체제의 특징 이해 CLI 및 GUI 환경에서 운영체제의 기본 명령어를 활용 운영체제에서 제공하는 작업 우선순위 설정 방법을 이용하여 애플리케이션의 작업 우선순위 조정 용어사전 메모리 관리 프로그램의 실행이 종료될 때까지 메모리를 가용한 상태로 유지 및 관리하는 것 환경변수 시스템 소프트웨어의 동작에 영향을 미치는 동적인 값들의 모임 운영체제의 개념 컴퓨터 시스템의 자원들(CPU, 주기억장치, 보조기억장치, 파일 등)을 효율적으로 관리하며, 사용자가 컴퓨터를 편리하고 효과적으로 사용할 수 있도록 인터페이스를 제공하는 시스템 소프트웨어 운영체제의 역할 사용자와 시스템 간의 편리한 인터페이스 제공 시스템의 각종 하드웨어와 네트워크를 관리하고 제어 자원을 효율적으로 관리하기 위해 자원의 스케쥴링 기능 제공 데이터를 관리하고 데이터 및 자원의 공유 기능 제공 입출력에 대한 보조 기능을 제공 시스템의 오류를 검사하고 복구 원시프로그램을 목적프로그램으로 변환하는 것은 번역 프로그램임 운영체제의 목적 목적 컴퓨터 시스템의 처리 능력 향상 사용 가능도 향상 반환 시간 단축 운영체제 성능 평가 기준 처리 능력 반환 시간 사용 가능도 신뢰도 운영체제의 종류 1. Windows 마이크로소프트사가 개발한 운영체제 특징 GUI 키보드로 명령어를 직접 수행하지 않고 마우스로 아이콘이나 메뉴를 선택하여 모든 작업을 수행 선점형 멀티태스킹 동시에 여러 개의 프로그램을 실행하는 멀티태스킹을 하면서 운영체제가 각 작업의 CPU 이용 시간을 제어하여 응용 프로그램 시행 중 문제가 발생하면 해당 프로그램을 강제 종료시키고 모든 시스템 자원을 반환하는 방식 PnP; Plug and Play 컴퓨터 시스템에 프린터나 사운드 카드 등의 하드웨어를 설치했을 때 해당 하드웨어를 사용하는 데 필요한 시스템 환경을 운영체제가 자동으로 구성해주는 기능 OLE; Object Linking Embedding 다른 응용 프로그램에서 작성된 문자나 그림 등의 개체를 현재 작성 중인 문서에 자유롭게 연결하거나 삽입하여 편집할 수 있게 하는 기능 2. UNIX AT&amp;T 벨 연구소, MIT, General Electric이 공동 개발한 운영체제 특징 C언어로 작성되어 이식성 높음 장치와 프로세스 간의 호환성 높음 시분할 시스템으로 설계된 대화식 운영 체제 소스가 공개된 개방형 시스템 다중 사용자가 다중 작업을 지원 많은 네트워킹 기능을 제공하므로 통신망 관리용 운영체제로 적합 구성 Kernel 커널 프로세스 관리 기억장치 관리 입출력 관리 파일 관리 컴퓨터가 부팅될 때 주기억장치에 적재되어 상주하면서 실행 Shell 쉘 사용자의 명령을 인식하는 명령어 해석기 시스템과 사용자 간의 인터페이스 주기억장치에 상주하지 않고, 명령어가 포함된 파일 형태로 존재하며 보조 기억장치에서도 교체처리가 가능 한 프로세스의 출력이 다른 프로세스의 입력으로 사용되는 단방향 통신인 파이프 라인 기능을 지원 3. LINUX 리누스 토발즈가 개발한 운영체제 특징 프로그램 소스 코드가 무료로 공개되어 프로그래머가 원하는 기능 추가 다양한 플랫폼에 설치하여 사용 가능 재배포가 가능 UNIX와 완벽하게 호환 4. MacOS Apple에서 UNIX 기반으로 개발한 운영체제 특징 아이맥과 맥북 등 애플 사 제품에만 사용이 가능 드라이버 설치 및 install 과정이 단순함 5. MS-DOS Windows 이전 운영체제, CLI","link":"/2020/05/04/Engineer_Information_Processing/ch17_%EC%9D%91%EC%9A%A9SW%EA%B8%B0%EC%B4%88%EA%B8%B0%EC%88%A0%ED%99%9C%EC%9A%A9/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EA%B8%B0%EC%B4%88%ED%99%9C%EC%9A%A9/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/"},{"title":"응용SW기초기술활용 - 프로세스 스케줄링","text":"응용SW기초기술활용 프로세스의 개념 처리기, CPU에 의해 처리되는 사용자 프로그램 정의 PCB(Process Controll Block)을 가지는 프로그램 실기억장치에 저장된 프로그램 프로세서가 할당되는 실체로서, 디스패치가 가능한 단위 프로시저가 활동 중인 것 서로 규칙적이거나 연속적이지 않고 독립적으로 실행되므로 비동기적 행위를 일으키는 주체 지정된 결과를 얻기 위한 일련의 계통적 동작 목적 또는 결과에 따라 발생되는 사건들의 과정 운영체제가 관리하는 실행 단위 PCB; Process Control Block, 프로세스 제어 블록 운영체제가 프로세스에 대한 중요한 정보를 저장해 놓는 곳 각 프로세스가 생성될 때마다 고유의 PCB가 생성되고, 프로세스가 완료되면 PCB는 제거됨 PCB에 저장되는 정보의 종류 프로세스의 현재 상태 포인터 부모 프로세스의 주소 기억 자식 프로세스의 주소 기억 현재 프로세스가 위치한 주소 기억 프로세스에 할당된 각 자원에 대한 주소 기억 프로세스 고유 식별자 스케줄링 및 프로세스의 우선순위 CPU 레지스터 정보 주기억장치 관리 정보 입출력 상대 정보 계정 정보 Thread 스레드 프로세스 내에서의 작업 단위로서 시스템의 여러 자원을 할당 받아 실행하는 프로그램 단위 하나의 프로세스에 하나의 스레드가 존재하는 경우는 단일 스레드, 하나 이상의 스레드가 존재하는 경우는 다중스레드 프로세스의 일부 특성을 갖고 있기 때문에 경량 프로세스라고 함 스레드 기반 시스템에서는 스레드는 독립적인 스케줄링의 최소 단위로서 프로세스의 역할 담당 장점 하드웨어, 운영체제의 성능과 응용 프로그램 처리율 향상 응용 프로그램의 응답 시간 단축 실행 환경을 공유 시켜 기억장소의 낭비를 줄임 프로세스들 간의 통신 향상 프로세스 내부의 작업 단위 Scheduling 스케줄링의 개념 CPU나 자원을 효율적으로 사용하기 위한 정책 프로세스가 생성되어 실행될 때 필요한 시스템의 여러 자원을 해당 프로세스에게 할당하는 작업 프로세스가 생성되어 완료될 때 까지 프로세스는 여러 종류의 스케줄링 과정을 거침 스케줄링의 목적 모든 프로세스에게 공정하게 할당 단위 시간당 프로세스를 처리하는 비율 증가 CPU가 순수하게 프로세를 실행하는데 사용되는 시간 비율 증가 우선 순위가 높은 프로세를 먼저 실행 오버헤드를 최소화 오버헤드 시스템에서 목적으로 하는 효과를 얻기 위해 본질적인 것은 아니지만 요구되는 작동, 또는 그 때문에 필요한 자원 작업을 지시하고 반응하는 응답시간 최소화 프로세스를 제출한 시간부터 실행이 완료될 때까지 걸리는 반환시간을 최소화 프로세스가 준비상태 큐에서 대기하는 시간을 최소화 메모리, 입력장치 등의 자원을 균형 있게 사용 자원을 사용하기 위해 무한정 연기되는 상태를 회피 프로세스에게 CPU를 할당하고 문맥 교환을 하는 프로세스 관리기능 Non-Preemptive 비선점 스케줄링 이미 할당된 CPU를 다른 프로세스가 강제로 빼앗아 사용할 수 없는 스케줄링 기법 프로세스가 CPU를 할당 받으면 해당 프로세스가 완료될 때까지 CPU를 사용 모든 프로세스에 대한 요구를 공정하게 처리 프로세스 응답 시간의 예측이 용이하며, 일괄 처리 방식에 적합 짧은 작업이 긴 작업을 기다리는 경우 발생할 수 있음 종류 FIFO(FCFS) SJF HRN Priority Preemptive 선점 스케줄링 하나의 프로세스가 CPU를 할당 받아 실행하고 있을 때 우선순위가 높은 다른 프로세스가 CPU를 강제로 빼앗아 사용할 수 있는 스케줄링 기법 우선순위가 높은 프로세를 빠르게 처리 빠른 응답시간을 요구하는 대화식 시분할 시스템에 사용됨 많은 오버헤드를 초래 선점이 가능하도록 일정 시간 배당에 대한 인터럽트용 타이머 클록 필요 종류 RR SRT Preemptive Priority MLQ MFQ 프로세스 스케줄링 종류 및 특징","link":"/2020/05/04/Engineer_Information_Processing/ch17_%EC%9D%91%EC%9A%A9SW%EA%B8%B0%EC%B4%88%EA%B8%B0%EC%88%A0%ED%99%9C%EC%9A%A9/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EA%B8%B0%EC%B4%88%ED%99%9C%EC%9A%A9/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81/"},{"title":"응용SW기초기술활용 - 핵심정리","text":"응용SW기초기술활용 1. 운영체제 종류 컴퓨터 시스템의 자원들(CPU, 주기억장치, 보조기억장치, 파일 등)을 효율적으로 관리하며, 사용자가 컴퓨터를 편리하고 효과적으로 사용할 수 있도록 인터페이스를 제공하는 시스템 소프트웨어 종류 Windows UNIX LINUX MacOS MS-DOS 2. 메모리 관리 기억장치의 계층 구조(산 형태 순서 정렬) 레지스터 캐시 기억장치 주기억장치 보조기억장치 기억장치 관리 전략 Fetch Placement Replacement 주기억장치 할당 기법 연속 할당 분산 할당 가상기억장치의 구현 기법 페이징 세그먼테이션 페이지 교체 알고리즘 종류 FIFO LRU NUR OPT LFU SCR 가상기억장치의 기타 관리 Locality Working Set Thrashing 3. 프로세스 스케줄링 프로세스 프로세서에 의해 처리되는 사용자 프로그램 프로세서 CPU 처리기 스레드 프로세스 내에서 작업 단위로서 시스템의 여러 자원을 할당 받아 실행하는 프로그램의 단위 스케줄링 프로세스가 생성되어 실행될 때 필요한 시스템의 여러 자원ㅇ르 해당 프로세스에 할당하는 작업 비선점 스케줄링의 종류 FIFO(FCFS) SJF HRN 선점 스케줄링의 종류 RR SRT MLQ MFQ 4. 환경변수 시스템 소프트웨어 동작에 영향을 미치는 동적인 값들의 모임 윈도우 환경변수 %APPDATA%, %COMSPEC%, %HOMEPATH%, %PATH%, %PATHEXT%, %PROGRAMFILES%, %SYSTEMDRIVE%, %SYSTEMROOT% , %USERNAME%, %USERPROFILE% 유닉스 환경변수 $DISPLAY, $HOME, $LANG, $MAIL, $PATH, $PS1, $PWD, $TERM, $USER 5. Shell Script GUI Graphic User Interface 마우스로 아이콘이나 메뉴를 선택하여 작업 CLI Command Line Interface 키보드로 명령어를 직접 입력하여 작업 UNIX와 LINUX 기본 명령어 명령어 기능 cat 파일 내용을 화면에 표시 chdir 디렉토리 위치 변경 chmod 파일의 사용 허가 지정 chown 소유자 변경 cp 파일 복사 getpid 자신의 프로세스 아이디를 얻음 ls 현재 디렉토리 내의 파일 목록을 표시 rm 파일 삭제","link":"/2020/05/05/Engineer_Information_Processing/ch17_%EC%9D%91%EC%9A%A9SW%EA%B8%B0%EC%B4%88%EA%B8%B0%EC%88%A0%ED%99%9C%EC%9A%A9/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EA%B8%B0%EC%B4%88%ED%99%9C%EC%9A%A9/%ED%95%B5%EC%8B%AC%EC%A0%95%EB%A6%AC/"},{"title":"응용SW기초기술활용 - 환경변수","text":"응용SW기초기술활용 환경변수의 개념 시스템 소프트웨어의 동작에 영향을 미치는 동적인 값들의 모임 변수명과 값으로 구성 시스템의 기본 정보를 저장 자식프로세스에 상속됨 부모 프로세스에서 상속받아 사용 시스템 전반에 걸쳐 적용되는 시스템 환경변수와 사용자 계정 내에만 적용되는 사용자 환경변수로 구분 환경변수 보기 Windows echo %PATH% UNIX echo $PATH 환경변수 설정 Windows self 변수 = 값 UNIX env 변수 = 값 set 변수 = 값 윈도우 운영체제 환경변수 환경변수 용도 %APPDATA% 설치된 모든 프로그램의 필요 데이터가 저장된 폴더 %COMSPEC% 기본 명령 프롬프트로 사용할 프로그램 %HOMEPATH% 로그인한 계정의 기본 폴더 %PATH% 실행 파일을 찾는 경로 %PATHEXT% CMD에서 실행할 수 있는 파일 확장자 목록 %PROGRAMFILES% 기본프로그램의 설치 폴더 %SYSTEMDRIVE% 윈도우가 부팅된 드라이브 %SYSTEMROOT% 부팅된 운영체제가 들어 있는 폴더 %USERNAME% 로그인한 계정 이름 %USERPROFILE% 로그인한 유저의 프로필이 저장된 폴더 UNIX와 LINUX 운영체제 환경변수 환경변수 용도 $DISPLAY 현재 디스플레이 위치 $HOME 사용자의 홈 디렉토리 $LANG 프로그램 사용 시 기본적으로 지원되는 언어 $MAIL 이메일을 보관하는 경로 $PATH 실행파일을 찾는 경로 $PS1 Shell Prompt 정보 $PWD 현재 작업하는 디렉토리 $TERM 로그인 터미널 타입 $USER 사용자의 이름","link":"/2020/05/05/Engineer_Information_Processing/ch17_%EC%9D%91%EC%9A%A9SW%EA%B8%B0%EC%B4%88%EA%B8%B0%EC%88%A0%ED%99%9C%EC%9A%A9/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EA%B8%B0%EC%B4%88%ED%99%9C%EC%9A%A9/%ED%99%98%EA%B2%BD%EB%B3%80%EC%88%98/"},{"title":"프로그래밍언어활용 - 변수","text":"프로그래밍언어활용 Variable 변수의 개념 변수는 저장하고자 하는 어떠한 값이 있을 때, 그 값을 주기억장치에 기억하기 위한 공간을 의미 저장하는 값에 따라 정수형, 실수형, 문자형 등으로 구분 C언어 변수명 설정 규칙 영문자, 숫자, 밑줄의 사용 가능 첫 글자는 영문자나 '_'로 시작해야하며 숫자를 사용할 수 없음 변수명에는 공백이나 밑줄이외의 특수문자(*,?,+,- 등) 사용 불가 글자 수에 제한이 없음 영문자는 대소문자를 구분 변수명은 제어문, 자료형 등 예약어 사용 불가능 예약어 제어문이나 데이터 타입 등 이미 용도가 정해져 있는 단어 do, for, while, char, double 변수 선언시 문장 끝에 세미콜론(’;’)을 붙여야 함 변수의 선언 변수는 일반적으로 다음과 같은 형식으로 선언 자료형 변수명 = 값; 자료형 : 변수에 저장될 자료의 형식을 지정 변수명 : 변수명 작성 규칙에 맞게 변수명 지정 값 : 변수를 선언하면서 초기값 지정 int a = 10; int : 자료의 형식을 정수형으로 지정 a : 변수명을 a로 지정 10 : 초기값을 10으로 지정","link":"/2020/05/07/Engineer_Information_Processing/ch16_%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%96%B8%EC%96%B4%ED%99%9C%EC%9A%A9/%EA%B8%B0%EB%B3%B8%EB%AC%B8%EB%B2%95%ED%99%9C%EC%9A%A9/%EB%B3%80%EC%88%98/"},{"title":"프로그래밍언어활용 - 연산자","text":"프로그래밍언어활용 Operator 연산자의 개념 연산자는 프로그램 실행을 위해 연산을 표현하는 기호 프로그램 내에서는 +,-와 같은 연산자 사용 연산자의 종류는 산술 연산자, 시프트 연산자, 관계 연산자, 논리 연산자 연산자 종류 1. 산술 연산자 일반적으로 사용되는 연산자 2. 관계 연산자 두 피연산자 사이의 크기를 비교하는 연산자 3. 시프트 연산자 비트를 이동시키는 연산자 4. 논리 연산자 두 피연산자 사이의 논리적인 관계를 정의하는 연산자 5. 비트 연산자 0과 1의 각 자리에 대한 연산을 수행하며, 0또는 1의 결과값을 가짐 연산자 우선순위 1. Java의 연산자 우선순위 2. C언어의 연산자 우선순위 연산 표기법의 종류 연산 표기법간 전환(Prefix -&gt; Postfix) Prefix -&gt; Infix 변환(+a*bc) (연산자, 변수, 변수)를 찾은 후 (변수, 연산자, 변수) 순으로 변경 +a(b*c) 같은 방법으로 나머지도 변수, 연산자, 변수 순으로 변경 후 괄호제거 a+b*c Infix -&gt; Postfix 변환(a+b*v) (변수, 연산자, 변수) 중 우선순위가 높은 연산자를 (변수, 변수, 연산자) 순으로 변경 a+(bc*) 나머지도 변수, 변수, 연산자 순으로 변경 후 괄호 제거 a(bc*)+ abc*+","link":"/2020/05/07/Engineer_Information_Processing/ch16_%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%96%B8%EC%96%B4%ED%99%9C%EC%9A%A9/%EA%B8%B0%EB%B3%B8%EB%AC%B8%EB%B2%95%ED%99%9C%EC%9A%A9/%EC%97%B0%EC%82%B0%EC%9E%90/"},{"title":"프로그래밍언어활용 - 데이터타입","text":"프로그래밍언어활용 응용소프트웨어 개발에 필요한 프로그래밍 언어의 데이터 타입을 적용하여 변수를 사용 프로그래밍 언어의 연산자와 명령문을 사용하여 애플리케이션에 필요한 기능을 정의하고 사용 용어사전 변수 어떤 값을 주기억 장치에 기억하기 위해서 사용하는 공간 데이터 타입 변수가 가질 수 있는 속성값의 길이 및 성절 연산자 데이터 처리를 위해 연산을 표현하는 기호로 +, - 등과 같은 연산자를 포함 데이터 타입(Data Type)의 개념 데이터 타입은 변수에 저장될 데이터의 형식을 나타내는 것 변수에 값을 저장하기 전에 문자형, 정수형, 실수형 등 어떤 형식의 값을 저장할지 데이터 타입을 지정하여 변수를 선언 데이터 타입 유형 불린 타입 조건이 참인지 거짓인지 판단할 때 사용 문자 타입 문자 하나를 저장하여 작은 따옴표 사용 문자열 타입 나열된 여러 개의 문자를 저장하여 큰 따옴표 사용 정수 타입 정수 값을 저장하고자 할 때 사용 부동 소숮점 타입 소수점을 포함하는 실수 값을 저장할 때 사용 배열 타입 여러 데이터를 하나로 묶어서 저장할 때 사용 Java의 데이터 타입 크기 및 기억 범위 C/C++의 데이터 타입 크기 및 기억 범위","link":"/2020/05/07/Engineer_Information_Processing/ch16_%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%96%B8%EC%96%B4%ED%99%9C%EC%9A%A9/%EA%B8%B0%EB%B3%B8%EB%AC%B8%EB%B2%95%ED%99%9C%EC%9A%A9/%EB%8D%B0%EC%9D%B4%ED%84%B0%ED%83%80%EC%9E%85/"},{"title":"프로그래밍언어활용 - 핵심정리","text":"프로그래밍언어활용 1. 데이터 타입 변수에 저장될 데이터 형식을 나타내는 것 2. 변수 변수는 저장하고자 하는 어떠한 값이 있을 때, 그 값을 주기억장치에 기억하기 위한 공간을 의미 저장하는 값에 따라 정수형, 실수형, 문자형 등으로 구분 C언어 변수명 설정 규칙 영문자, 숫자, 밑줄의 사용 가능 첫 글자는 영문자나 '_'로 시작해야하며 숫자 사용 불가 변수명에는 공백사용 불가 글자 수에 제한이 없음 영문자는 대소문자를 구분 변수명은 제어문, 자료형 등 예약어 사용 불가능 3. 연산자 연산자는 프로그램 실행을 위해 연산을 표현하는 기호 연산자의 종류는 산술 연산자, 시프트 연산자, 관계 연산자, 논리 연산자 연산 표기법의 종류 Prefix 전위 표기법 +a*bc Infix 중위 표기법 a+(b*c) Postfix 후위 표기법 abc*+","link":"/2020/05/07/Engineer_Information_Processing/ch16_%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%96%B8%EC%96%B4%ED%99%9C%EC%9A%A9/%EA%B8%B0%EB%B3%B8%EB%AC%B8%EB%B2%95%ED%99%9C%EC%9A%A9/%ED%95%B5%EC%8B%AC%EC%A0%95%EB%A6%AC/"},{"title":"프로그래밍언어활용 - 데이터입출력","text":"프로그래밍언어활용 C언어의 데이터 표준 입출력 함수 키보드로 입력 받아 화면으로 출력할 때 사용하는 함수 종류 scanf() getchar() gets() printf() putchar() puts() Java언어의 데이터 표준 입출력 키보드로 입력 받은 값을 저장하고 화면에서 서식을 지정하여 출력할 때 사용하는 클래스와 메소드 표준 입력 관련 클래스 Scanner 표준 출력 관련 클래스와 메소드 System.out.printf() scanf()함수 사용형식 scanf(서식문자열, 변수의 주소) scanf(&quot;%3d&quot;, &amp;a) 서식 문자열 입력 받을 데이터의 데이터 타입 지정 변수의 주소 입력 받을 데이터의 테이터 주소 저장 입력 받을 데이터의 자료형, 자릿수 지정 기능 한 번에 여러 개의 데이터 입력 가능 서식 문자열과 변수의 자료형은 일치해야 함 printf()함수 사용형식 print(서식문자열, 변수) printf(&quot;%-8.2f&quot;, 100.3) 100.30vv(v는 빈칸) 서식 문자열 변수의 자ꅐ형에 맞는 서식문자열 입력 변수 서식문자열의 순서에 맞게 출력할 변수 입력 % 서식문자임을 지정 - 왼쪽부터 출력 8 출력자리수 2 소수점 이하 2자리 지정 f 실수로 출력 서식문자열 %d 정수형 10진수 입출력시 지정 %u 부호 없는 정수형 10진수 입출력시 지정 %o 정수형 8진수 입출력시 지정 %x 정수형 16진수 입출력시 지정 %c 문자 입출력시 지정 %s 문자열 입출력시 지정 %f 소수점을 포함하는 실수 입출력시 지정 %e 지수형 실수 입출력시 지정 제어문자 \\n new line 커서 다음 줄 앞으로 이동 \\b backspace 커서를 왼쪽으로 한 칸 이동 \\t tab 커서를 일정 간격 띄움 \\r carriage return 커서를 현재 줄의 처음으로 이동 \\0 null 널 문자를 출력 \\` single quote 작은 따옴표 출력 \\&quot; double quote 큰 따옴표 출력 \\\\ backslash 역 슬래시 출력 \\f form feed 한 페이지를 넘김 C언어 기타 표준 입출력 함수 입력 getchar() 키보드로 한 문자를 입력 받아 변수에 저장하는 함수 gets() 키보드로 문자열을 입력 받아 변수에 저장하는 함수 출력 putchar() 인수로 주어진 한 문자를 화면에 출력하는 함수 puts() 인수로 주어진 문자열을 화면에 출력한 후 커서를 자동으로 다음 줄 앞으로 이동하는 함수 Java 표준 입력 사용 형식 12Scanner scan1 = new Scanner(System.in);in_var = scan1.nextInt(); Scanner 클래스를 인스턴스화하여 scan1 객체 변수를 생성 System.in은 표준 입력장치 즉 키보드로 부터 값을 입력 받는 객체 변수 생성 scan1 객체변수의 nextInt() 메소드는 입력 값을 정수형으로 반환 in_var : 입력 받은 값을 저장할 변수 Java 표준 출력 사용 형식 12System.out.printf(서식문자열, 변수);System.out.printf(\"%-8.2f\",100.3); Sytem 클래스의 서브 클래스인 out 클래스의 printf()메소드를 사용 printf() 메소드는 C언어의 printf() 함수의 사용법도 동일함","link":"/2020/05/08/Engineer_Information_Processing/ch16_%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%96%B8%EC%96%B4%ED%99%9C%EC%9A%A9/%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC%ED%99%9C%EC%9A%A9/%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%9E%85%EC%B6%9C%EB%A0%A5/"},{"title":"프로그래밍언어활용 - 예외처리","text":"프로그래밍언어활용 예외처리의 개념 정상적인 실행을 방해하는 조건이나 상태를 뜻 예외가 발생했을 때 해당 문제에 대한 처리 루틴을 수행하도록 하는 것 예외의 원인은 컴퓨터 하드웨어 문제, 운영 체제의 설정 실수, 라이브러리 손상, 사용자의 입력 실수, 할당하지 못한 기억 장치 접근이 있음 Java에서의 예외처리 예외를 객체로 취급 try~catch 구문 이용 try 블록 코드를 수행하다가 예외가 발생하면 예외를 처리하는 catch 블록으로 이동하여 예외 처리 코드를 실행하고 예외 발생 이후 코드는 실행 안됨 catch 블록에서 선언한 변수는 해당 catch 블록에서만 유효 try~catch 안에 또 다른 try~catch 포함 가능 Java의 주요 예외 객체","link":"/2020/05/08/Engineer_Information_Processing/ch16_%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%96%B8%EC%96%B4%ED%99%9C%EC%9A%A9/%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC%ED%99%9C%EC%9A%A9/%EC%98%88%EC%99%B8%EC%B2%98%EB%A6%AC/"},{"title":"프로그래밍언어활용 - 라이브러리","text":"프로그래밍언어활용 애플리케이션에 필요한 라이브러리를 검색하고 선택 애플리케이션 구현을 위해 선택한 라이브러리를 프로그래밍 언어 특성에 맞게 구성 선택한 라이브러리를 사용하여 애플리케이션 구현에 적용 용어사전 라이브러리 효율적인 프로그램 개발을 위해 필요한 프로그램을 모아 놓은 집합체로서, 프로그래밍 언어에 따라 일반적으로 도움말, 설치 파일, 샘플 코드 등을 제공 라이브러리의 개념 프로그램을 효율적으로 개발할 수 있도록 자주 사용하는 함수나 데이터들을 미리 만들어 모아 놓은 집합체 프로그래밍 언어에 따라 일반적으로 도움말, 설치파일, 샘플 코드 등을 제공 라이브러리의 구성 도움말 : 라이브러리를 사용할 수 있도록 하는 도움말 문서 설치파일 : 라이브러리를 적용하기 위해 제공되는 설치 파일 샘플 코드 : 라이브러리를 이해하고 손쉽게 적용하기 위해 제공되는 샘플 소스코드 라이브러리 종류 1. 표준 라이브러리 프로그래밍 언어에 기볹거으로 포함되어 있는 라이브러리 여러 종류의 모듈과 패키지를 가지며, 표준라이브러리를 이용하면 별도의 파일 설치 없이 날짜와 시간 등의 다양한 기능 이용이 가능함 2. 외부 라이브러리 별도 파일을 설치해야함 누구나 개발하여 설치할 수 있으며 공유도 가능 모듈과 패키지 1. Module 모듈 하나의 기능이 한 개의 파일로 구현된 형태 2. Package 패키지 여러 개의 모듈을 한 개의 폴더에 묶어서 기능을 제공 패키지명과 모듈을 import하여 불러올 수 있음 3. C언어의 대표적인 표준라이브러리 라이브러리를 헤더 파일로 제공 헤어 파일을 함수들이 포함 4. Java언어의 대표적인 표준라이브러리 라이브러리를 패키지에 포함하여 제공","link":"/2020/05/08/Engineer_Information_Processing/ch16_%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%96%B8%EC%96%B4%ED%99%9C%EC%9A%A9/%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC%ED%99%9C%EC%9A%A9/%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC/"},{"title":"프로그래밍언어활용 - 프로토타입","text":"프로그래밍언어활용 프로토타입의 개념 함수 원형이라는 의미 컴파일러에게 사용될 함수에 대한 정보를 미리 알리는 것 본문이 없다는 점을 제외하고 함수와 형태가 동일 반환 형식은 함수 정의에 지정된 반환 형식과 반드시 일치","link":"/2020/05/08/Engineer_Information_Processing/ch16_%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%96%B8%EC%96%B4%ED%99%9C%EC%9A%A9/%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC%ED%99%9C%EC%9A%A9/%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85/"},{"title":"프로그래밍언어활용 - 객체지향 프로그래밍 언어","text":"프로그래밍언어활용 Object Oriented 객체지향 프로그래밍 언어의 개념 구조적 방식의 문제점을 극복하고 인간이 사고하는 방식대로 프로그램을 개발하려는 노력으로 탄생 현실 세계의 개체 Entity 를 기계의 부품처럼 하나의 객체 Object 로 만들어 객체들을 조립해서 프로그램을 작성할 수 있도록 한 프로그래밍 기법 프로시저보다는 명령과 데이터로 구성된 객체를 중심으로 하는 프로그래밍 기법 객체지향 프로그래밍 언어의 장/단점 장점 상속을 통함 재사용과 시스템 확장이 용이 코드의 재활용성이 높음 현실 세계를 모형화하여 사용자와 개발자가 쉽게 이해 대형 프로그램의 작성이 용이 소프트웨어 개발 및 유지보수가 용이 단점 프로그래밍 구현을 지원해 주는 정형화된 분석 및 설계방법이 없음 구현 시 처리 시간이 지연 객체지향 프로그래밍의 특징 Encapsulation 캡슐화 데이터(속성)와 데이터를 처리하는 함수를 하나로 묶는 것 캡슐화된 객체의 세부 내용이 외부에 은폐되어 변경이 발생할 때 오류의 파급 효과가 적음 캡슐화된 객체들은 재사용이 용이 Information Hiding 정보은닉 다른 객체에게 자신의 정보를 숨기고 자신의 연산만을 통하여 접근을 허용하는 것 Abstraction 추상화 불필요한 부분을 생략하고 객체의 속성 중 가장 중요한 것에만 중점을 두어 모델화하는 것 공통 성질을 추출하여 슈퍼클래스를 설정하는 것 Inheritance 상속성 상위 클래스의 모든 속성과 메소드를 하위 클래스가 물려 받는 것 Polymorphism 다형성 동일한 이름의 메소드가 각 클래스마다 다른 사양으로 정의될 수 있음 다형성의 종류는 메소드 오버라이딩과 오버로딩이 있음 객체지향 프로그래밍의 구성요소 Class 클래스 객체의 타입을 정의하고 객체를 생성하는 틀 Object 객체 개체, 속성, 메소드로 구성된 클래스이 인스턴스 Message 메시지 객체간의 통신 객체의 구성요소 Entity 개체 현실 세계에 보이는 본질을 의미 Attribute 속성 자료 저장소 역할을 하며, 절차 지향 프로그래밍의 변수와 대응 Method 메소드 호출 단위를 의미하며, 절차지향 프로그래밍의 함수와 대응 객체지향 프로그래밍 언어의 종류 C# 마이크로소프트에서 개발한 객체지향 프로그래밍 언어로, 닷넷 프레임워크의 한 부분으로 만들어짐 JAVA 분산 네트워크 환경에서 적용이 가능하며, 멀티스레드 기능을 제공하여 여러 작업 동시 처리 가능 운영체제 및 하드웨어 독립적이며 이식성이 강함 캡슐화가 가능하고 재사용성이 높음 C++ C언어에 객체지향 개념을 적용한 언어 모든 문제를 객체로 모델링하여 표현","link":"/2020/05/07/Engineer_Information_Processing/ch16_%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%96%B8%EC%96%B4%ED%99%9C%EC%9A%A9/%EC%96%B8%EC%96%B4%ED%8A%B9%EC%84%B1%ED%99%9C%EC%9A%A9/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%96%B8%EC%96%B4/"},{"title":"프로그래밍언어활용 - 핵심정리","text":"프로그래밍언어활용 1. 라이브러리 프로그램을 효율적으로 개발할 수 있도록 자주 사용하는 함수나 데이터들을 미리 만들어 모아 놓은 집합체 프로그래밍 언어에 따라 일반적으로 도움말, 설치파일, 샘플 코드 등을 제공 2. 데이터 입출력 키보드로 입력 받은 값을 저장하고 화면에서 서식을 지정하여 출력할 때 사용하는 클래스와 메소드 C언어 관련 scanf() getchar() gets() printf() putchar() puts() Java언어 관련 Scanner Sytem.out.printf() 3. 예외처리 프로그램의 정상적인 실행을 방해하는 조건이나 상태를 뜻하는 예외가 발생했을 때 해당 문제에 대한 처리 루틴을 수행하도록 하는 것 4. 프로토타입 프로그래밍 언어에서 프로토타입이란 함수 원형 컴파일러에게 사용될 함수에 대한 정보를 미리 알리는 것 본문이 없다는 점을 제외하고 함수와 형태가 동일 반환 형식은 함수 정의에 지정된 반환 형식과 반드시 일치","link":"/2020/05/08/Engineer_Information_Processing/ch16_%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%96%B8%EC%96%B4%ED%99%9C%EC%9A%A9/%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC%ED%99%9C%EC%9A%A9/%ED%95%B5%EC%8B%AC%EC%A0%95%EB%A6%AC/"},{"title":"프로그래밍언어활용 - 스크립트 언어","text":"프로그래밍언어활용 Script Language 스크립트 언어의 개념 HTML 문서 안에 직접 프로그래밍 언어를 삽입하여 사용되며, 기계어로 컴파일 되지 않고 별도의 번역기가 소스를 분석하여 동작하는 언어 게시판, 상품 검색, 회원 가입 등과 같은 데이터베이스 처리 작업을 수행하기 위해 주로 사용 스크립트 언어는 웹브라우저에서 해석되어 실행하는 클라이언트용 스크립트 언어와 서버에서 해석되어 실행된 후 결과만 클라이언트로 보내는 서버용 스크립트 언어로 구분 클라이언트용 스크립트 언어 JavaScript 서버용 스크립트 언어 ASP JSP PHP Python 스크립트 언어의 장/단점 장점 컴파일 없이 바로 실행하므로 결과를 바로 확인가능 배우고 코딩하기 쉬움 개발시간이 짧음 소스코드를 쉽고 빠르게 수정할 수 있음 단점 코드를 읽고 해석해야 하므로 실행 속도가 느림 런타임 오류가 많이 발생 스크립트 언어의 종류 JavaScript 웹 브라우저에서 주로 사용되는 클라이언트용 스크립트 언어 폼 양식에서 필수 입력사항을 체크하는 용도로 많이 사용 ASP; Active Server Page IIS 서버 측에서 동적으로 수행하는 페이지를 만들기 위해 마이크로 소프트에서 개발 Window 운영체제에서만 실행 가능한 프로그래밍 언어 JSP; Java Server Page Java로 만들어진 서버용 스크립트 언어 Window, Linux등 다양한 운영체제에서 사용 가능 PHP; Professional Hypertext Preprocessor 서버용 스크립트 언어 배우기 쉬움 Python 객체지향 기능을 지원하는 대화형 인터프리터 언어로 플랫폼 독립적이고 문법이 간단하여 배우기 쉬움","link":"/2020/05/07/Engineer_Information_Processing/ch16_%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%96%B8%EC%96%B4%ED%99%9C%EC%9A%A9/%EC%96%B8%EC%96%B4%ED%8A%B9%EC%84%B1%ED%99%9C%EC%9A%A9/%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EC%96%B8%EC%96%B4/"},{"title":"프로그래밍언어활용 - 핵심정리","text":"프로그래밍언어활용 1. 절차적 프로그래밍 언어 일련의 처리 절차를 정해진 문법에 따라 순서대로 기술하는 언어 장점 컴퓨터의 처리 구조와 유사하며 실행속도가 빠름 같은 코드를 복사하지 않고 다른 위치에서 호출하여 사용가능 모듈 구성이 용이하며 구조적인 프로그래밍 가능 단점 프로그램을 분석하기 어려움 유지보수나 코드의 수정이 어려움 종류 C COBOL ALGOL FORTRAN 2. 객체지향 프로그래밍 언어 프로시저보다는 명령과 데이터로 구성된 객체를 중심으로 하는 프로그래밍 기법 장점 상속을 통함 재사용과 시스템 확장이 용이 코드의 재활용성이 높음 현실 세계를 모형화하여 사용자와 개발자가 쉽게 이해 대형 프로그램의 작성이 용이 소프트웨어 개발 및 유지보수가 용이 단점 프로그래밍 구현을 지원해 주는 정형화된 분석 및 설계방법이 없음 구현 시 처리 시간이 지연 특징 캡슐화 정보은닉 추상화 상속성 다형성 종류 C# JAVA C++ 3. 스크립트 언어 HTML 문서 안에 직접 프로그래밍 언어를 삽입하여 사용되며, 기계어로 컴파일 되지 않고 별도의 번역기가 소스를 분석하여 동작하는 언어 장점 컴파일 없이 바로 실행하므로 결과를 바로 확인가능 배우고 코딩하기 쉬움 개발시간이 짧음 소스코드를 쉽고 빠르게 수정할 수 있음 단점 코드를 읽고 해석해야 하므로 실행 속도가 느림 런타임 오류가 많이 발생 클라이언트용 스크립트 언어 JavaScript 서버용 스크립트 언어 ASP JSP PHP Python 4. 선언형 언어 명령형 언어가 문제를 해결하기 위한 방법을 기술한다면 선언형 언어는 프로그램이 수행해야 할 문제를 기술하는 언어 종류 LISP PROLOG Haskell SQL HTML XML","link":"/2020/05/07/Engineer_Information_Processing/ch16_%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%96%B8%EC%96%B4%ED%99%9C%EC%9A%A9/%EC%96%B8%EC%96%B4%ED%8A%B9%EC%84%B1%ED%99%9C%EC%9A%A9/%ED%95%B5%EC%8B%AC%EC%A0%95%EB%A6%AC/"},{"title":"프로그래밍언어활용 - 절차적 프로그래밍 언어","text":"프로그래밍언어활용 프로그래밍 언어별 특성 파악 파악된 프로그래밍 언어의 특성을 적용하여 애플리케이션을 구현 애플리케이션을 최적화하기 위해 프로그래밍 언어의 특성을 활용 프로그래밍 언어의 언어별 특성 프로그래밍 언어는 컴퓨터 시스템의 역사와 함께하고 있으며 프로그래밍 언어가 개바로딘 시대적인 패러다임에 따른 특성을 가짐 프로그래밍 언어의 발전 과정 1960년대 이전 ASSEMBLY FORTRAN LISP 1960년대 COBOL PL/I BASIC 1970년대 PASCAL C SMALLTALK PROLOG 1980년대 ADA C++ PYTHON PROLOG 1990년대 이후 RUBY JAVA JAVASCRIPT C# Procedural 절차적 프로그래밍 언어의 개념 일련의 처리 절차를 정해진 문법에 따라 순서대로 기술하는 언어 프로그램이 실행되는 절차를 중요시 함 데이터를 중심으로 프로시저를 구현하며 프로그램 전체가 유기적으로 연결됨 프로시저 루틴, 하위프로그램, 서브루틴, 메서드, 함수라고도 함 수행되어야할 연속적인 계산과정을 포함 자연어에 가까운 단어와 문장으로 구성 절차적 프로그램 언어의 장/단점 장점 컴퓨터의 처리 구조와 유사하며 실행속도가 빠름 같은 코드를 복사하지 않고 다른 위치에서 호출하여 사용가능 모듈 구성이 용이하며 구조적인 프로그래밍 가능 단점 프로그램을 분석하기 어려움 유지보수나 코드의 수정이 어려움 절차적 프로그래밍 언어의 종류 C UNIX 운영체제의 구현 이식성이 좋아 컴퓨터 기종에 관계없이 프로그램 작성 가능 ALGOL 알고리즘을 기술하기 위한 일반적인 표현 언어 COBOL 은행이나 대규모 회사들의 사무처리 목적으로 만든 언어 FORTRAN 과학 기술 계산용 언어","link":"/2020/05/07/Engineer_Information_Processing/ch16_%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%96%B8%EC%96%B4%ED%99%9C%EC%9A%A9/%EC%96%B8%EC%96%B4%ED%8A%B9%EC%84%B1%ED%99%9C%EC%9A%A9/%EC%A0%88%EC%B0%A8%EC%A0%81%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%96%B8%EC%96%B4/"},{"title":"SW개발 방법론 활용 - SW개발 방법론","text":"SW개발방법론선정 소프트웨어 개발 방법론의 개념 소프트웨어 개발, 유지보수 등에 필요한 여러 가지 일들의 수행 방법과 이러한 일들을 효율적으로 수행하려는 과정에서 필요한 각종 기법 및 도구를 체계적으로 정리하여 표준화한 것 소프트웨어 개발 방법론의 목적은 소프트웨어 생산성과 품질 향상 개발 방법론의 종류 구조적 방법론 정보공학 방법론 객체지향 방법론 컴포넌트 기반 방법론 애자일 방법론 제품 계열 방법론 1. 구조적 방법론 폭포수 모델과 같이 정형화된 분석 절차에 따라 사용자 요구사항을 파악하여 문서화하는 체계적인 분석 이론 프로그램 로직 중심의 방법론 쉬운 이해 및 검증 가능한 프로그램 코드 생성이 목적 2. 정보공학 방법론 정보시스템 개발에 필요한 관리절차와 작업기법을 체계화한 방법론 자료(Data) 중심의 방법론 대규모 정보시스템을 구축하는데 적합 3. 객체지향 방법론 현실 세계의 개체를 기계의 부품처럼 하나의 객체로 만들어, 객체들을 조립해서 필요한 소프트웨어를 구현하는 방법론 설계 시 자료와 자료에 가해지는 프로세서를 묶어 정의하고 관계를 규명 객체지향 방법론의 구성 요소에는 클래스, 객체, 메시지 특징 캡슐화 정보은닉 추상화 상속성 다형성 4. CBD; Componet Based Development 컴포넌트 기반 방법 기존의 시스템이나 소프트웨어를 구성하는 컴포넌트를 조합하여 하나의 새로운 애플리케이션을 만드는 방법론 컴포넌트의 재사용이 가능하여 시간과 노력을 절감 유지 보수 비용을 최소화하고 생산성 및 품질을 향상 5. Agile 애자일 방법론 고객의 요구사항 변화에 유연하게 대응할 수 있도록 일정한 주기를 반복하면서 개발 과정을 진행하는 방법론 소규모 프로젝트, 고도로 숙달된 개발자, 급변하는 요구사항에 적합 6. 제품 계열 방법론 특정한 제품에 적용하고 싶은 공통된 기능을 정의하여 개발하는 방법론 임베디드 소프트웨어를 만드는데 적합 입베디드 SW 디지털TV, 냉장고 등 해당 제품의 특정기능에 맞게 특화되어 제품 자체에 포함된 SW 영역공학 영역 분석, 영역 설계, 핵심 자산을 구현하는 영역 응용공학 제품 요구 분석, 제품 설게, 제품을 구현하는 영역 영역공학과 응용공학의 연계를 위해 제품의 요구사항, 아키텍처, 조립 생산이 필요 소프트웨어 개발 방법론 결정 프로젝트 관리와 재사용 현황을 소프트웨어 개발 방법론에 반영하고, 확정된 소프트웨어 생명 주기와 개발 방법론에 맞춰 소프트웨어 개발 단계, 활동, 작업, 절차 등을 정의하는 것 소프트웨어 개발 방법론 결정 절차 프로젝트 관리와 재사용 현황을 소프트웨어 개발 방법론에 반영 개발 단계별 작업 및 절차를 소프트웨어 생명 주기에 맞춰 수립 결정된 소프트웨어 개발 방법론의 개발 단계별 활동 목적, 작업 내용, 산출물에 대한 매뉴얼 작성","link":"/2020/05/02/Engineer_Information_Processing/ch18_%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4%EA%B0%9C%EB%B0%9C%EB%B0%A9%EB%B2%95%EB%A1%A0/%EB%B0%A9%EB%B2%95%EB%A1%A0%EC%84%A0%EC%A0%95/SW%EA%B0%9C%EB%B0%9C%EB%B0%A9%EB%B2%95%EB%A1%A0/"},{"title":"SW개발 방법론 활용 - SW 생명주기 모델","text":"SW개발방법론활용 SW개발방법론선정 소프트웨어 개발 생명주기 모델의 개념과 모델 종류별 특징을 이해 정형화된 개발방법론의 특징을 고려하여 응용 소프트웨어 특성에 맞는 개발방법론을 선정 소프트웨어 공학기술의 요구사항 분석 기법인 요구 공학 방법론을 이해 소프트웨어 비용 산정 모델의 종류와 특징을 이해 용어사전 소프트웨어 개발 생명 주기 타당성검토 -&gt; 분석 -&gt; 설계 -&gt; 개발 -&gt; 테스트 -&gt; 운영 -&gt; 유지보수 -&gt; 폐기단계의 생명주기를 가짐 요구공학 요구사항을 정의하고, 문서화, 관리하는 프로세스 Software Life Cycle 소프트웨어 개발 생명주기 개념 소프트웨어를 어떻게 개발할 것인가에 대한 추상적 표현으로 순차적 또는 병렬적 단계로 나눈 것 소프트웨어 생명주기를 표현하는 형태 소프트웨어 개발 생명주기 타당성검토 -&gt; 분석 -&gt; 설계 -&gt; 개발 -&gt; 테스트 -&gt; 운영 -&gt; 유지보수 -&gt; 폐기 개발자는 문제의 유형이나 개발 방법 등에 따라 특정 모델을 선택 소프트웨어 생명주기 모델 종류 폭포수 모델 프로토타입 모델 나선형 모델 애자일 모델 1. Waterfall Model 폭포수 모델 각 단계를 확실히 완료한 후 그 결과를 검토하고 승인 과정을 거친 후 다음 단계를 진행하는 개발 방법론 고전적 라이프 사이클 패러다임이라고 하며, 개발 과정의 앞 단계가 완료되어야만 다음 단계로 넘어갈 수 있는 선형 순차적 모형 2. Prototype Model 프로토타입 모델 사용자 요구사항을 정확히 파악하기 위해 실제 개발될 소프트웨어에 대한 프로토타입을 만들어 최종 결과물을 예측하는 모형 시제품은 발주자나 개발자 모두에게 공동의 참조 모델을 제공 최종 결과물이 만들어지기 전에 의뢰자가 최종 결과물의 일부 또는 모형을 볼 수 있음 추후 구현 단계에성의 구현의 골격이 됨 소프트웨어 개발이 완료된 시점에서 오류가 발견되는 폭포수 모형의 단점을 보완하기 위한 모형 3. Spiral Model 나선형 모델 보헴이 제안한 것으로, 폭포수 모형과 프로토타입 모형의 장점에 위험 분석 기능을 추가한 모형 나선을 따라 돌 듯이 여러 번의 소프트웨어 개발 과정을 거쳐 점진적으로 완벽하게 소프트웨어를 개발하는 것으로 점진적 모형이라고도 함 개발 순서 계획 및 정의 -&gt; 위험 분석 -&gt; 공학적 개발 -&gt; 고객평가 소프트웨어를 개발하면서 발생할 수 있는 위험을 관리하고 최소화하는 것이 목적 비용이 많이 들고 시간이 오래 걸리는 대규모 시스템 구축에 적합함 4. Agile Model 애자일 모델 애자일은 ‘민첩한’, '기민한’이라는 의미 스프린트 또는 이터레이션이라고 불리는 짧은 개발 주기를 반복하며 개발과정 진행 각 개발주기마다 만들어지는 결과물에 대한 고객의 평가와 요구를 적극적으로 수용 소규모 프로젝트, 고도로 숙달된 개발자, 급변하는 요구사항에 적합 애자일 개발 핵심 4가지 프로세스와 도구보다 개인과 그들의 협업에 더 가치를 둔다. 포괄적인 문서화보다 제대로 작동하는 소프트웨어에 더 가치를 둔다. 계약 협상보다 고객과의 협력에 더 가치를 둔다. 계획에 따르기보다 변화에 대응하는 것에 더 가치를 둔다. 개발 모형 SCRUM 매일 정해진 시간에 정해진 장소에서 짧은 시간의 개발을 하는 팀을 위한 프로젝트 관리 중심의 방법론 30일 마다 동작 가능한 제품을 제공하는 스프린트(Sprint)를 중심으로 한다. Backlog : 제품과 프로젝트에 대한 요구사항 Sprint : 30일 단위 반복(Iteration)의 짧은 개발기간으로 분리하여 반복적 수행 스크럼미팅 : 매일15분 정도 미팅으로 오늘과 내일의 해야 할 일 계획 수립 스크럼마스터 : 프로젝트 리더, 스크럼 수행 시 문제 인식 및 해결하고자 노력 XP : eXtreme Programming 의사소통 개선과 즉각적인 피드백에 의한 단순한 코딩으로 SW품질을 높이기 위한 방법론 1~3주 반복(Iteration) 5가지 갗치 용기 단순성 의사소통 피드백 존경 Kanban Lean 도요타 생산시스템을 재정립한 경영 방법론인 Lean 시스템의 품질기법을 소프트웨어 개발에 적용한 개발 방법론 낭비요소 제거를 통한 프로세스 향상이 목적 7가지 원칙 낭비제거 품질 내재화 지식 창출 늦은 확정 빠른 인도 사람 존중 전체 최적화 Crystal ASD : Adaptive Software Development FDD : Feature Driven Development DSDM : Dynamic System Development Method DAD : Disciplined Agile Delivery","link":"/2020/05/02/Engineer_Information_Processing/ch18_%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4%EA%B0%9C%EB%B0%9C%EB%B0%A9%EB%B2%95%EB%A1%A0/%EB%B0%A9%EB%B2%95%EB%A1%A0%EC%84%A0%EC%A0%95/SW%EC%83%9D%EB%AA%85%EC%A3%BC%EA%B8%B0%EB%AA%A8%EB%8D%B8/"},{"title":"SW개발 방법론 활용 - 비용 산정 모델","text":"SW개발방법론선정 소프트웨어 비용 산정의 개념 소프트웨어의 개발 규모를 소요되는 인원, 자원, 기간 등으로 확인하여 실행 가능한 계획을 수립하기 위해 필요한 비용을 예측하는 과학적이고 합리적인 활동 비용산정을 통해 발주자는 소프트웨어의 합리적인 가격을 확인할 수 있고 개발자는 개발에 필요한 정당한 비용 요구 가능 산정기법 종류 하향식 산정기법 상향식 산정기법 소프트웨어 비용 결정 요소 프로젝트 요소 제품 복잡도 시스템 크기 요구되는 신뢰도 일정기간 내 주어진 조건하에서 프로그램이 필요한 기능을 수행하는 척도 자원 요소 인적자원 하드웨어 / 소프트웨어 자원 생산성 요소 개발자 능력 개발자 전문지식과 경험, 이해도, 창의력 개발 기간 산정기법의 종류 1. 하향식 산정기법 과거의 유사 경험을 바탕으로 회의를 통해 산정하는 비과학적인 기법 종류 전문가 감정 기법 조직 내 경험이 있는 2명 이상의 전문가에게 비용 산정을 의뢰하는 산정기법으로 개인적이고 주관적 델파이 기법 전문가들의 편견이나 분위기에 지배되지 않도록 한 명의 조정자와 여러 전문가의 의견을 종합하여 비용을 산정 2. 상향식 산정기법 세부적인 작업 단위별로 비용을 산정한 후 합산 LOC 기법 : Line Of Code 각 기능의 원시 코드 라인 수의 비관치, 낙관치, 기대치를 측정하여 예측치 구함 공식 노력 = 개발기간 x 투입인원 = LOC/1인당 월평균 코드 라인 수 개발 비용 = 노력 x 1인당 월평균 인건비 생산성 = LOC/노력 Effort Per Task 기법 각 기능을 구현시키는데 필요한 노력을 생명 주기의 각 단계별로 선정하며, LOC보다 더 정확함 3. 수학식 산정기법 경험적 추정 기법 또는 실험적 추정 기법, 개발 비용 산정의 자동화가 목표 비용을 자동으로 산정하기 위해서 사용되는 공식은 과거 유사한 프로젝트를 기반으로 경험적으로 유도된 것 수학적 산정기법 종류 COCOMO 모형 Putnam 모형 기능 점수 FP : Function Point 1. COCOMO; COnstructive COst MOdel 모형 보헴이 제안한 것으로 원시 프로그램의 규모인 LOC(원시 코드 라인수)에 의한 비용 산정 기법 규모와, 소프트웨어 종류에 따라 조직형, 반분리형, 내장형으로 분류 Organic Model 조직형 5만라인의 소프트웨어로 사무처리용, 업무용, 과학용 응용 소프트웨어에 적합 노력(MM) = 2.4 X (KDSI)^1.05 개발기간(TDEV) = 2.5 X (MM)^0.38 Semi-Detached Model 반분리형 조직형과 내장형의 중간형 트랜잭션 처리시스템, 운영체제, DBMS등 30만 라인 이하에 적합 Embedded Model 내장형 초대형 규모로 30만 라인 이상 MM = 3.6 X (KDSI)^1.20 TDEV = 2.5 X (MM)^0.32 KSDI : Kilo Delivered Source Intruction 전체 라인수를 1,000 단위로 묶은 것 2. Putnam 모형 소프트웨어 생명 주기의 전 과정 동안에 사용될 노력의 분포를 가정해주는 모형 시간에 따른 함수로 표현되는 Rayleigh-Norden 곡선의 노력 분포도를 기초로함 대형 프로젝트의 노력 분포 산정에 이용되는 기법 개발 기간이 늘어날수록 프로젝트 적용 인원의 노력이 감소함 3. 기능 점수 FP 모형 알브레히트가 제안한 것으로, 소프트웨어 기능을 증대 시키는 요인(입력, 출력, 질의, 파일, 인터페이스의 개수)별로 단순, 보통, 복잡 가중치 부여 요인별 가중치를 합산하여 총 기능 점수를 산출하며 총 기능 점수와 영향도를 이용하여 기능 점수를 구한 후 이를 이용해서 비용을 산정하는 기법 기능점수 = 총 기능 점수 x [0.65 + (0.1 x 총 영향도)] 자동화 추정 도구 비용 산정의 자동화를 위해 개발된 도구로는 SLIM 과 ESTIMACS가 있음 SLIM Payleigh-Norden 곡선과 Putnam 예측 모델을 기초로 하여 개발된 자동화 추정 도구 ESTIMACS 다양한 프로젝트와 개인별 요소를 수용하도록 FP모형을 기초로 하여 개발된 자옹화 추정 도구","link":"/2020/05/02/Engineer_Information_Processing/ch18_%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4%EA%B0%9C%EB%B0%9C%EB%B0%A9%EB%B2%95%EB%A1%A0/%EB%B0%A9%EB%B2%95%EB%A1%A0%EC%84%A0%EC%A0%95/%EB%B9%84%EC%9A%A9%EC%82%B0%EC%A0%95%EB%AA%A8%EB%8D%B8/"},{"title":"SW개발 방법론 활용 - 핵심정리","text":"SW개발방법론선정 1. 소프트웨어 생명주기 모델 소프트웨어를 어떻게 개발할 것인가에 대한 추상적 표현으로 순차적 또는 병렬적 단계로 나눈 것 소프트웨어 개발 생명주기 타당성검토 -&gt; 분석 -&gt; 설계 -&gt; 개발 -&gt; 테스트 -&gt; 운영 -&gt; 유지보수 -&gt; 폐기 소프트웨어 생명주기 모델 종류 폭포수 모델 프로토타입 모델 나선형 모델 애자일 모델 2. 소프트웨어 개발 방법론 소프트웨어 개발, 유지보수 등에 필요한 여러 가지 일들의 수행 방법과 이러한 일들을 효율적으로 수행하려는 과정에서 필요한 각종 기법 및 도구를 체계적으로 정리하여 표준화한 것 개발 방법론의 종류 구조적 방법론 정보공학 방법론 객체지향 방법론 컴포넌트 기반 방법론 애자일 방법론 제품 계열 방법론 3. 요구공학 방법론 요구사항의 지속적인 중요성 증대와 채계적인 관리의 필요성이 대두되어 시스템의 요구사항을 정의하고, 문서화하고, 관리하는 프로세스 요구공학 프로세스 도출 분석 명세 확인/검증 4. 비용산정 모델 소프트웨어의 개발 규모를 소요되는 인원, 자원, 기간 등으로 확인하여 실행 가능한 계획을 수립하기 위해 필요한 비용을 예측하는 과학적이고 합리적인 활동 산정기법 종류 하향식 산정기법 전문가 감정 기법 델파이 기법 상향식 산정기법 LOC 기법 Effort Per Task 기법 수학적 산정기법 COCOMO 모형 Putnam 모형 FP 모형","link":"/2020/05/02/Engineer_Information_Processing/ch18_%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4%EA%B0%9C%EB%B0%9C%EB%B0%A9%EB%B2%95%EB%A1%A0/%EB%B0%A9%EB%B2%95%EB%A1%A0%EC%84%A0%EC%A0%95/%ED%95%B5%EC%8B%AC%EC%A0%95%EB%A6%AC/"},{"title":"SW개발 방법론 활용 - 소프트웨어 개발 프레임워크","text":"SW개발방법론 테일러링 소프트웨어 개발 프레임워크 소프트웨어 개발 프레임워크의 개념 소프트웨어 개발에 공통적으로 사용되는 구성 요소와 아키텍처를 일반화하여 손쉽게 구현할 수 있도록 여러 가지 기능들을 제공해 주는 반제품 형태의 소프트웨어 시스템 프레임워크 사전적으로 뼈대, 골조를 의미하며 소프트웨어에서는 특정 기능을 수행하기 위해 필요한 클래스나 인터페이스 등을 모아둔 집합체 프레임워크의 주요 기능에는 예외 처리, 트랜잭션 처리, 메모리 공유, 데이터 소스 관리, 쿼리 서비스, 로깅 서비스, 인증 서비스 등 프레임워크 특징 특정 개념들의 추상화를 제공하는 여러 클래스와 컴포넌트로 구성 추상적인 개념들이 문제를 해결하기 위해 같이 작업하는 방법 정의 컴포넌트들의 재사용이 가능 높은 수준에서 패턴들을 조작 종류 1. 스프링 프레임워크(Spring Framework) JAVA 플랫폼을 위한 오픈 소스 경량형 애플리케이션 프레임워크 J2EE에서 제공하는 대부분의 지능을 지원 DB처리를 위한 JDBC, iBatis, Hibernate, JPA 등 라이브러리와 연동 지원 전자정부 표준 프레임워크의 기반이 되는 기술 2. 전자정부 표준 프레임워크 우리나라의 공공부분 정보화 사업 시 효율적인 정보시스템 구축을 지원하기 위해 필요한 기능 및 아키텍처를 제공하는 프레임워크 개발 프레임워크의 표준 정립으로 응용 소프트웨어의 표준화, 품질 및 재사용성의 향상을 목적으로 함 오픈 소스 기반의 범용화가 되고 공개된 기술으 활용함으로써 특정 업체의 종속성을 배제하고 사업별 공통 컴포넌트의 중복 개발 방지 3. 스트럿츠 프레임워크 STRUTS Framework JAVA기반의 JSP만을 위한 프레임워크 다양한 운영체제에서 활용 가능 오픈소스이기 때문에 개발에 필요한 부분을 수정하여 사용 UI기반의 프레임워크 4. 닷넷프레임워크(.NET Framework) Windows 프로그램 개발 및 실행 환경을 제공하는 프레임워크 Microsoft 사에서 통합 인터넷 전략을 위해 개발 코드 실행을 관리하는 CLR(Common Language Runtime)이라는 가상머신 상에서 작동 메모리 관리, 유형 및 메모리 안전성, 보안, 네트워크 작업 등 여러가지 서비스를 제공 5. 앵귤러 JS(Angular JS) 자바스크립트 기반의 프레임워크 앵귤러 JS의 데이터 모델은 단순 자바스크립트 객체로 재사용이 쉬운 정적인 UI컴포넌트로 구성 코드의 길이를 더욱 단순화 HTML, CSS 개발자와 자바스크립트 개발자를 명확하게 분리 6. 장고 프레임워크(Django Framework) Python으로 작성된 오픈 소스 웹 애플리케이션 프레임워크 MVC(Model-View-Controller)패턴 기반 프레임워크 ORM(Object Relational Mapping)기능 지원 수윈 DB관리를 위해 프로젝트를 생성하면서 관리자 기능을 제공 쉬운 URL 파싱 기능 지원","link":"/2020/05/03/Engineer_Information_Processing/ch18_%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4%EA%B0%9C%EB%B0%9C%EB%B0%A9%EB%B2%95%EB%A1%A0/%EB%B0%A9%EB%B2%95%EB%A1%A0%ED%85%8C%EC%9D%BC%EB%9F%AC%EB%A7%81/%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4%EA%B0%9C%EB%B0%9C%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC/"},{"title":"SW개발 방법론 활용 - 요구공학 방법론","text":"SW개발방법론선정 요구공학의 개념 시스템의 요구사항을 정의하고, 문서화하고, 관리하는 프로세스 요구사항의 지속적인 중요성 증대 요구사항에 관한 체계적인 관리의 필요성 대두 요구공학의 목적 이해관계자 사이에 효과적인 의사소통 수단을 제공하고 요구사항에 대한 공통 이해를 설정 요구사항 손실 방지 및 에러 감지로 불필요한 비용을 절감하고 요구사항 변경 추적을 가능하게 함 요구공학 프로세스 기능은 없음 1. Requirement Elicitation 요구사항 도출 소프트웨어 가 해결해야할 문제를 이해하고 요구사항이 어디에 있고, 어떻게 수집할 것인가와 관련 활용기법 인터뷰 시나리오 작업분석 BRP : Business Process Reengineering RFP : Request for Proposla 벤치마킹 2. Requirement Aanlysis 요구사항 분석 요구사항들 간의 상충을 해결하고, 소프트웨어의 범위를 파악하면 소프트웨어가 환경과 어떻게 상호작용하는지 이해 활용기법 구조적 분석 DFD : Data Flow Diagram Data Dictionary ERD : Entity Relationship Diagram Use Case 기반 분석 UML 모델링 3. Requirement Specification 요구사항 명세 체계적으로 검토, 평가, 승인될 수 있는 문서 작성 시스템 정의, 시스템 요구사항, 소프트웨어 요구사항 작성 활용기법 ER 모델링 FSM : Finite State Machine, 유한 상태 기계 SADT : Structered Analysis and Design Technique, 구조화 해석 설계 기법 4. Validation/Verification 요구사항 확인/검증 분석가가 요구사항을 이해 했는지 확인(Validation) 요구사항 문서가 일관성 있고 완전한지 검증(Verification) 베이스라인으로 설정하는 활동 이해관계자들이 문서 검토 및 형상 관리 수행 리소스가 요구사항에 할당되기 전에 문제 파악을 위한 검증 수행 활용기법 검토 프로토타이핑 모델 검증 인수테스트","link":"/2020/05/02/Engineer_Information_Processing/ch18_%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4%EA%B0%9C%EB%B0%9C%EB%B0%A9%EB%B2%95%EB%A1%A0/%EB%B0%A9%EB%B2%95%EB%A1%A0%EC%84%A0%EC%A0%95/%EC%9A%94%EA%B5%AC%EA%B3%B5%ED%95%99%EB%B0%A9%EB%B2%95%EB%A1%A0/"},{"title":"프로그래밍언어활용 - 선언형 언어","text":"프로그래밍언어활용 선언형 언어의 개념 명령어 언어와 반대 프로그램이 수행해야 할 문제를 기술하는 언어 목표를 명시하고 알고리즘을 명시하지 않음 함수형 언어 수학적 함수를 조합하여 문제를 해결하는 언어 적용형 언어라고 불림 재귀호출이 자주 이용되고 병렬처리에 유리 논리형 언어 기호 논리학에 기반을 둔 언어 선언적 언어라고 불림 반복문이나 선택문을 사용하지 않으며 비절차적 언어 선언형 언어의 특징 알고리즘에 집중하여 이미 만들어진 것을 선언을 통해 사용 구체적인 작동순서를 나열하지 않기 때문에 오류가 적음 가독성이나 재사용이 좋음 선언형 언어의 종류 LISP 인공지능 분야에 사용되는 언어 기본 구조가 연결 리스트 구조 PROLOG 논리학을 기초로 한 고급 언어 추론이나 리스트 처리등에 사용 Haskell 함수형 언어들을 통합 정리하며 만든 일반적인 순수 함수형 프로그램 코드가 간결하고 에러 발생 가능성이 낮음 SQL 관계형 데이터베이스 관리 시스템의 데이터를 관리하기 위해 설계된 특수 목적의 프로그래밍언어 HTML 웹페이지 문서를 만들기 위해 사용되는 언어 XML 새로운 태그를 정의할 수 있으며, 문서의 내용과 이를 표현하는 방식이 독립적임","link":"/2020/05/07/Engineer_Information_Processing/ch16_%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%96%B8%EC%96%B4%ED%99%9C%EC%9A%A9/%EC%96%B8%EC%96%B4%ED%8A%B9%EC%84%B1%ED%99%9C%EC%9A%A9/%EC%84%A0%EC%96%B8%ED%98%95%EC%96%B8%EC%96%B4/"},{"title":"DB구축관리 - DB 관련 신기술","text":"IT프로젝트정보시스템구축관리 DB구축관리 데이터베이스와 관련된 IT신기술의 종류와 특징을 이해 데이터베이스 관리 기능으로 회복과 병행제어의 개념 이해 데이터베이스 표준화의 개념과 구성요소를 이해 용어사전 - 데이터 표준화 - 시스템을 구성하는 데이터 요소의 명칭, 정의, 형식, 규칙에 대한 원칙을 수립하고 적용하는 것 DB 관련 신기술 1. Big Data 빅데이터 기존의 관리 방법이나 분석체계로는 처리하기 어려운 막대한 양의 정형 또는 비정형 데이터의 집합으로 스마트 단말기의 빠른 확산, 소셜 네트워크 서비스의 활성화, 사물 네트워크의 확대로 데이터 폭발이 가속화됨 3가지 특징 Volume 데이터의 양 Velocity 데이터 생성 속도 Variety 형탱의 다양성 2. Broad Data 브로드 데이터 다양한 채널에서 소비자의 상호 작용을 통해 생성된 기업 마케팅에 있어 효율적이고 다양한 데이터이며, 이전에 사용하지 않거나 알지 못했던 새로운 데이터나 기존 데이터에 가치가 더해진 데이터 다양한 정보를 뜻하는 것으로 소비자의 SNS 활동이나 위치 정보 등이 이에 속함 3. Digital Archiving 늘어나는 정보 자원의 효율적인 관리와 이용을 위해 디지털 정보 자원을 장기적으로 보존하기 위한 작업 아날로그 콘텐츠는 디지털로 변환한 후 압축해서 저장하고, 디지털 콘텐츠도 체계적으로 분류하고 메타 데이터를 만들어 DB화 하는 작업 4. Meta Data 메타 데이터 일련의 데이터를 정리하고 설명해주는 데이터 메타 데이터는 여러 용도로 사용되나 주로 빠르게 검색하거나 내용을 간략화하고 체계적으로하기 위해 많이 사용 5. Data Diet 데이터 다이어트 데이터를 삭제하는 것이 아니라 압축하고, 중복된 정보는 중복을 배재하고 새로운 기준에 따라 나누어 저장하는 작업 인터넷과 이동통신 이용이 늘면서 각 기관/기업의 데이터베이스에 쌓인 방대한 정보를 효율적으로 관리하기 위해 대두된 방안으로 같은 단어가 포함된 데이터들을 한 곳에 모다 두되 필요할 때 제대로 찾아내는 체계를 갖추는 것이 필요 6. Hadoop 하둡 오픈 소스를 기반으로 한 분산 컴퓨팅 플랫폼 7. Tajo 타조 오픈 소스 기반 분산 컴퓨팅 플랫폼인 아파치 하둡 기반의 분산 데이터 웨어하우스 프로젝트로 우리나라가 주도하여 개발 데이터웨어하우스 자료와 창고의 합성어로기업의 의사결정과정에 효과적으로 사용할 수 있또록 에러시스템에 분산되어 있는 데이터를 주체별로 통합축적해 놓은 데이터베이스 대규모 데이터 처리와 실시간 상호 분석 모두 사용 가능","link":"/2020/05/01/Engineer_Information_Processing/ch19_IT%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8%EC%A0%95%EB%B3%B4%EC%8B%9C%EC%8A%A4%ED%85%9C%EA%B5%AC%EC%B6%95%EA%B4%80%EB%A6%AC/DB%EA%B5%AC%EC%B6%95%EA%B4%80%EB%A6%AC/DB%EA%B4%80%EB%A0%A8%EC%8B%A0%EA%B8%B0%EC%88%A0/"},{"title":"SW개발 방법론 활용 - 핵심정리","text":"SW개발방법론 테일러링 1. 소프트웨어 개발 표준 소프트웨어 개발 단계의 품질 관리에 사용되는 국제 표준 ISO/IEC 12207 국제 표준화 기구에서 제공하는 소프트웨어 생명주기 프로세스 표준 기본 생명 주기, 지원 생명 주기, 조직 생명 주기 프로세스 CMMI 소프트웨어 개발 조직의 업무 능력 및 조직의 성숙도 평가 모델 성숙도 5단계 초기, 관리, 정의, 정량적 관리, 최적화 SPICE 소프트웨어 프로세스를 평가 및 개선하는 국제 표준 수행 능력 6단계 불완전, 수행, 관리, 확립, 예측, 최적화 2. 테일러링 기준 소프트웨어 개발 방법론 테일러링은 프로젝트 상황 및 특성에 맞도록 개발 방법론의 절차, 사용기법 등을 수정 및 보완하는 작업 소프트웨어 개발 방법론 테일러링 고려사항 내부적 기준 : 목표환경, 요구사항, 프로젝트 규모, 보유기술 외부적 기준 : 법적 제약사항, 표준 품질기준 소프트웨어 개발 방법론 테일러링 기법 프로젝트 규모와 복잡도, 프로젝트 구성원, 팀내 방법론 지원, 자동화에 따른 테일러링 3. 소프트웨어 개발 프레임워크 소프트웨어 개발에 공통적으로 사용되는 구성 요소와 아키텍처를 일반화하여 손쉽게 구현할 수 있도록 여러 가지 기능들을 제공해 주는 반제품 형태의 소프트웨어 시스템 소프트웨어 개발 프레임워크 스프링 프레임워크 전자정부 표준 프레임워크 스트럿츠 프레임워크 닷넷 프레임워크 앵귤러 JS 장고 프레임워크","link":"/2020/05/03/Engineer_Information_Processing/ch18_%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4%EA%B0%9C%EB%B0%9C%EB%B0%A9%EB%B2%95%EB%A1%A0/%EB%B0%A9%EB%B2%95%EB%A1%A0%ED%85%8C%EC%9D%BC%EB%9F%AC%EB%A7%81/%ED%95%B5%EC%8B%AC%EC%A0%95%EB%A6%AC/"},{"title":"SW개발 방법론 활용 - SW 개발 표준","text":"SW개발방법론 테일러링 응용 소프트웨어 개발에 사용할 표준으로 활동 및 절차 수행에 필요한 기법과 표준, 산출물 표준 양식 및 작성 기법, 적용 도구를 정립 테일러링된 적용 개발 방법론에 따른 작성 산출물 유형 확정 소프트웨어 개발 프레임워크의 개념과 종류별 특징을 이해 용어사전 Tailoring 테일러링 ‘재단, 양복업’ 으로 표준을 기반으로 실제 업무에서 여건에 맞게 수정/보완 하는 것 SW 개발 표준의 개념 소프트웨어 개발 단계의 품질 관리에 사용되는 국제 표준 대표적인 국제표준 ISO/IEC 12207 CMMI SPICE 종류 1. ISO/IEC 12207 ISO; International Organization for Standardiztaion, 국제표준화기구에서 소프트웨어 개발, 운영, 유지보수 등을 체계적으로 관리하기 위한 소프트웨어 생명주기 프로세스 표준을 제공 소프트웨어와 관련된 조직과 사람, 소프트웨어 획득자, 공급자, 개발자, 운영자, 유지보수자, 품질보증관리자, 사용자 등의 이해관계자들이 각자의 입장에서 수행해야 할 일을 정의하고 지속적으로 개선시키기 위한 활동 기본 생명 주기 프로세스 획득 프로세스 공급 프로세스 개발 프로세스 운영 프로세스 유지보수 프로세스 지원 생명 주기 프로세스 문서화 프로세스 품질보증 프로세스 형상관리 프로세스 검증 프로세스 확인 프로세스 문제해결 프로세스 활동 검토 프로세스 유지보수 프로세스 조직 생명 주기 프로세스 기반구조 프로세스 관리 프로세스 개선 프로세스 훈련 프로세스 2. CMMI; Capability Maturity Model Integration 능력 성숙도 모델 통합 소프트웨어 개발 조직의 업무 능력 및 조직의 성숙도 평가 모델 CMMI 성숙도 5단계 단계 프로세스 특징 초기 - 작업자 능력에 따라 성공 여부 결정 관리 규칙화된 프로세스 특정한 프로젝트 내의 프로세스 정의 및 수행 정의 표준화된 프로세스 조직의 표준 프로세스를 활용하여 업무 수행 정량적 관리 예측 가능한 프로세스 프로젝트를 정량적으로 관리 및 통제 최적화 지속적 개선 프로세스 프로세스 역량 향상을 위해 지속적인 프로세스 개선 3. SPICE; Software Process Improvement and Capability dEtermination 소프트웨어 처리 개선 및 능력 평가 기준 소프트웨어 프로세스를 평가 및 개선하는 국제표준 ISO/IEC 15504 목적 프로세스 개선을 위해 개발 기관이 스스로 평가하는 것 요구조건의 만족여부를 개발 조직이 스스로 평가하는 것 계약 체결을 위해 수탁 기관의 프로세스를 평가하는 것 5개의 프로세스 범주와 40개의 세부 프로세스로 구성 고객- 공급자 프로세스 소프트웨어를 개발하여 고객에게 전달하는 것을 지원 소프트웨어의 정확한 운용 및 사용을 위한 프로세스로 구성 인수, 공급, 요구 도출, 운영 프로세스 수 : 10개 공학 프로세스 시스템과 소프트웨어 제품의 명세화, 구현, 유지보수하는 프로세스로 구성 개발, 소프트웨어 유지보수 프로세스 수 : 9개 지원 프로세스 소프트웨어 생명 주기에 다른 프로세스에 의해 이용되는 프로세스로 구성 문서화, 형상, 품질 보증, 검증, 확인, 리뷰, 감사, 품질문제해결 프로세스 수 : 8개 관리 프로세스 소프트웨어 생명 주기에서 프로젝트 관리자에 의해 사용되는 프로세스로 구성 관리, 프로젝트 관리, 품질 및 위험 관리 프로세스 수 : 4개 조직 프로세스 조직의 업무 목적 수립과 조직의 업무 목표 달성을 위한 프로세스로 구성 조직배치, 개선 활동 프로세스, 인력 관리, 기반 관리, 측정도구, 재사용 프로세스 수 : 9개 프로세스 수행 능력 6개 불완전 Incomplete 프로세스가 구현되지 않았거나 목적을 달성핮지 못한 단계 수행 Performed 프로세스가 수행되고 목적이 달성된 단계 관리 Managed 정의된 자원의 한도 내에서 그 프로세스가 작업 산출물을 인도하는 단계 확립 Established 소프트웨어 공학 원칙에 기반하여 정의된 프로세스가 수행되는 단계 예측 Predictable 프로세스가 목적 달성을 위해 통제되고, 양적인 측정을 통해 일관되게 수행되는 단계 최적화 Optimizing 프로세스 수행을 최적화하고, 지속적인 개선을 통해 업무 목적을 만족시키는 단계","link":"/2020/05/03/Engineer_Information_Processing/ch18_%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4%EA%B0%9C%EB%B0%9C%EB%B0%A9%EB%B2%95%EB%A1%A0/%EB%B0%A9%EB%B2%95%EB%A1%A0%ED%85%8C%EC%9D%BC%EB%9F%AC%EB%A7%81/SW%EA%B0%9C%EB%B0%9C%ED%91%9C%EC%A4%80/"},{"title":"SW개발 방법론 활용 - 테일러링 기준","text":"SW개발방법론 테일러링 테일러링 기준 소프트웨어 개발 방법론 테일러링의 개념 소프트웨어 개발 방법론 테일러링은 프로젝트 상황 및 특성에 맞도록 개발 방법론의 절차, 사용기법 등을 수정 및 보완하는 작업 소프트웨어 개발 방법론 테일러링 수행절차 프로젝트 특징 정의 표준프로세스 선정 및 검증 상위 수준의 커스터마이징 세부 커스터마이징 테일러링 문서화 소프트웨어 개발 방법론 테일러링 고려사항 내부적 기준 목표환경 시스템의 개발 환경과 유형이 서로 다른 경우 테일러링 필요 요구사항 프로젝트의 생명 주기 활동에서 개발, 운영, 유지보수 등 프로젝트에서 우선적으로 고려할 요구사항이 서로 다른 경우 필요 프로젝트 규모 비용, 인력, 개발 기간 등 프로젝트 규모가 서로 다른 경우 보유 기술 프로세스, 개발 방법론, 산출물, 인력의 숙련도 등이 다른 경우 외부적 기준 법적 제약사항 프로젝트별로 적용될 IT Compliance가 서로 다른 경우 IT Compliance IT분야에서 내/외 부적으로 반드시 지켜야 하는 법칙 규제사항이나 지침 표준 품질기준 금융, 제도, 의료 등 업종별 표준 품질 기준이 서로 다른 경우 테일러링이 필요 소프트웨어 개발 방법론 테일러링 기번 프로젝트 규모와 복잡도에 따른 테일러링 프로젝트 규모를 프로젝트 기간, 작업범위, 참여 인원 등에 따라 대/중/소로 구분하고, 프로젝트 업무 난이도에 따라 복잡도를 상/중/하로 구분하는 기법 프로젝트 구성원에 따른 테일러링 프로젝트에 참여하는 구성원들의 기술적 숙련도와 방법론의 이해 정도를 확인하여 테일러링 수준을 결정하는 기법 팀내 방법론 지원에 따른 테일러링 프로젝트 수행 시 각 팀 별로 방법론 담당 인력을 배정하여 팀의 방법론 교육과 프로젝트 전체의 방법론 운영을 위한 의사소통을 담당하도록 인력을 구성하는 기법 자동화에 따른 테일러링 프로젝트 수행 시 작업 부하를 줄이기 위해 중간 단계에서의 산출물을 자동화 도구를 사용하여 산출할 수 있도록 지원하는 기법","link":"/2020/05/03/Engineer_Information_Processing/ch18_%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4%EA%B0%9C%EB%B0%9C%EB%B0%A9%EB%B2%95%EB%A1%A0/%EB%B0%A9%EB%B2%95%EB%A1%A0%ED%85%8C%EC%9D%BC%EB%9F%AC%EB%A7%81/%ED%85%8C%EC%9D%BC%EB%9F%AC%EB%A7%81%EA%B8%B0%EC%A4%80/"},{"title":"DB구축관리 - DB 관리 기능","text":"IT프로젝트정보시스템구축관리 DB구축관리 DB관리기능 회복 1. Recovery 회복의 개념 트랜잭션들을 수행하는 도중에 장애가 발생하여 데이터베이스가 손상되었을 때 손상되기 이전의 정상 상태로 복구하는 작업 트랜잭션 데이터베이스의 상태를 변환시키는 하나의 논리적 기능을 수행하기 위한 작업의 단위 또는 한꺼번에 모두 수행되어야 할 일련의 연산 2. 장애의 유형 트랜잭션 장애 입력 데이터 오류, 불명확한 데이터, 시스템 자원 요구의 과다등 트랜잭션 내부의 비정상적인 상황으로 인하여 프로그램 실행이 중지되는 현상 시스템 장애 데이터베이스에 손상을 입히지는 않으나 하드웨어 오동작, 소프트웨어의 손상, 교착 상태 등에 의해 모든 트랜잭션의 연속적인 수행에 장애를 주는 현상 미디어 장애 저장장치인 디스크 블록의 손상이나 디스크 헤드의 충돌 등에 의해 데이터베이스의 일부 또는 전부가 물리적으로 손상된 상태 3. Recovery Management 회복 관리기 회복관리기는 DBMS의 구성요소 트랜잭션 실행이 성공적으로 완료되지 못하면 트랜잭션이 데이터베이스에 생성했던 모든 변화를 취소(Undo)시키고 트랜잭션 수행 이전의 원래 상태로 복구하는 역할 메모리 덤프, 로그를 이용하여 회복을 수행 병행제어 1. Concurrency Control 병행제어의 개념 동시에 여러 개의 트랜잭션을 병행 수행할 때, 동시에 실행되는 트랜잭션들이 데이터베이스의 일관성을 파괴하지 않도록 트랜잭션 간의 상호작용을 제어하는 것 2. 병행제어의 목적 데이터베이스의 공유를 최대화 시스템의 활용도를 최대화 데이터베이스의 일관성을 유지 사용자에 대한 응답 시간을 최소화 3. 병행수행의 문제점 병행제어 기법에 의한 제어없이 트랜잭션들이 데이터베이스에 동시에 접근하도록 허용하는 경우 발생하는 문제점 문제점 설명 갱신분실 두 개 이상의 트랜잭션이 같은 자료를 공유하여 갱신할 때 갱신 결과의 일부가 없어지는 현상 비완료 의존성 하나의 트랜잭션 수행이 실패한 후 회복되기 전에 다른 트랜잭션이 실패한 갱신 결과를 참조하는 현상 모순성 두 개의 트랜잭션이 병행수행 될 때 원치않는 자료를 이용함으로써 발생하는 문제 연쇄 복귀 병행수행되던 트랜잭션들 중 어느 하나에 문제가 생겨 Rollback하는 경우 다른 트랜잭션도 함께 Rollback되는 현상","link":"/2020/05/01/Engineer_Information_Processing/ch19_IT%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8%EC%A0%95%EB%B3%B4%EC%8B%9C%EC%8A%A4%ED%85%9C%EA%B5%AC%EC%B6%95%EA%B4%80%EB%A6%AC/DB%EA%B5%AC%EC%B6%95%EA%B4%80%EB%A6%AC/DB%EA%B4%80%EB%A6%AC%EA%B8%B0%EB%8A%A5/"},{"title":"DB구축관리 - 핵심정리","text":"IT프로젝트정보시스템구축관리 DB구축관리 1. IT신기술 및 데이터베이스 기술 트렌드 정보 빅데이터 브로드 데이터 디지털 아카이빙 메타 데이터 데이터 다이어트 하둡 타조 2. 데이터베이스 관리기능 회복 트랜잭션들을 수행하는 도중에 장애가 발생하여 데이터베이스가 손상되었을 때 손상되기 이전의 정상 상태로 복구하는 작업 병행제어 동시에 여러 개의 트랜잭션을 병행 수행할 때, 동시에 실행되는 트랜잭션들이 데이터베이스의 일관성을 파괴하지 않도록 트랜잭션 간의 상호작용을 제어하는 것 3. 데이터베이스 표준화 시스템을 구성하는 데이터 요소의 명칭, 정의, 형식, 규칙에 대한 원칙을 수립하고 적용하는 것 데이터베이스 표준화 구성요소 데이터 표준 데이터 관리조직 데이터 표준화 절차","link":"/2020/05/01/Engineer_Information_Processing/ch19_IT%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8%EC%A0%95%EB%B3%B4%EC%8B%9C%EC%8A%A4%ED%85%9C%EA%B5%AC%EC%B6%95%EA%B4%80%EB%A6%AC/DB%EA%B5%AC%EC%B6%95%EA%B4%80%EB%A6%AC/%ED%95%B5%EC%8B%AC%EC%A0%95%EB%A6%AC/"},{"title":"HW구축관리 - 서버장비 운영","text":"IT프로젝트정보시스템구축관리 HW구축관리 서버장비 운영 요소 1. 서버 장비 운영 요소의 개념 정보처리시스템에 필요한 서버 장비 뿐만 아니라 데이터 저장 장치인 스토리지, 운영체제, 고가용성 장비, 보안 솔루션 등 정보 시스템 운영의 시작부터 끝까지 필요한 모든 것 2. 서버 소프트웨어 유형 서버 SW 유형 주요 기능 비고 운영체제(OS) 시스템에 대한 계정/성능/장애/구성/보안 관리 를 담당 Windwo Server, Unix, LINUX DBMS Data를 효과적이고, 효율적으로 관리하기 위한 관리 시스템 Oracle, MySQL, DB2 보안 솔루션 기밀성, 무결성, 가용성 등 백신ISW, IDS, IPS, Firewall WEB 운영 시스템 자원을 효율적으로 이용하기 위한 가상화 솔루션 Apache, WAS, JEJUS 3. 저장장치(스토리지 시스템) Secure OS 1. Secure OS 개념 기존의 운영체제에 내재된 보안 취약점을 해소하기 위해 보안 기능을 갖춘 커널을 추가하여 외부의 침입으로 부터 시스템 자원을 보호하는 운영체제 보안 커널은 보안 기능을 갖춘 커널을 의미하며, TCB 기반으로 참조 모니터의 개념을 구현하고 집행 보안 커널의 보호 대상은 주기억장치와 보조기억장치, 저장 데이터, 하드웨어 장치, 자료 구조, 명령어, 각종 보호 매커니즘 보호방법 논리적분리 프로세스 논리적 구역지정 물리적분리 특정장비만 사용토록 제한 암호적분리 내부 정보 암호화 시간적분리 프로세스 동시실행 방지 구현복잡도 암호적 &gt; 논리적 &gt; 시간적 &gt; 물리적 참조모니터 3가지 특징 Isolation 격리성 Verifiability 검증가능성 Completeness 완전성 2. Secure OS 보안 기능 구분 설명 식별 및 인증 각 접근 주체에 대한 안전하고 고유한 식별 인증 기능 임의적 접근 통제 소속 그룹 또는 개인에 따라 부여된 권한에 따라 접근 통제 DAC 또는 신분기반정책 강제적 접근 통제 접속 단말 및 접속방법, 권한, 요청 객체의 특성 등 여러보안 속성이 고려된 규칙에 따라 강제적으로 접근 통제 MAC 또는 규칙기반 정책 객체재사용보호 메모리에 기존 데이터가 남아있지 않도록 초기화하는 기능 완전한 조정 우회할 수 없도록 모든 접근 경로를 완전하게 통제하는 기능 신뢰 경로 비밀번호 변경 및 권한 설정 등과 같은 보안 작업을 위한 안전한 경로를 제공하는 기능 감사 및 감사기록 축소 모든 보안 관련 사건 및 작업을 기록한 후 보호하는 기능 3. 고가용성 1. High Availability 고가용성의 개념 긴 시간동안 안정적인 서비스 운영을 위해 장애 발생시 즉시 다른 시스템으로 대체 가능한 환경을 구축하는 메커니즘 가용성을 극대화 하는 방법 클러스터 두 대 이상의 서버를 하나의 서버처럼 운영하는 기술 이중화 시스템 오류로 데이터베이스 서비스중단이나 물리적 손상발생시 이를 복구하기 위해 동일한 데이터베이스를 복제하여 관리하는 것 2. 고가용성의 필요성 서비스 다운 타임을 최소화함으로써 가용성을 극대화 고가용성으로 기업의 비즈니스 연속성을 확보 기업의 신뢰도 및 경쟁력 향상","link":"/2020/04/30/Engineer_Information_Processing/ch19_IT%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8%EC%A0%95%EB%B3%B4%EC%8B%9C%EC%8A%A4%ED%85%9C%EA%B5%AC%EC%B6%95%EA%B4%80%EB%A6%AC/HW%EA%B5%AC%EC%B6%95%EA%B4%80%EB%A6%AC/%EC%84%9C%EB%B2%84%EC%9E%A5%EB%B9%84%EC%9A%B4%EC%98%81/"},{"title":"DB구축관리 - DB 표준화","text":"IT프로젝트정보시스템구축관리 DB표준화 데이터 표준화의 개념 시스템을 구성하는 데이터 요소의 명칭, 정의, 형식, 규칙에 대한 원칙을 수립하고 적용하는 것 데이터 표준화 작업은 데이터의 정확한 의미를 파악할 수 잇게 할 뿐 만아니라 데이터에 대한 상반된 시각을 조정하는 역할을 수행 데이터 표준화의 대상 데이터 명칭 데이터를 유일하게 구분할 수 있는 유일성, 의미 전달의 충분성, ㄱ리고 업무적 보편성을 갖는 이름으로 정의 데이터 정의 데이터를 제3자의 입장에서도 쉽게 이해할 수 있도록 해당 데이터가 의미하는 범위 및 자격 요건을 규정 데이터 형식 업무 규칙 및 사용 목적과 유사한 데이터에 대해 일관되게 데이터 형식을 정의함으로써 데이터 입력 오류, 통제 위험 등을 최소화 데이터 규칙 기본 값, 허용 값, 허용 범위 등과 같이 발생할 수 있는 데이터 값을 사전에 지정함으로써 데이터의 정합성 및 완전성을 향상 데이터 표준화의 기대효과 동일한 데이터에 대해 동일한 명칭을 지정하면서 명확한 의사소통 가능 표준화된 데이터를 사용하면 필요한 데이터의 의미나 위치 등을 쉽게 파악 가능 데이터 표준에 따라 데이터 형식 및 규칙을 적용하면 입력 오류를 방지하고 잘못된 데이터로 인한 의사 결정의 오류를 줄여 데이터 품질을 향상 데이터 표준에 따라 데이터를 전사적으로 관리하면 시스템 간 데이터 공유 시 데이터 변환이나 정제 작업을 수행하지 않아도 됨 향후 데이터 유지보수 및 운영의 효율성, 관리 비용 절감 가능 데이터 표준 데이터 모델이나 데이터베이스에서 정의할 수 있는 모든 오브젝트를 대상으로 데이터 표준화를 수행하는 것이 이상적이나 주로 관리해야될 필요성이 있는 오브젝트만을 대상으로 데이터 표준화 데이터 표준의 종류 표준 단어 업무에서 사용하고 일정한 의미를 갖고 있는 최소 단위의 단어를 의미 표준 도메인 문자형, 숫자형, 날짜형, 시간형과 같이 칼럼을 성질에 따라 그룹핑한 개념 표준 코드 선택할 수 있는 값을 정형화하기 위해 기준에 맞게 이미 정의된 코드 값 표준 용어 단어, 도메인, 코드 표준이 정의되면 이를 바탕으로 표준 용어를 구성 데이터 관리 조직 전사적으로 수립된 데이터 표준 원칙, 데이터 표준, 데이터 표준 준수 여부 관리 등을 위해서 데이터관리자 역할이 요구됨 데이터 표준화 절차 데이터 표준화 요구사항 수집 데이터표준화와 관련된 요구사항 수집 시스템별 데이터 표준 수집 표준화 현황 진단 데이터 표준 정의 표준화 원칙 정의 표준 용아, 표준 단어, 표준 도메인, 표준 코드 등을 데이터 표준 정의 데이터 표준 확정 데이터 표준 검토, 확정, 공표 데이터 표준 관리 데이터 표준 적용, 준수, 검사 등 데이터 표준 관리절차 수립 데이터 표준 이행","link":"/2020/05/01/Engineer_Information_Processing/ch19_IT%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8%EC%A0%95%EB%B3%B4%EC%8B%9C%EC%8A%A4%ED%85%9C%EA%B5%AC%EC%B6%95%EA%B4%80%EB%A6%AC/DB%EA%B5%AC%EC%B6%95%EA%B4%80%EB%A6%AC/DB%ED%91%9C%EC%A4%80%ED%99%94/"},{"title":"HW구축관리 - 핵심정리","text":"IT프로젝트정보시스템구축관리 HW구축관리 1. IT 신기술 및 서버장비 트렌드 정보 하드웨어 관련 신기술 3D 프린팅 엠디스크 멤리스트 네트워크 가상화 앤 스크린 RAID 서버 가상화 2. 서버장비 운영 서버 장비 운영 요소 서버 장비 뿐만 아니라 스토리지, 운영체제, 고가용성 장비, 보안 솔루션등 정보 시스템 운영에 필요한 모든 것들을 포함 저방 장치 DAS NAS SAN Secure OS 기존의 운영체제에 내재된 보안 취약점을 해소하기 위해 보안 기능을 갖춘 커널을 추가한 운영체제 High Availability 안정적인 서비스 운영을 위해 장애 발생시 즉시 다른 시스템으로 대체 가능한 환경을 구축하는 메커니즘","link":"/2020/05/01/Engineer_Information_Processing/ch19_IT%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8%EC%A0%95%EB%B3%B4%EC%8B%9C%EC%8A%A4%ED%85%9C%EA%B5%AC%EC%B6%95%EA%B4%80%EB%A6%AC/HW%EA%B5%AC%EC%B6%95%EA%B4%80%EB%A6%AC/%ED%95%B5%EC%8B%AC%EC%A0%95%EB%A6%AC/"},{"title":"SW구축관리 - SW개발보안 정책","text":"IT프로젝트정보시스템구축관리 SW구축관리 SW개발보안 정책의 개념 소프트웨어 개발과정에서발생할수 있는 보안취약점을 최소화하여 보안위협으로 부터 안전한 소프트웨어를 개발하기 위한 일련의 보안활동 SW개발 생명주기SDLC의 각 단계에서 요구되는 보안활동을 수행해 안전한 소프트웨어를 개발하는 것이 목적 SW 보안 취약점이 발생하는 경우 보안 요구사항이 정의되지 않은 경우 소프트웨어 설계 시 논리적 오류가 포함된 경우 기술 취약점을 갖고 있는 코딩 규칙을 적용한 경우 소프트웨어 배치가 적절하지 않은 경우 보안 취약점 발견 시 적절하게 대응하지 못한 경우 SW개발 보완 관련 기관 소프트웨어 개발 보안 관련 활동 주체 정책기관인 행정안전부 발주기관인 행정기관 전문기관인 인터넷진흥원 개발기관인 사업자 보안약점진단인 감리법인 SW개발 역할별 보안활동 프로젝트 관리자 PM 응용프로그램에 대한 보안 전략을 구성원들에게 설명하고 프로젝트 일정 및 보안위험의 상관관계등과 같은 보안 영향을 이해시키고 조직의 상태를 모니터링 요구사항 분석가 RM 아키텍트가 고려해야 할 보안 관련 비지니스 요구사항을 설명하고 프로젝트 팀이 고려해야할 구조에 존재하는 보안 요구사항과 유즈케이스에 대한 보안 고려사항을 기반으로 오용 사례를 정의 아키텍트 Architect 보안 오류가 발생하지 않도록 보안 기술 문제를 충분히 이해하고 시스템 사용되는 모든 리소스 정의 및 각 리소스별로 적절한 보안 요구사항 적용 설계자 Designer 특정 기술이 보안요구사항을 만족하는지 확인하고 애플리케이션 보안노력에 대한 품질 측정을 지원, 많은 비용이 필요한 수정 요구사항을 최소화하기 위한 방법을 제공, 타사의 소프트웨어 통합시 발생가능한 보안 위험을 이해하며 식별된 보안위협에 적절히 대응 구현개발자 Implementer 구조화된 소프트웨어 개발 환경에서 프로그램을 원활히 구현할 수 있도록 시큐어 코딩 표준을 준수하여 개발하며 제3자가 소프트웨어 안전 여부를 쉽게 판단할 수 있도록 문서화 시큐어 코딩 개발하고 있는 소프트웨어의보안상 취약점을 사전에 보완하면서 프로그래밍하는것 테스트분석가 Test Analyst 소프트웨어 개발 요구사항과 구현 결과를 반복적으로 확인하며 테스트 그룹은 반드시 보안전문가일 필요는 없지만보안 위험에 대한 학습이나 툴 사용법을 숙지함 SW개발 역할별 보안활동 보안 감시자 Security Auditor 프로젝트 전체단계에서 활동하며, 소프트웨어 개발 프로젝트의 현재 상태의 보안을 보장하고 요구사항 검토시 요구사항의 적합성과 완전성을 확인하고, 설계단계에서는 보안 문제로 이어질 수 있는 사항이 있는지 확인하며, 구현단계에서는 보안 문제가 있는지 확인 SW개발보안 관련 법령 개인정보보호법 정보통신망 이용촉진 및 정보보호 등에 관한 법률 신용정보의 이용 및 보호에 관한 법률 표준 개인정보 보호 지침 개인정보의 안전성 확보 조치 기준 개인정보 영향평가에 관한 고시 IT기술 관련 규정 RFID 프라이버시 보호 가이드라인 위치정보의 관리적, 기술적 보호조치 권고 해설서 바이오정보 보호 가이드라인 뉴미디어 서비스 개인정보 보호 가이드라인","link":"/2020/04/30/Engineer_Information_Processing/ch19_IT%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8%EC%A0%95%EB%B3%B4%EC%8B%9C%EC%8A%A4%ED%85%9C%EA%B5%AC%EC%B6%95%EA%B4%80%EB%A6%AC/SW%EA%B5%AC%EC%B6%95%EA%B4%80%EB%A6%AC/SW%EA%B0%9C%EB%B0%9C%EB%B3%B4%EC%95%88%EC%A0%95%EC%B1%85/"},{"title":"SW구축관리 - SW 관련 신기술","text":"IT프로젝트정보시스템구축관리 SW구축관리 소프트웨어와 관련된 IT 신기술의 종류와 특징을 이해 소프트웨어 개발 보안의 개념과 보안 관련 기관 및 소프트웨어 개발 프로젝트 참여자별 보안 활동 역할 이해 소프트웨어 개발 보안 활동 관련 법령 및 규정의 종류 이해 용어사전 SW개발보안 정책 소프트웨어 개발 과정에서 발생할 수 있는 보안 취약점을 최소화하여 보안 위협으로부터 안전한 소프트웨어를 개발하기 위한 일련의 보안활동 SW 관련 신기술 1. AI; Artificial Intelligence 인공지능 컴퓨터 스스로 인간의 두뇌와 같이 추론, 학습, 판단 등 인간 지능적인 작업을 수행하는 시스템 인공지능의 응용분야에는 신경망, 퍼지, 패턴 인식, 전문가 시스템, 자연어 인식, 이미지 처리, 컴퓨터 시각, 로봇 공학 등 Fuzzy 퍼지 인간의 말, 의미, 사고, 측정 등에 본질적으로 포함되어 있는 애매 모호함을 수학적으로 다루는 학문 2. AR; Augmented Reality 증강현실 가상현실이 이미지, 주변 배경, 객체 모두를 가상의 이미지로 만들어 보여 주는 반면, 증강 현실은 현실에 기반하여 정보를 추가 제공하는 기술 3. Blockchain 블록체인 과 Distributed Ledgers 분산 장부 P2P 네트워크를 이용하여 온라인 금융 거래 정보를 온라인 네트워크 참여자의 디지털 장빙 분산 저장하는 기술 기존 금융 회사들이 사용하고 있는 중앙 집중형 서버에 거래 정보를 저장할 필요가 없어 관리 비용이 절감되고, 분산 저장으로 인해 해킹이 어려워짐에 따라 보안 및 거래 안정성이 향상됨 4. CC; Common Criteria 공통 평가 기준 ISO 15408 표준으로 채택된 정보 보호 제품 평가기준 정보화 순기능 역할을 보장하기 위해 정보화 제품의 정보보호기능과 이에 대한 사용 환경 등급을 정한 기준 5. CEP; Complex Event Processing 복잡 이벤트 처리 실시간으로 발생하는 많은 사건들 중 의미가 있는 것만을 추출할 수 있도록 사건 발생 조건을 정의하는 데이터 처리 방법 금융, 통신, 전력, 물류, 국방 등에서 대용량 데이터 스트림에 대한 요구에 실시간으로 대응하기 위하여 개발된 기술이며 미들웨어에 접속시키면 기업이 독자적인 실시간 응용 애플리케이션 개발 가능 미들웨어 운영체제와 해당 운영체제에 의해 실행되는 응용 프로그램 사이에서 운영체제가 제공하는 서비스 이외에 추가적인 서비스를 제공하는 소프트웨어 6. Deep Learning 딥 러닝 인간의 두뇌를 모델로 만들어진 인공신경망을 기반으로 하는 기계 학습 기술 많은 데이터를 이용한 컴퓨터가 마치 사람처럼 스스로 학습할 수 있어 특정 업무를 수행할 때 정형화된 데이터를 입력 받지 않고 스스로 필요한 데이터를 수집,분석하여 고속으로 처리 가능 7. Digital Twin 디지털 트윈 현실 속의 사물을 소프트웨어로 가상화한 모델로 자동차, 항공, 에너지, 국방, 헬스케어 등 여러 분야에서 활용 현실 속의 사물을 대신해 다양한 상황을 모의 실험하기 위한 용도 8. Expert System 전문가 시스템 의료 진단 등과 같이 특정 분야의 전문가가 수행하는 고도의 업무를 지원하기 위한 컴퓨터 응용 프로그램 인간의 지적 활동과 경험을 통해서 축적된 전문가의 지식과 전문가에 의해 정의된 추론 규칙을 활용하여 결정하거나 문제르 해결 지식 베이스(Knowledge Base)라는 데이터베이스 + 추론을 실행하는 추론 엔진(Inference Engine) 9. Grayware 그레이웨이 소프트웨어를 제공하는 입장에서는 악의적이지 않은 유용한 소프트웨어라고 주장할 수 있지만 사용자 입장에서는 유용할 수도 있고 악의적일 수도 있는 애드웨어, 스파이웨어, 기타 악성코드나 악성 공유웨어를 뜻함 10. Hash 해시 임의의 길이의 입력 데이터나 메시지를 고정된 길이의 값이나 키로 변환하는 것 데이터의 암호화가 아닌 무결성 검증을 위한 방법으로 대칭, 비대칭 암호화 기법과 함께 사용되어 전자화폐, 전자서명 등 다양한 방면에서 활용되고 있음 11. Mashup 매시업 웹에서 제공하는 정보 및 서비스를 이용하여 새로운 소프트웨어나 서비스, 데이터베이스 등을 만드는 기술 다수의 정보원이 제공하는 콘텐츠를 조합하여 하나의 서비스로 제공하는 웹 사이트 또는 어플리케이션 12. OGSA; Open Grid Service Architecture 오픈 그리드 서비스 아키텍처 애플리케이션 공유를 위한 웹 서비스를 그리드 상에서 제공하기 위해 만든 개방형 표준 13. PET; Privacy Enhancing Technology 개인정보 강화 기술 심각한 위험으로 대두되고 있는 개인정보 침해 위험을 관리하기 위한 핵심 기술 암호화, 익명화 등 개인정보를 보호하는 기술에서 사용자가 직접 개인정보를 통제하기 위한 기술까지 다양한 사용자 프라이버시 보호 기술을 통칭함 14. PIA; Privacy Impact Assessment 개인정보 영향평가 제도 개인정보를 활용하는 새로운 정보시스템의 도입 및 기존 정보시스템의 중요한 변경 시 시스템의 구축/운영이 기업의 고객은 물론 국민의 사생활에 및리 영향에 대해 미리 조사/분석/평가하는 제도 15. QKD; Quantum Key Distribution 양자 암호키 분배 양자 통신을위해 비밀키를 분배/관리하는 기술 양자 물리학에서 상호 작용과 관련된 모든물리적 독립계의 최소단위 16. RIA; Rich Internet Application 리치 인터넷 어플리케이션 플래시 애니메이션 기술과 웹 서버 애플리케이션 기술을 통합하여 기존 HTML보다 역동적이고 인트랙티브한 웹페이지를 제공하는 신개념의 플래시 웹페이지 제작 기술 17. Semantic Web 시맨틱 웹 컴퓨터가 사람을 대신하여 정보를 읽고 이해하고 가공하여 새로운 정보를 만들어 낼 수 있는 '의미론적인 웹이라는 의미를 가진 차세대 지능형 웹 18. SOA; Service Oriented Architecture 서비스 지향아키텍처 정보시스템을 공유와 재사용이 가능한 서비스 단위나 컴포넌트 중심으로 구축하는 정보기술 아키텍처 19. Software Escrow 소프트웨어 에스크로 소프트웨어 개발자의지식재산권을 보호하고 사용자는 저렴한비용으로 소프트웨어를 안정적으로 사용 및 유지보수 받을 수 있도록 소스 프로그램과 기술 정보 등을 제3의 기관에 보관하는 것 20. Vaporware 증발품 판매 계획 또는 배포 계획은 발표되었으나 실제로 고객에게 판매되거나 배포되지 않고 있는 소프트웨어","link":"/2020/04/30/Engineer_Information_Processing/ch19_IT%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8%EC%A0%95%EB%B3%B4%EC%8B%9C%EC%8A%A4%ED%85%9C%EA%B5%AC%EC%B6%95%EA%B4%80%EB%A6%AC/SW%EA%B5%AC%EC%B6%95%EA%B4%80%EB%A6%AC/SW%EA%B4%80%EB%A0%A8%EC%8B%A0%EA%B8%B0%EC%88%A0/"},{"title":"네트워크구축관리 - 네트워크 관련 신기술","text":"IT프로젝트정보시스템구축관리 네트워크구축관리 IT신기술 및 네트워크 장비 트렌드 정보 네트워크 관련 신기술 1. Ad-hoc Network 애드 혹 네트워크 재난 현장과 같이 별도의 고정된 유선망을 구축할 수 없는 장소에서 모바일 호스트만을 이용하여 구성한 네트워크 망을 구성한 후 단기간 사용되는 경우나 유선망을 구성하기 어려운 경우에 적합하며, 빠른 망 구성과 저렴한 비용이 장점 2. BLE; Bluetooth Low Energy 저전력 블루투스 기술 일반 블루투스와 동일한 2.4GHz 주파수 대역을 사용하지만 연결되지 않은 대기 상태에서는 절전 모드를 유지하는 기술 주로 낮은 전력으로 저용량 데이터를 처리하는 시계, 장난감, 비콘, 착용 컴퓨터 등의 국소형 사물 인터넷에 적합 3. Cloud Computing 클라우드 컴퓨팅 각종 컴퓨팅 자원을 중앙 컴퓨터에 두고 인터넷 기능을 갖는 단말기로 언제 어디서나 인터넷을 통해 컴퓨터 작업을 수행 중앙 컴퓨터는 복수의 데이터 센터를 가상화 기술로 통합한 대형 데이터 센터로 각종 소프트웨어, 데이터, 보안 솔루션 기능 보유 서비스 종류 IaaS Paas SaaS 4. GIS; Geographic Informatio System 지리 정보 시스템 지리적인 자료를 수집/분석/출력할 수 있는 컴퓨터 응용 시스템으로 위성을 이용해 모든 사물의 위치 정보를 제공해 주는 것 GIS는 지도에서 사물을 확인하는 단계를 벗어나 인터넷, 인공위성 등 다양한 매체를 통해 지리 데이터를 수집/구축/분석/처리 과정을 거쳐 고품질의 공간 정보를 생성함으로써 보다 나은 공간 의사 결정에 도움을 주는 단계에까지 이르고 있음 5. 지능형 초연결망 과학기술정보통신부 주관으로 추진 중인 사업으로 스마트 시티, 스마트 스테이션 등 4차 산업혁명 시대를 맞아 새로운 변화에 따라 급격하게 증가하는 데이터 트래픽을 효과적으로 수용하기 위해 시행되는 정부 주관 사업 6. M2M; Machine to Machine 사물 통신 무선통신을 이용한 기계와 기계 사이의 통신 변압기 원격 감시 전기, 가스 등의 원격 검침 무선 신용카드 조회기 무선 보안 단말기 버스 운행 시스템 위치 추적 시스템 부호 분할 다중 접속(CDMA), GSM, 무선 데이터 통신 등 다양한 무선 통신망을 사용 7. IoT; Internet of Things 사물 인터넷 정보 통신 기술을 기반으로 실세계와 가상세계의 다양한 사물을 인터넷으로 서로 연결하여 진보된 서비스를 제공하기 위한 서비스 기반 기술 M2M의 개념을 인터넷으로 확장하여 사물은 물론, 현실과 가상 세계의 모든 정보와 상호 작용하는 IoT개념으로 진화 IoT 기반 서비스는 개방형 아키텍처를 필용로 하기 때문에 정보공유에 대한 부작용을 초소화하기 위한 정보 보안 기술의 적용이 중요함 8. Mesh Network 메시 네트워크 차세대 이동통신 홈 네트워킹, 공공 안정 등 특수 목적을 위한 새로운 방식의 네트워크 기술로, 대규모 디바이스의 네트워크 생성에 최적화 됨 무선 랜의 한계를 극복하기 위해 라우터들을 기지국으로 활용하여 모든 구간을 동일한 무선망처럼 구성함 9. Mobile Computing 모바일 컴퓨팅 휴대용 기기로 이동하면서 자유로이 네트워크에 접속하여 업무를 처리할 수 있는 환경 모바일 컴퓨팅의 진화로 기업은 비지니스 효율을 극대화하여 경쟁력을 확보하고 개인은 삶의 질을 향상시킬 수 있음 10. MCC; Mobile Cloud Computing 모바일 클라우드 컴퓨팅 클라우드 서비스를 이용하여 소비자와 소비자의 파트너가 모바일기기로 클라우드 컴퓨팅 인프라를 구성하여 여러 가지 정보와 자원을 고유하는 ICT기술을 의미함 모바일의 이동성과 클라우드 컴퓨팅의 경제성이 결합됨 11. NDN; Named Data Networking 콘텐츠 자체의 정보와 라우터 기능만으로 데이터 전송을 수행하는 기술로, 클라이언트와 서버가 패킷의 헤더에 내장되어 있는 주소 정보를 이용하여 연결되던 기존의 IP망을 대체할 새로운 인터넷 아키텍처로 떠오르고 있음 해시 테이블에 기반을 두는 P2P 시스템과 같이 콘텐츠에 담겨 있는 정보와 라우터 기능만으로 목적지를 확정함 12. Network Slicing 네트워크 슬라이싱 3GPP를 포함한 여러 글로벌 이동통신 표준화 단체가 선정한 5G의 핵심 기술 중 하나로, 네트워크에서 하나의 물리적인 코어 네트워크 인프라를 독립한 다수의 가상 네트워크로 분리하여 각각의 네트워크를 통해 다양한 고객 맞춤형 서비스 제공을 목적으로 하는 네트워크 기술 13. NFC; Near Field Communication 근거리 무선 통신 고주파를 이용한 근거리 무선 통ㅅ니 기술 양방향 통신을 지원하는 RFID 기술의 일종이며, 13.56MHz 주파수를 이용해 10cm 내에서 최고 424kbps의 속도로 데이터 전송을 지원 14. NGN; Next Generation Network 차세대 통신망 유선망 기반의 차세대 통신망 15. PICONET 피코넷 여러 개의 독립된 통신장치가 블루투스 기술이나 UWB 통신 기술을 사용하여 통신망르 형성하는 무선 네트워크 기술 네트워크를 구성하는 장비 간에 사전에 네트워크와 정의와 계획없이 상황에 따라 조정 프로토콜에 의하여 마스터와 슬레이브의 역할을 하면서 네트워크를 형성 16. SDN; Software Defined Networking 소프트웨어 정의 네트워킹 네트워크를 컴퓨터처럼 모델링하여 여러 사용자가 각각의 소프트웨어들로 네트워킹을 가상화 하여 제어하고 관리하는 네트퉈크 17. SON; Self Oragnizing Network 자동 구성 네트워크 주변 상황에 맞추어 스스로 망을 구성하는 네트워크 통신망 커버리지 및 전송 용량 확장의 경제성 문제를 해결하고, 망의 운영과 관리의 효율성을 높이는 것을 목적으로 함 18. USN; Ubiquitous Sensor Network 유비쿼터스 센서 네트워크 각종 센서로 수집한 정보를 무선으로 수집할 수 있도록 구성한 네트워크 19. UWB; Ultra WidBand 초광대역 짧은 거리에서 많은 양의 디지털 데이털르 낮은 전력으로 전송하기 위한 무선 기술로 무선 디지털 펄스라고도 하며, 블루투스와 비교되는 기술 20. WBAN; Wireless Body Area Network 웨어러블 또는 몸에 심는 형태의 센서나 기기를 무선으로 연결하는 개인 영역 네트워킹 기술 21. Wi-Sun 와이선 스마트 그리드와 같은 장거리 무선 통신을 필요로 하는 사물인터넷 서비스를 위한 저전력 장거리 통신 기술","link":"/2020/04/28/Engineer_Information_Processing/ch19_IT%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8%EC%A0%95%EB%B3%B4%EC%8B%9C%EC%8A%A4%ED%85%9C%EA%B5%AC%EC%B6%95%EA%B4%80%EB%A6%AC/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC%EA%B5%AC%EC%B6%95%EA%B4%80%EB%A6%AC/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC%EA%B4%80%EB%A0%A8%EC%8B%A0%EA%B8%B0%EC%88%A0/"},{"title":"SW구축관리 - 핵심정리","text":"IT프로젝트정보시스템구축관리 SW구축관리 1. IT신기술 및 SW개발 트렌드 정보 인공지능 증강현실 블록체인 딥러닝 전문가 시스템 그레이웨이 매시업 시맨틱 웹 서비스 지향 아키텍처 2. SW개발보안 정책 SW개발 생명주기의 각 단계에서 요구되는 보안활동을 수행해 안전한 소프트웨어를 개발하는 것이 목적 SW개발 보안 관련 기관 행정안전부, 한국인터넷진흥원, 발주기관 사업자, 감리법인 SW개발 역할별 보안활동 프로젝트 관리자 요구사항 분석가 아키텍트 설계자 구현개발자 테스트분석가 보안감시자 SW개발보안 관련 법령 및 규정 개인정보 보호법 정보통신망 이용촉진 및 정보보호 등에 관한 법률","link":"/2020/04/30/Engineer_Information_Processing/ch19_IT%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8%EC%A0%95%EB%B3%B4%EC%8B%9C%EC%8A%A4%ED%85%9C%EA%B5%AC%EC%B6%95%EA%B4%80%EB%A6%AC/SW%EA%B5%AC%EC%B6%95%EA%B4%80%EB%A6%AC/%ED%95%B5%EC%8B%AC%EC%A0%95%EB%A6%AC/"},{"title":"네트워크구축관리 - 네트워크 장비","text":"IT프로젝트정보시스템구축관리 네트워크구축관리 네트워크장비 Topology 네트워크 설치 구조 네트워크 분류 스위치 분류 스위치는 브리지와 같이 LAN과 LAN을 연결하여 훨씬 큰 LAN을 만드는 장치 OSI계층의 Layer에 따라 L2, L3, L4, L7로 분류 스위치 방식 스위치가 프레임을 전달하는 방식에 따라 Store and Forwarding, Cut-through, Fragment Free로 구분됨 Backbone Switch 백본 스위치 여러 네트워크들을 연결할 때 중추적 역할을 하는 네트워크를 백본이라고 하고, 백본에서 스위칭 역할을 하는 장비를 백본 스위치라고 함 모든 패킷이 지나가는 네트워크의 중심에 배치 대규모 트래픽을 처리하려면 고성능 백본 스위치를 사용 L3 스위치가 담당 네트워크 구축을 위한 Hierarchical 3 Layer 모델","link":"/2020/04/30/Engineer_Information_Processing/ch19_IT%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8%EC%A0%95%EB%B3%B4%EC%8B%9C%EC%8A%A4%ED%85%9C%EA%B5%AC%EC%B6%95%EA%B4%80%EB%A6%AC/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC%EA%B5%AC%EC%B6%95%EA%B4%80%EB%A6%AC/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC%EC%9E%A5%EB%B9%84/"},{"title":"SW개발 보안 구현 - 암호알고리즘","text":"소프트웨어 개발 보안 구축 SW개발 보안 구현 암호 알고리즘의 개념과 암호 알고리즘의 종류별 특징을 이해 코드오류와 캡슐화, API 오용 개념과 각 보안 점검 항목별 보약 약점의 종류 및 특징을 이해 용어사전 Hash 해시 임의의 길이의 입력 데이터나 메시지를 고정된 길이의 값이나 키로 변환하는 단방향 암호 알고리즘 암호 알고리즘 개념 주민번호, 패스워드, 은행계좌 등 중요 정보를 보호하기 위해 평문을 암호문으로 만드는 절차 또는 방법 해시를 사용하는 단방향 암호화 방식과 개인키와 공개키로 분류되는 양방향 암호화 방식으로 구분됨 Stream 방식 평문과 동일한 길이의 스트림을 생성하여 비트단위로 암호화 Block 방식 한 번에 하나의 데이터 블록을 암호화 양방향 알고리즘 1. 비밀키(개인키, 대칭키) 암호 알고리즘 장/단점 암호화 및 복호화 할 때 사용하는 키가 같음 장점 : 암호화 복호화 속도가 빠르며, 알고리즘이 단순하고, 공개키 암호기법보다 파일의 크기가 작음 단점 : 사용자의 증가에 따라 관리해야할 키의 수가 많음 2. 공개키(비대칭키) 암호 알고리즘 장/단점 암호화할 때 사용하는 키와 복호화 할 때 사용하는 키가 다름 장점 : 키의 분배가 용이하고, 관리해야할 키의 개수가 적음 단점 : 암호화 및 복호화 속도가 느리며, 알고리즘이 복잡하고, 개인키 암호화 기법보다 파일의 크기가 큼 3. 양방향 암호 알고리즘의 종류 단방향 암호 알고리즘 해시 입력 데이터나 메시지를 고정된 길이의 값이나 키로 변환하는 것을 의미 해시 알고리즘을 해시 함수라고 부르며, 해시 함수로 변환된 값이나 키를 해시값 또는 해시키로 부름 데이터의 암호화, 무결성 검증을 위해 사용될 뿐만 아니라 정보보호의 다양한 분야에 활용","link":"/2020/04/27/Engineer_Information_Processing/ch20_%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4%EA%B0%9C%EB%B0%9C%EB%B3%B4%EC%95%88%EA%B5%AC%EC%B6%95/SW%EA%B0%9C%EB%B0%9C%EB%B3%B4%EC%95%88%EA%B5%AC%ED%98%84/%EC%95%94%ED%98%B8%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"},{"title":"SW개발 보안 구현 - API 오용","text":"소프트웨어 개발 보안 구축 SW개발 보안 구현 API 오용 개념 소프트웨어 구현단계에서 API를 잘못 사용하거나 보안에 취약한 API를 사용하지 않도록 하기 위한 보안 검증 항목들 API 오용의 보안 약점 DNS lookup에 의존한 보안 결정 취약한 API 사용 API 프로그래머가 라이브러리가 제공하는 여러 함수를 이용하여 프로그램을 작성할 때 해당 함수의 내부 구조는 알 필요없이 단순히 API에 정의된 입력 값을 주고 결과 값을 사용 보안 약점의 종류 1. DNS lookup에 의존한 보안 결정 도메인명에 의존하여 인증이나 접근 통제 등의 보안 결정을 내리는 경우 발생하는 보안 약점 DNS 엔트리를 속여 동일한 도메인에 속한 서버인 것처럼 위장하거나, 사용자와 서버 간의 네트워크 트래픽을 유도하여 악성 사이트를 경유하도록 조작할 수 있음 DNS 검색을 통해 도메인 이름으로 비교하지 않고 IP주소를 직접 입력하여 접근함으로써 방지 2. 취약한 API 사용 보안 문제로 사용이 금지된 API를 사용하거나, 잘못된 방식으로 API를 사용했을 때 발생하는 보안 약점 보안 상 안전한 API라고 하더라도 자원에 대한 직접 연결이나 네트워크 소켓을 통한 직접 호출과 같이 보안에 위협을 줄 수 있는 인터페이스를 사용하는 경우 보안 약점이 노출됨 보안 문제로 금지된 함수는 안전한 함수로 대체하고, API 매뉴얼을 참고하여 보안이 보장되는 인터페이스를 사용함으로써 방지 가능","link":"/2020/04/28/Engineer_Information_Processing/ch20_%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4%EA%B0%9C%EB%B0%9C%EB%B3%B4%EC%95%88%EA%B5%AC%EC%B6%95/SW%EA%B0%9C%EB%B0%9C%EB%B3%B4%EC%95%88%EA%B5%AC%ED%98%84/API%EC%98%A4%EC%9A%A9/"},{"title":"HW구축관리 - HW 관련 신기술","text":"IT프로젝트정보시스템구축관리 HW구축관리 IT 신기술 및 서버장비 트랜드 정보 서버장비 운영(Secure-OS, 운영체제, NAS, DAS, SAN, 고가용성) 용어 사전 Secure-OS 기존의 운영체제에 내재된 보안 취약점을 해소하기 위해 보안 기능을 갖춘 커널을 추가하여 외부의 침입으로 시스테 자원을 보호하는 운영체제 고가용성 High Availability 긴 시간 동안 안정적인 서비스 운영을 위해 장애 발생시 즉시 다른 시스템으로 대체 가능한 환경을 구축하는 메카니즘 HW 관련 신기술 1. Three Dimension Printing 3D 프린팅 대상을 평면으로 출력하는 것이 아니라 아주 얇은 두께로 한층 한층 적층시켜 손으로 만질 수 있는 실제 물체로 만들어내는 것 2. 4K Ultra High Definition 4K 해상도 가로 해상도가 4 Kilo Pixel로 차세대 고화질 해상도를 지칭하는 용어 가로 픽셀수 3,840 * 세로 픽셀수 2,160 3. M-DISC, Milennial DISC 엠디스크 한 번의 기록만으로 자료를 영구 보관할 수 있는 광 저장장치 디스크 표면의 무기물층에 레이저를 이용해 자료를 조작해서 기록하므로 빛, 열, 습기 등의 외부요인에 영향을 받지 않음 4. Memristor 멤리스트 메모리와 레지스터의 합성어로 전류의 방향과 양 등 기존의 경험을 모두 기억하는 특별한 소자 전원 공급이 끊어졌을 때도 직전에 통과한 전류의 방향과 양을 기억하기 때문에 다시 전원이 공급되면 기존의 상태로 그대로 복원됨 5. MEMS; Micro-Electro Mechanical System 멤스 초정밀 반도체 제조 기술을 바탕으로 센서, 액추에이터등 기계구조를 다양한 기술로 미세 가공하여 전기기계적 동작을 할 수 있도록 한 초미세 장치 6. Network Virtualization 네트워크 가상화 라우터, 방화벽, 스위치 같은 물리적 네트워크 자원들을 마치 하나의 자원처럼 사용하는 기술로 단일한 네트워크를 여러 개의 가상 네트워크로 구성할 수 있으며, 서로 영향을 주지 않고 네트워크 자원에 액세스하며 일관성 있는 관리 및 보안 정책 유지 가능 7. N-Screen 앤 스크린 N개의 서로 다른 단말기에 동일한 콘텐츠를 자유롭게 이용할 수 있는 서비스 PC, TV, 휴대폰에서 동일한 콘텐츠를 끊기 없이 이용할 수 있음 8. Phablet 패블릿 폰과 태블릿의 합성어로 태블릿 기능을 포함한 5인치 이상의 대화면 스마트폰 9. RAID; Redundant Array of Inexpensive Disk 여러 개의 하드디스크로 디스크 배열을 구성하여 파일을 구성하고 있는 데이터 블록들을 서로 다른 디스크들에 분산 저장할 경우 그 블록들을 여러 디스크에서 동시에 읽거나 쓸 수 있으므로 디스크의 속도가 매우 향상됨 10. Server Virtualization 서버 가상화 CPU, 메모리, 하드디스크 등 서버의 물리적인 자원들을 논리적으로 통합하여 마치 하나의 서버를 통해 서비스를 받는 것처럼 느껴지게 하는 기술 11. Thin Client PC 신 클라이언트 PC 서버 기반 컴퓨팅과 관련되어 신 클라이언트PC는 하드디스크나 주변 장치 없이 기본적인 메모리만 갖추고 서버와 네트워크로 운용되는 개인용 컴퓨터 12. TrustZone Technology 트러스트존 기술 ARM에서 개발한 기술로 하나의 프로세서 내에 일반 애플리케이션을 처리하는 일반구역과 보안이 필요한 애플리케이션으로 처리하는 보안 구역으로 분할하여 관리하는 하드웨어 기반의 보안 기술","link":"/2020/04/30/Engineer_Information_Processing/ch19_IT%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8%EC%A0%95%EB%B3%B4%EC%8B%9C%EC%8A%A4%ED%85%9C%EA%B5%AC%EC%B6%95%EA%B4%80%EB%A6%AC/HW%EA%B5%AC%EC%B6%95%EA%B4%80%EB%A6%AC/HW%EA%B4%80%EB%A0%A8%EC%8B%A0%EA%B8%B0%EC%88%A0/"},{"title":"SW개발 보안 구현 - 캡슐화","text":"소프트웨어 개발 보안 구축 SW개발 보안 구현 캡슐화의 보안 점검 정보 은닉이 필요한 중요한 데이터와 기능을 불충분하게 캡슐화하거나 잘못 사용함으로써 발생할 수 있는 문제를 예방하기 위한 보안 점검 항목들 캡슐화 보안 약점 잘못된 세션에 의한 정보 노출 제거 되지 않고 남은 디버그 코드 시스템 데이터 정보 노출 Public 메소드로부터 반환된 Private 배열 Private 배열에 Public 데이터 할당 캡슐화 보안 약점 1. 잘못된 세션에 의한 정보 노출 다중 스레드 환경에서 멤버 변수에 정보를 저장할 때 발생하는 보안 약점 싱글톤 패턴에서 발생하는 레이스컨디션으로 인해 동기화 오류가 발생하거나, 멤버 변수의 정보가 노출 될 수 있음 멤버 변수보다 지역 변수를 활용하여 변수의 범위를 제한하여 방지 잘못된 세션에 의한 정보 노출은 SW개발 보안 설계의 세션통제 보안 약점으로도 나오는데, 세션통제는 분석, 설계 단계의 점검 내용이고 캡슐화는 구현단계의 점검내용만 다를 뿐 나머지는 동일 2. 제거되지 않고 남은 디버그 코드 개발 중에 버그 수정이나 결과값 확인을 위해 남겨둔 코드들로 인해 발생하는 보안 약점 디버그 코드에 인증 및 식별 절차를 생략하거나 우회하는 코드가 포함되어 있는 경우 공격자가 악용 가능 배포전에 코드 검사를 통해 남아있는 디버그 코드를 삭제함으로써 방지 가능 3. 시스템 데이터 정보 노출 시스템 내부 정보를 시스템 메시지 등을 통해 외부로 출력하도록 코딩했을 때 발생하는 보안 약점 메시지는 최소한의 정보만을 제공함으로써 방지 가능 4. Public 메소드로부터 반환된 Private 배열 5. Private 배열에 Public 데이터 할당","link":"/2020/04/28/Engineer_Information_Processing/ch20_%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4%EA%B0%9C%EB%B0%9C%EB%B3%B4%EC%95%88%EA%B5%AC%EC%B6%95/SW%EA%B0%9C%EB%B0%9C%EB%B3%B4%EC%95%88%EA%B5%AC%ED%98%84/%EC%BA%A1%EC%8A%90%ED%99%94/"},{"title":"SW개발 보안 구현 - 코드오류","text":"소프트웨어 개발 보안 구축 SW개발 보안 구현 코드오류의 개념 코드 오류는 소프트웨어 구현 단계에서 개발자들이 코딩 중 실수하기 쉬운 형(Type) 변환, 자원 반환 등의 오류를 예방하기 위한 보안 점검 항목 코드 오류로 발생할 수 있는 보안 약점 Null 포인터 역참조 Null은 값이 없음을 의미하며 포인터는 메모리의 위치를 가리킴. 부적절한 자원 해제 해제된 자원 사용 초기화되지 않은 변수 사용 보안약점종류 1. 널 포인터(Null Pointer) 역참조 널포인트가 가리키는 메모리에 어떠한 값을 저장할 때 발생하는 보안 약점 많은 라이브러리 함수들이 오류가 발생할 경우 널 값을 반환하는데, 이 반환값을 포인터로 참조하는 경우 발생 널포인터는 메모리의 첫 주소를 가리키며, 해당 주소를 참조할 경우 소프트웨어가 비정상적으로 종료 됨 공격자는 널 포인터 참조 오류로 발생하는 예외 상황을 악용할 수 있음 널 값을 갖고 있는지 검사함으로써 방지 null이 이미 없는 것이기 때문에 초기화 불가 2. 부적절한 자원 해제 자원을 반환하는 코드를 누락하거나 프로그램 오류로 할당된 자원을 반환하지 못했을 때 발생하는 보안 약점 힙 메모리, 소켓 등의 유일한 시스템 자원이 계속 점유하고 있으면 자원 부족으로 인해 새로운 입력을 처리하지 못함 힙 메모리 소프트웨어가 자유롭게 사용할 수 있는 메모리 공간 소켓 데이터 교환을 위한 통로 자원 반환 코드가 누락되었는지 확인하고, 오류로 인해 함수가 중간에 종료되었을 때 예외처리에 관계없이 자원이 반환되도록 코딩함으로써 방지 3. 해제된 자원 사용 이미 사용이 종료되어 반환된 메모리를 참조하는 경우 발생하는 보안 약점 반환된 메모리를 참조하는 경우 예상하지 못한 값 또는 코드를 수행하게 되어 의도하지 않은 결과 발생 주소를 저장하고 있는 포인터를 초기화함으로써 방지 가능 4. 초기화되지 않은 변수 사용 변수 선언 후 값이 부여되지 않은 변수를 사용할 때 발생하는 보안 약점 변수 선언으로 메모리가 할당되면 해당 메모리 이전에 사용하던 내용이 계속 남아 외부에 노출되는 경우 중요 정보 악용됨 변수 선언시 할당된 메모리를 초기화함으로써 방지 가능","link":"/2020/04/28/Engineer_Information_Processing/ch20_%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4%EA%B0%9C%EB%B0%9C%EB%B3%B4%EC%95%88%EA%B5%AC%EC%B6%95/SW%EA%B0%9C%EB%B0%9C%EB%B3%B4%EC%95%88%EA%B5%AC%ED%98%84/%EC%BD%94%EB%93%9C%EC%98%A4%EB%A5%98/"},{"title":"네트워크구축관리 - 핵심정리","text":"IT프로젝트정보시스템구축관리 네트워크구축관리 1. IT 신기술 및 네트워크 장비 트렌드 정보 - Ad-hoc Network 애드 혹 네트워크 - Cloud Computing 클라우드 컴퓨팅 - IoT; Internet of Things 사물 인터넷 - NDN; Named Data Networking - NFC; Near Field Communication 근거리 무선 통신 - PICONET 피코넷 - USN; Ubiquitous Sensor Network 유비쿼터스 센서 네트워크 2. 네트워크 장비(라우터, 백본 스위치) - 네트워크 토폴리지(Topology) 종류 - 성형, 버스형, 링형, 트리형, 망형 - 네트워크 분류 - LAN, MAN, WAN, VAN - 스위치의 분류 - L2, L3, L4, L7 스위치 - Hierarchical 3 Layer 모델 - 액세스 계층, 디스트리뷰션 계층, 코어 계층","link":"/2020/04/30/Engineer_Information_Processing/ch19_IT%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8%EC%A0%95%EB%B3%B4%EC%8B%9C%EC%8A%A4%ED%85%9C%EA%B5%AC%EC%B6%95%EA%B4%80%EB%A6%AC/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC%EA%B5%AC%EC%B6%95%EA%B4%80%EB%A6%AC/%ED%95%B5%EC%8B%AC%EC%A0%95%EB%A6%AC/"},{"title":"SW개발 보안 구현 - 핵심정리","text":"소프트웨어 개발 보안 구축 SW개발 보안 구현 1. 암호 알고리즘 주민번호, 패스워드, 은행계좌 등 중요 정보를 보호하기 위해 평문을 암호문으로 만드는 절차 또는 방법 해시를 사용하는 단방향 암호화 방식과 개인키와 공개키로 분류되는 양방향 암호화 방식으로 구분됨 Stream 방식 평문과 동일한 길이의 스트림을 생성하여 비트단위로 암호화 Block 방식 한 번에 하나의 데이터 블록을 암호화 2. 코드오류 코드 오류는 소프트웨어 구현 단계에서 개발자들이 코딩 중 실수하기 쉬운 형(Type) 변환, 자원 반환 등의 오류를 예방하기 위한 보안 점검 항목 코드 오류로 발생할 수 있는 보안 약점 Null 포인터 역참조 Null은 값이 없음을 의미하며 포인터는 메모리의 위치를 가리킴. 부적절한 자원 해제 해제된 자원 사용 초기화되지 않은 변수 사용 3. 캡슐화 정보 은닉이 필요한 중요한 데이터와 기능을 불충분하게 캡슐화하거나 잘못 사용함으로써 발생할 수 있는 문제를 예방하기 위한 보안 점검 항목들 캡슐화 보안 약점 잘못된 세션에 의한 정보 노출 제거 되지 않고 남은 디버그 코드 시스템 데이터 정보 노출 Public 메소드로부터 반환된 Private 배열 Private 배열에 Public 데이터 할당 4. API 오용 소프트웨어 구현단계에서 API를 잘못 사용하거나 보안에 취약한 API를 사용하지 않도록 하기 위한 보안 검증 항목들 API 오용의 보안 약점 DNS lookup에 의존한 보안 결정 취약한 API 사용","link":"/2020/04/28/Engineer_Information_Processing/ch20_%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4%EA%B0%9C%EB%B0%9C%EB%B3%B4%EC%95%88%EA%B5%AC%EC%B6%95/SW%EA%B0%9C%EB%B0%9C%EB%B3%B4%EC%95%88%EA%B5%AC%ED%98%84/%ED%95%B5%EC%8B%AC%EC%A0%95%EB%A6%AC/"},{"title":"SW개발 보안 설계 - Secure SDLC","text":"소프트웨어 개발 보안 구축 SW개발 보안 설계 Secure SDLC 개념과 SDLC 단계별 보안활동에 대한 이해 입력데이터 검증 및 표현, 보안기능, 에러처리, 세션통제 보안 점검의 개념 이해 각각의 보안 약점 및 방지 방법 이해 용어사전 Security Elements 보안요소 소프트웨어 개발에 있어 충족시켜야 할 요소 및 요건을 의미하며, 주요 보안요소에는 기밀성, 무결성, 가용성이 있으며 그 외에 인증, 부인방지가 포함됨 Session Control 세션통제 세션은 서버와 클라이언트의 연결을 의미하고 세션통제는 세션의 연결과 연결로 인해 발생하는 정보를 관리하는 것 Secure SDLC(Software Development Life Cycle) 개념 보안상 안전한 소프트웨어를 개발하기 위해 소프트웨어 개발 생명주기에 보안 강화를 위한 프로세스를 포함한 것 소프트웨어 유지 보수 단계에서 보안 이슈를 해결하기 위해 소모되는 많은 비용을 최소화하기 위해 등장 요구사항 분석, 설계, 구현, 테스트, 유지보수 등 SDLC 전체 단계에 걸쳐 수행되어야 할 보안 활동을 제시 Secure SDLC 단계별 활동 1.요구사항 분석 단계에서의 보안 활동 보안 항목에 해당하는 요구사항을 식별하는 작업을 수행 전산화되는 정보가 가지고 있는 보안 수준을 보안 요소별로 등급을 구분하여 분류 보안정책항목들의 출처, 요구수준, 세부내용을 문서화 보안요소 기밀성 시스템 내의 정보와 자원은 인가된 사용자에게만 접근 허용 무결성 시스템 내의 저보는 오직 인가된 사용자만 수정가능 가용성 인가 받은 사용자는 언제든지 사용 가능 인증 시스템 내 정보와 자원을 사용하려는 자가 합법적인 사용자인지 확인 부인방지 데이터를 송/수신한 자가 송/수신 사실을 부인할 수 없도록 증거 제공 2. 설계 단계에서의 보안 활동 식별된 보안 요구사항들을 소프트웨어 설계서에 반영하고, 보안 설계서를 작성 소프트웨어에서 발생할 수 있는 위협을 식별하여 보안대책, 소요예산, 사고발생 시 영향범위와 대응책 수립 환경에 대한 보안 통제 기준 수립 및 설계 반영 네트워크 외부의 사이버 공격으로부터 개발 환경을 보호하기 위해 네트워크를 분리하거나 방화벽 설치 서버 보안이 뛰어난 운영체제를 사용하고 보안 업데이트, 외부접속에 대한 접근통제 실시 물리적 보안 출입통제, 개발 공간 제한, 폐쇄회로 개발프로그램 허가 되지 않은 프로그램을 통제하고 지속적인 데이터 무결성 검사 실시 3. 구현 단계에서의 보안 활동 표준 코딩 정의서 및 소프트웨어 개발 보안 가이드를 준수하며, 설계서에 따라 보안 요구사항들을 구현 갭라 과정 중에는 지속적인 단위 테스트를 통해 소프트웨어에 발생할 수 있는 보안 취약점을 최소화 단위 테스트 프로그램의 단위기능을 구현하는 모듈이 정해진 기능을 정확히 수행하는지 검증 코드 점검 및 소스 코드 진단 작업을 통해 소스 코드의 안정성 확보 4. 테스트 단계에서의 보안 활동 설계 단계에서 작성한 보안 설계서를 바탕으로 보안 사항들이 정확히 반영되고 동작하는지 점검 동적 분석 도구 또는 모의 침투테스트를 통해 설계 단계에서 식별된 위협들의 해결 여부 검증 구현 단계에서 추가로 제시된 위협들과 취약점들을 점검할 수 있도록 테스트 계획을 수립하고 시행 테스트 단계에서 수행한 모든 결과는 문서화, 개발자에게 피드백 5. 유지보수 단계에서의 보안 활동 이전 과정을 모두 수행했음에도 발생할 수 있는 보안사고들을 식별 사고 발생 시 이를 해결하고 보안 패치를 설치 보안 이슈는 유지보수 단계","link":"/2020/04/27/Engineer_Information_Processing/ch20_%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4%EA%B0%9C%EB%B0%9C%EB%B3%B4%EC%95%88%EA%B5%AC%EC%B6%95/SW%EA%B0%9C%EB%B0%9C%EB%B3%B4%EC%95%88%EC%84%A4%EA%B3%84/Secure_SDLC/"},{"title":"SW개발 보안 설계 - 세션통제","text":"소프트웨어 개발 보안 구축 SW개발 보안 설계 세션통제의 개념 세션 서버와 클라이언트의 연결 세션통제 세션의 연결과 연결로 인해 발생하는 정보를 관리 소프트웨어 개발 과정 중 요구사항 분석 및 설계단계에서 진단해야 하는 보안 점검 내용 보안 약점 불충분한 세션 관리 잘못된 세션에 의한 정보 노출 인가된 클라이언트만 접근할 수 있도록하는 것은 기밀성에 관한 것 1. 불충분한 세션 관리 일정한 규칙이 존재하는 세션ID가 발급되거나 타임아웃이 너무 길게 설정되어 있는 경우 발생할 수 있는 보안 약점 세션 관리가 충분하지 않으면 침입자는 세션 하이재킹와 같은 공격을 통해 획득한 세션ID로 인가되지 않은 시스템의 기능을 이용하거나 중요한 정보에 접근 가능 2. 잘못된 세션에 의한 정보 노출 다중 스레드 환경에서 멤버 변수에 정보를 저장할 때 발생하는 보안 약점 싱글톤 패턴에서 발생하는 레이스 컨디션으로 인해 동기화 오류가 발생하거나, 멤버 변수의 정보가 노출 싱글톤 하나의 객체를 생성하면 생성된 객체를 어디서든 참조할 수 있지만, 여러 프로세스가 동시에 참조할 수 없는 디자인 패턴 레이스컨디션 두 개 이상의 프로세스가 공용 자원을 획득하기 위해 경쟁하는 상태 멤버 변수보다 지역 변수를 활용하여 변수의 범위를 제한함으로써 방지 세션 설계 시 고려사항 시스템의 모든 페이지에서 로그아웃이 가능하도록 UI 구성 로그아웃 요청시 할당된 세션이 완전히 제거되도록 함 세션 타임아웃은 중요도 높을 시 2~5분, 낮을실 15~30분 이전 세션이 종료되지 않으면 새 세션이 생성되지 못하도록 설계 중복 로그인을 허용하지 않는 경우 클라이언트의 중복 접근에 대한 세션 관리 정책을 수립 패스워드 변경 시 활성화된 세션을 삭제하고 재할당 세션ID의 관리방법 안전한 서버에서 최소 128비트 예측이 불가능하도록 안전한 난수 알고리즘 URL Rewrite기능을 사용하지 않는 방향으로 설계 URL Rewrite 쿠키를 사용할 수 없는 환경에서 세션ID전달을 위해 URLL에 세션ID를 포함시키는 로그인시 로그인 이전의 세션ID를 삭제하고 재할당 장기간 접속하고 있는 세션ID는 주기적으로 재할당되도록 설계","link":"/2020/04/27/Engineer_Information_Processing/ch20_%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4%EA%B0%9C%EB%B0%9C%EB%B3%B4%EC%95%88%EA%B5%AC%EC%B6%95/SW%EA%B0%9C%EB%B0%9C%EB%B3%B4%EC%95%88%EC%84%A4%EA%B3%84/%EC%84%B8%EC%85%98%ED%86%B5%EC%A0%9C/"},{"title":"SW개발 보안 설계 - 입력데이터 검증 및 표현","text":"소프트웨어 개발 보안 구축 SW개발 보안 설계 입력데이터 검증 및 표현의 개념 폼 양식의 입력란을 통해 입력되는 데이터로 인해 발생하는 문제들을 예방하기 위해 구현 단계에서 검증해야 하는 보안 점검 항목들 입력 데이터로 인해 발생하는 문제를 예방하기 위해서 소프트웨어개발의 구현 단계에서 유효성 검증 체계를 갖추고, 검증되지 않은 데이터가 입력되는 경우 이를 처리할 수 있도록 구현해야 함 입력 데이터를 처리하는 객체에 지정된 자료형이 올바른지 확인하고 일관된 언어셋(Character Set)을 사용하도록 코딩 함 Character Set 컴퓨터에서 처리하기 위해 사용하는 코드표를 의미 ASCII Unicode UTF-8 입력데이터 검증 및 보안 약점 종류 SQL 입력란에 SQL을 삽입하며 무단으로 DB를 조회하거나 조작하는 보안 약점 동적 쿼리에 사용되는 입력 데이터에 예약어 및 특수문자가 입력되지 않게 필터링 되도록 방지 동적쿼리 질의어 코드를 문자열 변수에 넣어 조건에 따라 질의를 동적으로 변경하여 처리하는 방식 XSS 크로스사이트 스크립트 웹페이지에 악의적인 스크립트를 삽입하여 방문자들의 정보를 탈취하거나 비정상적인 기능 수행을 유발하는 보안 약점 HTML 태그의 사용을 제한하거나 스크립트에 삽입되지 않도록 ‘&lt;’, ‘&gt;’ 등의 문자를 다른 문자로 치환함으로써 방지 위험한 형식 파일 업로드 악의적인 명령어가 포함된 스크립트 파일을 업로드함으로써 시스템에 손상을 주거나 시스템을 제어할 수 있는 보안 약점 업로드 되는 파일의 확장자 제한, 파일명의 암호화, 웹사이트와 파일 서버 경로 분리, 실행 속성을 제거하는 드으이 방법으로 방지 경로 조작 및 자원 삽입 데이터 입출력 경로를 조작하여 서버 자원을 수정/삭제할 수 있는 보안 약점 사용자 입력값을 식별자로 사용하는 경우, 경로 순회 공격을 막는 필터를 사용하여 방지 경로 순회 경로를 탐색할때 사용하는 ‘/’, ‘’ 등의 기호를 악용하여 허가되지 않은 파일에 접근하는 방식","link":"/2020/04/27/Engineer_Information_Processing/ch20_%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4%EA%B0%9C%EB%B0%9C%EB%B3%B4%EC%95%88%EA%B5%AC%EC%B6%95/SW%EA%B0%9C%EB%B0%9C%EB%B3%B4%EC%95%88%EC%84%A4%EA%B3%84/%EC%9E%85%EB%A0%A5%EB%8D%B0%EC%9D%B4%ED%84%B0%EA%B2%80%EC%A6%9D%EB%B0%8F%ED%91%9C%ED%98%84/"},{"title":"SW개발 보안 설계 - 에러처리","text":"소프트웨어 개발 보안 구축 SW개발 보안 설계 에러처리의 개념 소프트웨어 실행 중에 발생할 수 있는 오류(Error)들을 사전에 정의하여 오류로 인해 발생할 수 있는 문제들을 예방하기 위한 보안 점검 항목 각 프로그래밍 언어의 예외처리 구문을 통해 오류에 대한 사항을 정의 예외처리 구문으로 처리하지 못한 오류들은 중요정보를 노출시키거나, 소프트웨어의 싫애이 중단되는 등의 문제를 발생 보안 약점의 종류 오류 메시지를 통한 정보 노출 오류 상황 대응 부재 부적절한 예외처리 발생 오류 메시지를 통한 정보노출 오류 발생으로 실행환경, 사용자 정보, 디버깅 정보 등의 중요 정보를 소프트웨어가 메시지로 외부에 노출하는 보안 약점 오류 메시지를 통해 노출되는 경로 및 디버깅 정보는 해커의 악의적인 행위를 도움 예외처리 구문에 예외의 이름이나 스택트레이스를 출력하도록 코딩시 해커는 소프트웨어의 내부구조를 쉽게 파악 가능 스택트레이스 오류가 발생한 위치를 추적하기 위해 소프트웨어가 실행 중에 호출한 메소드의 리스트를 기록한 것 오류 발생 시 가능한 내부에서만 처리되도록 하거나 메시지를 출력할 경우 최소한의 정보만 출력되도록 함으로써 방지 오류 상황에 대한 대응 부재 소프트웨어 개발 중 예외처리를 하지 않았거나 미비로 인해 발생하는 보안 약점 오류가 발생할 수 있는 부분에 예외처리 구문을 작성하고 제어문을 활용하여 오류가 악용되지 않도록 코딩함으로써 방지 부적절한 예외처리 함수의 반환 값 또는 오류들을 세분화하여 처리하지 않고 광범위하게 묶어 한 번에 처리가 존재할 때 발생하는 보안 약점 함수 등이 예상했던 결과와 다른 값을 반환하여 예외로 처리되지 않은 경우 잘못된 값으로 인해 다양한 문제가 발생 가능 모든 함수의 반환 값이 의도대로 출력되는지 확인하고, 세분화된 예외처리를 수행함으로써 방지","link":"/2020/04/27/Engineer_Information_Processing/ch20_%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4%EA%B0%9C%EB%B0%9C%EB%B3%B4%EC%95%88%EA%B5%AC%EC%B6%95/SW%EA%B0%9C%EB%B0%9C%EB%B3%B4%EC%95%88%EC%84%A4%EA%B3%84/%EC%97%90%EB%9F%AC%EC%B2%98%EB%A6%AC/"},{"title":"시스템보안구현 - 로그분석","text":"시스템보안구축 시스템보안구현 로그 분석의 개념과 리눅스와 윈도우에서의 주요 로그분석대상을 이해 보안 솔루션의 개념과 보안 솔루션의 종류별 특징을 이해 취약점 분석/평가의 개념과 범위 및 항목, 수행 절차를 이해 로그 분석 로그 시스템 사용에 대한 모든 내역을 기록해 놓은 것 로그 분석을 통해 시스템에 대한 침입 흔적이나 취약점 확인 가능 로그 정보를 이용하면 시스템 침해 사고 발생 시 해킹 흔적이나 공격 기법 파악 가능 Linux 리눅스 로그 var/log 디렉토리에 기록 관리 syslogd 데몬 로그 파일 관리 etc/syslog.conf 읽어 로그 관련 파일들의 위치 파악 후 로그 작업 시작 데몬 사용자의 직접적인 개입없이 특정 상태가 되면 자동으로 동작하는 시스템 프로그램 Linux, Unix 는 데몬 Window 는 서비스 syslog.conf 파일을 수정하여 로그 관련 파일들의 저장 위치와 파일명 변경 가능 리눅스 주요 로그 파일 로그 파일명 데몬 내용 커널로그 /dev/console kernel 커널에 관련된 내용을 관리자에게 알리기 위해 파일로 저장하지 않고 지정된 장치에 표시 부팅로그 /var/log/boot.log boot 부팅 시 나타나는 메시지들을 기록 크론로그 /var/log/cron crond 작업 스케줄러인 crond의 작업 내역을 기록 시스템로그 /var/log/messages syslogd 커널에서 실시간으로 보내오는 메시지들을 기록 보안로그 /var/log/secure xinetd 시스템의 접속에 대한 로그를 기록 FTP로그 /var/log/xferlog ftpd FTP로 접속하는 사용자에 대한 로그를 기록 메일로그 /var/log/mailog sendmail popper 송수신 메일에 대한 로그를 기록 커널 운영체제에서 가장 핵심적인 부분으로 하드웨어를 보호하고 프로그램과 하드웨어 간의 인터페이스 역할을 담당 프로세스 관리 기억장치 관리 파일 관리 입/출력 관리 프로세스 간 통신 데이터 전송 및 변환 커널의 로그파일은 Console Window 윈도우 로그 이벤트 뷰어를 이용하여 이벤트 로그 확인 [제어판]-[관리도구]-[이벤트뷰어] C:\\Windows\\System32\\winevt\\Logs 윈도우 이벤트 뷰어의 로그 로그 내용 응용프로그램 응용프로그램에서 발생하는 이벤트 기록 보안 로그온 시도, 파일이나 객체 생성, 조회, 제거 등의 리소스 사용관련 이벤트 기록 시스템 Windows 시스템 구성요소에 의해 발생하는 이벤트 기록 Setup 프로그램설치와 관련된 이벤트 기록 Forwarded Events 다른 컴퓨터와의 상호작용으로 발생하는 이벤트기록 로그인은 보안 로그 항목에 기록되는 내용","link":"/2020/04/26/Engineer_Information_Processing/ch21_%EC%8B%9C%EC%8A%A4%ED%85%9C%EB%B3%B4%EC%95%88%EA%B5%AC%EC%B6%95/%EC%8B%9C%EC%8A%A4%ED%85%9C%EB%B3%B4%EC%95%88%EA%B5%AC%ED%98%84/%EB%A1%9C%EA%B7%B8%EB%B6%84%EC%84%9D/"},{"title":"SW개발 보안 설계 - 보안기능","text":"소프트웨어 개발 보안 구축 SW개발 보안 설계 보안기능의 개념 소프트웨어 개발의 구현 단계에서 코딩하는 기능인 인증, 접근제어, 기밀성, 암호화등을 올바르게 구현하기 위한 보안 점검 항목들 각 보안 기능들은 서비스 환경이나 취급 데이터에 맞게 처리될 수 있도록 구현 소프트웨어 기능 또는 데이터에 접근하려는 사용자별로 중요도구분하고, 차별화된 인증 방안 적용 개인정보나 인증정보와 같은 중요한 정보의 변조, 삭제, 오남용 등을 방지하기 위해 안전한 암호화 기술 적용 보안기능의 보안 약점 종류 적절한 인증 없이 중요기능 허용 보안검사를 우회하여 인증과정 없이 중요한 정보 또는 기능에 접근 및 변경 중요정보나 기능을 수행하는 페이지에서 재인증 기능을 수행하도록 하여 방지 중요한 자원에 대한 잘못된 권한 설정 권한 설정이 잘못된 자원에서 접근하여 해당 자원을 임의로 사용 인가되지 않은 사용자의 중요 자원에 대한 접근 여부를 검사하므로써 방지 부적절한 인가 접근제어 기능이 없는 실행경로를 통해 정보 또는 권한을 탈취 모든 실행경로에 접근 제어 검사 수행하고 사용자에게는 필요한 접근권한만 부여함으로써 방지 하드코드가된 비밀번호 소스코드 유출 시 내부에 하드코드 된 패스워드를 이용하여 관리자 권한 탈취 패스워드는 암호화하여 별도의 파일에 저장하고 디폴트 패스워드 사용을 피함 취약한 암호화 알고리즘 사용 암호화된 환경설정 파일을 해독하여 비밀번호 등의 중요정보를 탈취 안전한 암호화 알고리즘을 이용하고 업무관련 내용이나 개인정보등은 암호모듈을 이용함으로써 방지 중요정보 평문 저장 및 전송 암호화되지 않은 평문 데이터를 탈취하여 중요한 정보를 획득 HTTPS또는 SSL과 같은 보안 프로토콜을 이용함으로써 방지","link":"/2020/04/27/Engineer_Information_Processing/ch21_%EC%8B%9C%EC%8A%A4%ED%85%9C%EB%B3%B4%EC%95%88%EA%B5%AC%EC%B6%95/%EC%8B%9C%EC%8A%A4%ED%85%9C%EB%B3%B4%EC%95%88%EA%B5%AC%ED%98%84/%EB%B3%B4%EC%95%88%EA%B8%B0%EB%8A%A5/"},{"title":"시스템보안구현 - 핵심정리","text":"시스템보안구축 시스템보안구현 핵심정리 로그분석 로그는 시스템 사용에 대한 모든 내역을 기록해 놓은 것으로 로그를 분석하여 시스템에 대한 침입 흔적이나 취약점 확인 가능 리눅스 주요 로그 파일 로그 파일명 데몬 내용 커널로그 /dev/console kernel 커널에 관련된 내용을 관리자에게 알리기 위해 파일로 저장하지 않고 지정된 장치에 표시 부팅로그 /var/log/boot.log boot 부팅 시 나타나는 메시지들을 기록 크론로그 /var/log/cron crond 작업 스케줄러인 crond의 작업 내역을 기록 시스템로그 /var/log/messages syslogd 커널에서 실시간으로 보내오는 메시지들을 기록 보안로그 /var/log/secure xinetd 시스템의 접속에 대한 로그를 기록 FTP로그 /var/log/xferlog ftpd FTP로 접속하는 사용자에 대한 로그를 기록 메일로그 /var/log/mailog sendmail popper 송수신 메일에 대한 로그를 기록 보안솔루션 접근 통제, 침입차단 및 탐지 등을 수행하는 외부로 부터의 붋법적인 침입을 막는 기술 및 시스템 주요 보안 솔루션 방화벽 IDS 침입 탐지 시스템 IPS 침입 방지 시스템 DLP 데이터 유출 방지 웹 방화벽 VPN NAC 취약점 분석 사이버 위협으로부터 정보시스템의 취약점을 분석 및 평가한 후 개선하는 일련의 과정 수행 절차 및 방법 취약점 분석/평가 계획 수립 취약점 분석/평가 대상 선별 취약점 분석 수행 취약점 평가 수행","link":"/2020/04/26/Engineer_Information_Processing/ch21_%EC%8B%9C%EC%8A%A4%ED%85%9C%EB%B3%B4%EC%95%88%EA%B5%AC%EC%B6%95/%EC%8B%9C%EC%8A%A4%ED%85%9C%EB%B3%B4%EC%95%88%EA%B5%AC%ED%98%84/%ED%95%B5%EC%8B%AC%EC%A0%95%EB%A6%AC/"},{"title":"시스템보안구현 - 보안솔루션","text":"시스템보안구축 시스템보안구현 보안솔루션 개념 접근통제, 침입 차단 및 탐지 등을 수행하여 외부로부터 불법적인 침입을 막는 기술 시스템 주요 보안 솔루션 방화벽 IDS 침입 탐지 시스템 IPS 침입 방지 시스템 DLP 데이터 유출 방지 웹 방화벽 VPN NAC Firewall 방화벽 조직 내부의 네트워크와 인터넷 간에 전송되는 정보를 선별하여 수용/거부/수정하는 기능을 가진 침입 차단 시스템 내부 네트워크에서 외부로 나가는 패킷은 그대로 통과시킴 외부에서 내부 네트워크로 들어오는 패킷은 내용을 엄밀히 체크하여 인증된 패킷만 통과시키는 구조 해킹등으로 의한 외부로의 정보 유출을 막기 위해 사용 IDS(Intrusion Detection System) 침입 탐지 시스템 컴퓨터의 비정상적인 사용, 오용, 남용 등을 실시간으로 탐지하는 시스템 내부 사용자의 불법적인 행동과 외부 해킹에 100% 대처는 불가능 문제발생시 해커 침앱 패턴에 대한 추적과 유해 정보 감시 필요 종류 오용탐지 미리 입력해둔 공격 패턴이 감지되면 알려줌 이상탐지 비정상적인 행위나 자원이 사용되면 알려줌 IPS(Intrusion Prevention System) 침입 방지 시스템 방화벽 + 침입 탐지 시스템을 결합 비정상적인 트래픽을 능동적으로 차단하고 격리하는 등의 방어 조치를 취하는 보안 솔루션 침입 탐지 기능으로 패킷을 하나씩 검사한 후 비정상적인 패킷이 탐지되면 방화벽 기능으로 해당 패킷을 차단 DLP)Data Leakage/Loss Prevention) 데이터 유출 방지 내부 정보의 외부 유출을 방지하는 보안 솔루션 사내PC 및 네트워크상의 모든 정보 검색하고 메일, 메신저, 웹하드, 프린트 등의 사용자 행위를 탐지 및 통제함으로써 방지 Web Firewall 웹 방화벽 일반 방화벽이 탐지하지 못하는 SQL 삽입공격, Cross-Site Scripting(XSS) 등의 웹 기반 공격을 방어할 목적으로 만들어진 웹 서버에 특화된 방화벽 웹 관련 공격을 감시하고 도달하기 전에 차단 VPN(Virtual Private Network, 가상 사설 통신망) 인터넷 등 통신 사업자의 공중 네트워크에 암호화 기술을 이용하여 사용자가 마치 자신의 전용 회선을 사용하는 것처럼 해주는 보안 솔루션 암호화된 규격을 통해 인터넷망을 전용선의 사설망을 구축한 것처럼 이용 비용 부담이 줄어듬 원격지의 지사, 이동 근무자가 지역적 제한 없어짐 NAC(Network Access Control) 네트워크에 접속하는 내부PC의 MAC주소를 IP관리시스템에 등록한 후 일관된 보안 관리 기능을 제공하는 보안솔루션 MAC주소 랜카드 48bit 내부PC의 소프트웨어 사용 현황을 관리하여 불법적인 소프트웨어 설치를 방지 일반적인 배포 관리 기능을 이용해 백신이나 보안 패치 등의 설치 및 업그레이드 수행 네트워크에 접속한 비인가된 시스템을 자동으로 검출하여 자산을 관리 ESM(Enterprise Security Management) 다양한 장비에서 발생하는 로그 및 보안 이벤트를 통하여 관리하는 보안 솔루션 로그(방화벽, IDS, IPS, VPN) 및 보안 이벤트를 통합하여 관리함으로써 비용 및 자원 절약 보안 솔루션 간의 상호 연동을 통해 종합적인 보완 관리체계 수립 가능","link":"/2020/04/26/Engineer_Information_Processing/ch21_%EC%8B%9C%EC%8A%A4%ED%85%9C%EB%B3%B4%EC%95%88%EA%B5%AC%EC%B6%95/%EC%8B%9C%EC%8A%A4%ED%85%9C%EB%B3%B4%EC%95%88%EA%B5%AC%ED%98%84/%EB%B3%B4%EC%95%88%EC%86%94%EB%A3%A8%EC%85%98/"},{"title":"시스템보안구현 - 취약점분석","text":"시스템보안구축 시스템보안구현 취약점분석 개요 취약점 분석/평가의 개념 사이버 위협으로 부터 정보시스템의 취약점을 분석 및 평가한 후 개선하는 일련의 과정 안정적인 정보시스템의 운영을 방해하는 사이버 위협에 대한 항목별 점검항목 파악후 취약점 분석 수행 취약점이 발견되면 위험 등급 부여 후 개선 방향 수립 범위 및 항목 취약점 분석/평가 범위 및 항목 정보시스템과 정보시스템 자산에 직/간접적으로 관여된 물리적, 관리적, 기술적 분야를 포함 상, 중, 하 3 단계로 중요도 분리 '상’인 항목은 필수적으로 점검 ‘중’, '하’는 선택적으로 점검 수행 절차 및 방법 취약점 분석/평가 계획 수립 수행주체, 수행절차, 소요예산, 산출물 등의 세부 계획 수립 취약점 분석/평가 대상 선별 자산을 식별하고 유형별로 그룹화하여 평가 대상 목록을 작성 식별된 대상 목록의 각 자산에 대해 중요도 산정 취약점 분석 수행 관리적, 물리적, 기술적 세부 점검 항목표 작성 관리적 점검 정보보호 정책, 지침 등 관련 문서 확인 정보보호 담당자, 시스템 관리자, 사용자 등과 면담 물리적 점검 전산실, 발전실 등 통제구역 현장 점검 기술적 점검 점검도구 모의 해킹 취약점 평가 수행 세부 결과를 작성 위험등급 ‘상,중,하’ 표시 ‘상’ 은 조기 개선 ‘중’, ‘하’ 는 장기 개선으로 구분 후 개선 방향 수립","link":"/2020/04/26/Engineer_Information_Processing/ch21_%EC%8B%9C%EC%8A%A4%ED%85%9C%EB%B3%B4%EC%95%88%EA%B5%AC%EC%B6%95/%EC%8B%9C%EC%8A%A4%ED%85%9C%EB%B3%B4%EC%95%88%EA%B5%AC%ED%98%84/%EC%B7%A8%EC%95%BD%EC%A0%90%EB%B6%84%EC%84%9D/"},{"title":"시스템보안설계 - 서버접근통제","text":"시스템 보안 설계 서버 접근통제 Access Control 접근 통제 개념 사용자 및 장비의 접근 필요성에 따라 정보자산에 대한 접근 권한을 부여함으로써 비인가자의 무단 접근을 제한 통제 종류 - 비인가된 사용자의 접근 감시 - 접근 요구자의 사용자 식별 - 접근 요구의 정당성 확인 및 기록 - 보안 정책에 근거한 접근의 승인 및 거부 운동 접근 통제의 3요소 정책 매커니즘 보안모델 접근통제 정책 종류 임의적 접근통제 객체에 접근하고자 하는 주체의 접근 권한에 따라 접근 통제를 적용하는 방식 사용자가 접근권한을 임의적으로 추가하거나 철회하는 것이 가능 데이터 소유자가 사용자나 사용자 그룹의 신분에 따라 접근을 제어 기능 신원기반, 사용자 기반통제 방식 사용 강제적 접근통제 주체와 객체의 등급을 비교하여 접근 권한을 부여하는 방식 제3자가 접근 통제 권한을 지정 최상위보안등급을 가진 자도 모든 자료의 열람은 불가 보안등급, 규칙기반, 관리기반 접근통제 방식으로 모든 주체 및 객체에 대해 일정하며 어느 하나의 주체, 객체 단위로 접근제한을 설정할 수 없음 역할기반 접근통제 임의적 접근통제의 단점을 보완한 기법 비임의적 접근통제 사용자에게 최소한의 권한을 부여함으로 남용을 방지 직무에 따라 허가를 결정하므로 직원변경이 자주되는 구조에서 유리 접근통제 행렬 주체는 열에, 객체는 행에 표시하여 각각에 권한을 부여하는 방법 R : Read, W : Write 접근제어(AC) 사용자에 따라 공유데이터에 접근할 수 있는 권한을 제한하는 방법으로 접근의 허용을 결정하는 인증, 사용자의 행위에 대해 강제적으로 제약하는 인가가 있음 서버보안의 접근통제 3요소 인증 인가 감사","link":"/2020/04/26/Engineer_Information_Processing/ch21_%EC%8B%9C%EC%8A%A4%ED%85%9C%EB%B3%B4%EC%95%88%EA%B5%AC%EC%B6%95/%EC%8B%9C%EC%8A%A4%ED%85%9C%EB%B3%B4%EC%95%88%EC%84%A4%EA%B3%84/%EC%84%9C%EB%B2%84%EC%A0%91%EA%B7%BC%ED%86%B5%EC%A0%9C/"},{"title":"시스템보안설계 - 보안아키텍처","text":"시스템 보안 설계 보안아키텍처 보안 아키텍처의 개념 무결성, 가용성, 기밀성을 확보하기 위해 보안 요소 및 보안 체계를 식별하고 이들 간의 관계를 정의한 구조 보안의 3요소 Integrity 무결성 Availability 가용성 Confidentality 기밀성 관리적, 물리적, 기술적 보안 개념의 수립, 보안 관리 능력의 향상, 일관된 보안 수준의 유지를 기대함 관리적 보안 정보보호 정책 조직 분류 교육 및 훈련 인적 보안 업무 연속성 관리 물리적 보안 건물 및 사물실 출입 통제 지침 전산실 관리 지침 재해 복구 센터 운영 기술적 보안 사용자 인증 접근 제어 서버 네트워크 데이터 보안 수준에 변화가 생겨도 기본 보안 아키텍처의 수정 없이 지원할 수 있어야함 보안 프레임워크의 개념 프레임워크는 뼈대, 골조를 의미 안전한 정보시스템 환경을 유지하고 보안 수준을 향상시키기 위한 체계 ISO 27001은 정보보안 관리를 위한 국제 표준 조직에 대한 정보보안 관리 규격이 정의되어 있어 실제 심사/인증용으로 사용됨","link":"/2020/04/26/Engineer_Information_Processing/ch21_%EC%8B%9C%EC%8A%A4%ED%85%9C%EB%B3%B4%EC%95%88%EA%B5%AC%EC%B6%95/%EC%8B%9C%EC%8A%A4%ED%85%9C%EB%B3%B4%EC%95%88%EC%84%A4%EA%B3%84/%EB%B3%B4%EC%95%88%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98/"},{"title":"시스템보안설계 - 서비스공격유형(1)","text":"시스템 보안 설계 서비스 공격 유형 서비스 거부 공격의 개념과 서비스 거부 공격의 종류별 특징을 이해 서버 인증과 서버 접근 통제의 개념을 이해하고 인증의 종류와 접근 통제 정책의 종류를 이해 보안아키텍처와 보안 Framework의 개념 및 보안 통제 항목의 종류를 이해 서비스 거부 공격 - 서비스 공격은 일반적으로 서비스 거부(Dos) 공격을 뜻함 - 서버는 서비스 요청에 대해 서비스를 제공하는 의무가 있음 - 서버가 서비스 능력을 초과하는 요청을 도시다발적으로 받게 되면 서비스 불능상태로 마비됨 Ping Flood 하나의 사이트로 많은 양의 ICMP echo request를 요청할 때 이 사이트에서 존재하는 시스템 자원은 개별 메시지들에 각각 응답하기 위해 시스템 자원(resource)를 모두 사용해 버리는 점을 이용 ICMP : Internet Control Message Protocol TCP/IP 기반의 인터넷 통신 서비스에서 인터넷 프로토콜에 결합되어 전송되는 프로토콜로, IP에 대해 통신 중 발생하는 오류 처리와 전송 경로 변경, 에코 요청, 에코 응답 등을 제어하기 위한 메시지를 취급 1ping [주소] Ping of Death Ping 명령을 전송할 때 패킷의 크기를 인터넷 프로토콜 허용 범위(65,536 byte)이상으로 전송하여 공격 대상의 네트워크를 마비시키는 서비스 거부 공격 Ping 기본 크기 : 32byte 1ping -I 100 -n 5 [주소] SMURFING 엄청난 양의 데이터를 한 사이트에 집중적으로 보냄으로써 네트워크를 불능 상태로 만듬 공격자는 패킷의 송신 주소를 공격 대상의 IP주소로 위장하고 해당 네트워크 라우터의 브로드캐스트 주소를 수신지로 하여 패킷을 전송하면 라우터의 브로드캐스트 주소로 수신된 패킷은 해당 네트워크 내의 모든 컴퓨터로 전송함 - Broadcast : 네트워크에 연결된 전체 컴퓨터에 패킷을 전송할 때 사용하는 주소 해당 네트워크 내의 모든 컴퓨터는 수신된 패킷에 대한 응답 메시지를 송신 주소인 공격 대상 컴퓨터로 집중적으로 전송하게 되어 공격 대상지는 네트워크 과부하로 정상적인 서비스 수행이 불가능해짐 SYN Flooding(Synchronize sequence number) TCP는 신뢰성 있는 전송을 위해 3-way-handshake를 거친 후에 데이터를 전송 Client &gt; Server SYN 패킷 전송 대상 서버에 접속한다고 손을 내밈 Server &gt; Client SYN + ACK 패킷 전송 서버에는 접속해도 된다고 응답함 Client &gt; Server ACK(Acknowledgment) 패킷 전송 응답메시지를 받으면 데이터를 보냄 공격자가 가상의 클라이언트로 위장한 후 공격 대상지인 서버로 ‘SYN’ 신호를 보냄 서버는 'SYN+ACK’신호를 가상의 클라이언트로 보내면서 클라이언트의 접속을 받아들이기 위한 메모리의 일정 공간을 확보함 공격자가 사용할 수 없는 IP 주소를 이용하여 공격 대상지 서버로 반복적인 3-way-handshake 과정을 요청하면 공격 대상지 서버는 메모리 공간을 점점 더 많이 확보한 상태에서 대기하게 됨 대비 SYN 수신 대기 시간을 줄이거나 침입 차단 시스템을 활용 TearDrop 데이터의 송수신과정에서 패킷의 크기가 커서 여러 개로 분할되어 전송될 때 분할 순서를 알 수 있도록 Fragment Offset 값을 함께 전송 이때 Offset 값을 변경시켜 수신 측에서 패킷을 재조립할 때 오류로 인한 과부하 발생시켜 시스템 다운 유도 - 일반적으로 128kb로 토막낸다. 8개 - 다시 받을 때 합친다. 대비 - Fragment Offset 잘못된 경우 해당 패킷을 폐기 Land 패킷을 전송할 때 송신 IP주소와 수신 IP주소를 모두 공격 대상의 IP주소로 설정한 후 공격 대상에게 전송하는 것 이 패킷을 받은 공격 대상은 송신 IP주소가 자신이므로 자신에게 응답을 수행하는데 이러한 패킷이 계속해서 전송될 경우 자신에 대해 무한 응답하게 함 대비 송신 IP주소와 수신 IP 주소를 검사 DDoS(Distributed Denial of Service, 분산 서비스 거부) 공격 여러 곳에 분산된 공격 지점에서 한 곳에 서버에 대해 서비스 거부 공격을 수행 일부 호스트에 다수의 에이전트를 관리할 수 있는 핸들러 프로그램을 설치하여 마스터로 지정후 공격 취약점이 있는 호스트들을 탐색한 후 이들에 분산 서비스 공격용 툴을 설치하여 좀비PC로 만듬 분산 서비스 공격용 툴 - Trin00 - TFN - TFN2K - Stacheldraht","link":"/2020/04/26/Engineer_Information_Processing/ch21_%EC%8B%9C%EC%8A%A4%ED%85%9C%EB%B3%B4%EC%95%88%EA%B5%AC%EC%B6%95/%EC%8B%9C%EC%8A%A4%ED%85%9C%EB%B3%B4%EC%95%88%EC%84%A4%EA%B3%84/%EC%84%9C%EB%B9%84%EC%8A%A4%EA%B3%B5%EA%B2%A9%EC%9C%A0%ED%98%9501/"},{"title":"시스템보안설계 - 서버인증","text":"시스템 보안 설계 서버 인증 보안서버 개념 보안서버는 인터넷을 통한 개인정보를 암호화하여 송/수신할 수 잇는 기능을 갖춘 서버 Sniffing(스니핑)을 이용한 정보유출, Phishing(피싱)을 이용한 위조 사이트 등에 대비하기 위해 보안 서버 구축 필요 개인정보의 기술적/관리적 보호조치 기준에 따르면 다음을 갖추어야함 - 서버에 SSL(Secure Socket Laver) 인증서를 설치하여 정송 정볼르 암호화하여 송/수신 하는 기능 - 서버에 암호화 응용 프로그램을 설치하고 전송 정볼르 암호화하여 송/수신하는 기능 Authentication(인증)의 개념 인증은 다중 사용자 컴퓨터 시스템이나 네트워크 시스템에서 로그인을 요청한 사용자의 정보를 확인하고 접근 권한을 검증하는 보안절차 인증의 종류 - 지식기반인증 Something You Know - 소유기반인증 Something You Have - 생체기반인증 Something You Are - 행위기반인증 Something You Do 지식기반인증 사용자가 기억하고 있는 정보를 기반으로 인증을 수행하는 것 사용자의 기억을 기반으로 하므로 관리비용 저렴 인증기법 중 가장 보안에 취약함 예 - 아이디/비밀번호 - 아이핀 소유기반인증 사용자가 소유하고 있는 것을 기반으로 인증하는 것 소유물이 쉽게 도용될 수 있기 대문에 지식기반이나 생체기반 인증방식과 함께 사용 분실 및 도용의 위험이 존재 예 - 신분증 - 스마트 카드 - OTP 생체기반인증 사용자의 고유한 생체 정보를 기반으로 인증을 수행하는 것 사용이 쉽고 도난 위험도 적으며 위조가 어려움 예 - 지문 - 홍채/망막 - 얼굴 - 음성 - 정맥 행위기반인증 사용자의 행동 정보를 이용해 인증 수행 예 - 서명 위치기반인증 인증을 시도하는 위치의 적절성 확인 예 - GPS - IP","link":"/2020/04/26/Engineer_Information_Processing/ch21_%EC%8B%9C%EC%8A%A4%ED%85%9C%EB%B3%B4%EC%95%88%EA%B5%AC%EC%B6%95/%EC%8B%9C%EC%8A%A4%ED%85%9C%EB%B3%B4%EC%95%88%EC%84%A4%EA%B3%84/%EC%84%9C%EB%B2%84%EC%9D%B8%EC%A6%9D/"},{"title":"시스템보안설계 - 핵심정리","text":"시스템보안구축 시스템 보안 설계 핵심정리 서비스 공격 유형 서비스 거부 공격의 종류 Ping Flood Ping of Death Smurfing SYN Flooding TearDrop Land DDos 네트워크 침해 공격 Smishing APT Spear Phishing Qshing 정보 보안 침해 공격 Botnet Worm Zero Day Attack Ransomeware Trojan Horse Key Logger Attack 서버 인증 보안 서버는 인터넷을 통해 개인정보를 암호화하여 송/수신할 수 있는 기능을 갖춘 서버 인증은 다중 사용자 컴퓨터나 시스템이나 네트워크 시스템에서 로그인을 요청한 사용자의 정보를 확인하고 접근 권한을 검증하는 보안 절차 인증의 종류 지식기반인증 소유기반인증 생체기반인증 행위기반인증 서버 접근통제 사용자 및 장비의 접근 필요성에 따라 정보자산에 대한 접근 권한을 부여함으로써 비인가자의 무단 접근을 제한 접근통제의 3요소 정책 메커니즘 보안모델 접근통제 정책 종류 임의적 접근통제 강제적 접근통제 역할기반 접근통제 접근통제 행렬 접근제어(AC) 보안 아키텍처 정보시스템의 무결성, 가용성, 기밀성을 확보하기 위해 보안 요소 및 보안 체계를 식별하고 이들간의 관계를 정의한 구조 관리적, 물리적, 기술적 보안 개념의 수립, 보안관리 능력 향상, 일관된 보안 수준의 유지를 기대 보안 수준에 변화가 생겨도 기본 보안 아키텍처의 수정 없이 지원할 수 있어야 함 보안 요구사항의 변화나 추가를 수용할 수 있어야 함 보안 프레임워크 프레임워크는 뼈대, 골조를 의미 안전한 정보시스템 환경을 유지하고 보안 수준을 향상시키기 위한 체계 ISO 27001은 정보보안 관리를 위한 국제 표준으로 일종의 보안 인증이자 가장 대표적인 보안 프레임워크","link":"/2020/04/26/Engineer_Information_Processing/ch21_%EC%8B%9C%EC%8A%A4%ED%85%9C%EB%B3%B4%EC%95%88%EA%B5%AC%EC%B6%95/%EC%8B%9C%EC%8A%A4%ED%85%9C%EB%B3%B4%EC%95%88%EC%84%A4%EA%B3%84/%ED%95%B5%EC%8B%AC%EC%A0%95%EB%A6%AC.md/"},{"title":"시스템보안설계 - 서비스공격유형(2)","text":"시스템 보안 설계 네트워크 침해 공격 용어 Smishing 스미싱 문자메시지를 보낸 후 메시지에 있는 인터넷 주소를 클릭하면 악성코드를 설치하여 금융정보 빼냄 APT(Advanced Persistent Threats, 지능형 지속 위협) 특정기업이나 조직 네트워크에 침투해 활동 거점을 마련한 뒤 때를 기다리면서 보안을 무력화하고 정보를 수집한 다음 외부로 빼돌리는 형태의 공격 내부자에게 악성코드가 포함된 이메일을 오랜 기간 동안 꾸준히 발송해 클릭하기를 기다림 스턱스넷과 같이 악성코드가 담긴 USB로 전파 Spear Phishing 스피어 피싱 사회 공학의 한 기법 - Social Engineering : 인간 상호 작용의 깊은 신뢰를 바탕으로 사람들을 속여 정상 보안절차를 깨뜨리기 위한 비기술적 시스템 침입 수단 특정 대상을 선정 후 일반적인 메일로 위장 후 지속적으로 발송하여 발송 메일의 링크나 첨부 파일을 클릭하도록 유도해 사용자의 개인 정보를 탈취 Qshing 큐싱 QR(Quick Rsponse Code)를 통해 악성 앱의 다운로드 유도 정보 보안 침해 공격 용어 Botnet 봇넷 악성 프로그램에 감염되어 악의적인 의도로 사용될 수 있는 다수의 컴퓨터들이 네트워크로 연결된 형태 Worm 웜 네트워크를 통해 연속적으로 자신을 복제하여 시스템의 부하를 높임으로써 결국 시스템을 다운시키는 바이러스 Zero Day Attack 제로데이공격 보안 취약점이 발견되었을 때 발견된 취약점의 존재 자체가 널리 공표되기 전에 해당 취약점을 통하여 이루어지는 보안 공격으로 공격의 신속성 의미 Ransomware 랜섬웨어 인터넷 사용자의 컴퓨터에 잠입해 내부 문서나 파일 등을 암호화해 사용자가 열지 못하게 하는 프로그램 암호 해독용 프로그램의 전달을 조건으로 돈을 요구 Trojan Horse 트로이 목마 정상적인 기능을 하는 프로그램으로 위장 프로그램 내에 숨어 있다가 해당 프로그램이 동작할 때 활성화 되어 부작용을 일으킴 자기 복제 능력은 없음 Key Logger Attack 키로거 공격 컴퓨터 사용자의 키보드 움직임을 탐지해 id, pw, 계좌번호 등 같은 개인의 중요한 정보를 몰래 빼가는 해킹","link":"/2020/04/26/Engineer_Information_Processing/ch21_%EC%8B%9C%EC%8A%A4%ED%85%9C%EB%B3%B4%EC%95%88%EA%B5%AC%EC%B6%95/%EC%8B%9C%EC%8A%A4%ED%85%9C%EB%B3%B4%EC%95%88%EC%84%A4%EA%B3%84/%EC%84%9C%EB%B9%84%EC%8A%A4%EA%B3%B5%EA%B2%A9%EC%9C%A0%ED%98%9502/"}],"tags":[{"name":"데이터분석","slug":"데이터분석","link":"/tags/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B6%84%EC%84%9D/"},{"name":"데이터사이언스개념","slug":"데이터사이언스개념","link":"/tags/%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%82%AC%EC%9D%B4%EC%96%B8%EC%8A%A4%EA%B0%9C%EB%85%90/"},{"name":"python 자료형","slug":"python-자료형","link":"/tags/python-%EC%9E%90%EB%A3%8C%ED%98%95/"},{"name":"c 자료형","slug":"c-자료형","link":"/tags/c-%EC%9E%90%EB%A3%8C%ED%98%95/"},{"name":"데이터분석 - 순열 - 조합","slug":"데이터분석-순열-조합","link":"/tags/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B6%84%EC%84%9D-%EC%88%9C%EC%97%B4-%EC%A1%B0%ED%95%A9/"},{"name":"WordCloud","slug":"WordCloud","link":"/tags/WordCloud/"},{"name":"konlpy","slug":"konlpy","link":"/tags/konlpy/"},{"name":"한국어임베딩","slug":"한국어임베딩","link":"/tags/%ED%95%9C%EA%B5%AD%EC%96%B4%EC%9E%84%EB%B2%A0%EB%94%A9/"},{"name":"embedding","slug":"embedding","link":"/tags/embedding/"},{"name":"자연어처리","slug":"자연어처리","link":"/tags/%EC%9E%90%EC%97%B0%EC%96%B4%EC%B2%98%EB%A6%AC/"},{"name":"NLP배경","slug":"NLP배경","link":"/tags/NLP%EB%B0%B0%EA%B2%BD/"},{"name":"Machine_Translation","slug":"Machine-Translation","link":"/tags/Machine-Translation/"},{"name":"Sequence_Tagging","slug":"Sequence-Tagging","link":"/tags/Sequence-Tagging/"},{"name":"Anaconda","slug":"Anaconda","link":"/tags/Anaconda/"},{"name":"Recurrent Neural Network","slug":"Recurrent-Neural-Network","link":"/tags/Recurrent-Neural-Network/"},{"name":"ChatBot","slug":"ChatBot","link":"/tags/ChatBot/"},{"name":"논문","slug":"논문","link":"/tags/%EB%85%BC%EB%AC%B8/"},{"name":"python","slug":"python","link":"/tags/python/"},{"name":"class","slug":"class","link":"/tags/class/"},{"name":"Vector","slug":"Vector","link":"/tags/Vector/"},{"name":"소프트스킬","slug":"소프트스킬","link":"/tags/%EC%86%8C%ED%94%84%ED%8A%B8%EC%8A%A4%ED%82%AC/"},{"name":"정보처리기사","slug":"정보처리기사","link":"/tags/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/"},{"name":"핵심정리","slug":"핵심정리","link":"/tags/%ED%95%B5%EC%8B%AC%EC%A0%95%EB%A6%AC/"},{"name":"애플리케이션테스트결과분석","slug":"애플리케이션테스트결과분석","link":"/tags/%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98%ED%85%8C%EC%8A%A4%ED%8A%B8%EA%B2%B0%EA%B3%BC%EB%B6%84%EC%84%9D/"},{"name":"애플리케이션테스트시나리오작성","slug":"애플리케이션테스트시나리오작성","link":"/tags/%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98%ED%85%8C%EC%8A%A4%ED%8A%B8%EC%8B%9C%EB%82%98%EB%A6%AC%EC%98%A4%EC%9E%91%EC%84%B1/"},{"name":"애플리케이션테스트케이스작성","slug":"애플리케이션테스트케이스작성","link":"/tags/%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98%ED%85%8C%EC%8A%A4%ED%8A%B8%EC%BC%80%EC%9D%B4%EC%8A%A4%EC%9E%91%EC%84%B1/"},{"name":"애플리케이션통합테스트수행","slug":"애플리케이션통합테스트수행","link":"/tags/%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98%ED%86%B5%ED%95%A9%ED%85%8C%EC%8A%A4%ED%8A%B8%EC%88%98%ED%96%89/"},{"name":"오류처리확인및보고서작성","slug":"오류처리확인및보고서작성","link":"/tags/%EC%98%A4%EB%A5%98%EC%B2%98%EB%A6%AC%ED%99%95%EC%9D%B8%EB%B0%8F%EB%B3%B4%EA%B3%A0%EC%84%9C%EC%9E%91%EC%84%B1/"},{"name":"인터페이스구현검증","slug":"인터페이스구현검증","link":"/tags/%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4%EA%B5%AC%ED%98%84%EA%B2%80%EC%A6%9D/"},{"name":"인터페이스보안","slug":"인터페이스보안","link":"/tags/%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4%EB%B3%B4%EC%95%88/"},{"name":"소프트웨어연계테스트","slug":"소프트웨어연계테스트","link":"/tags/%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4%EC%97%B0%EA%B3%84%ED%85%8C%EC%8A%A4%ED%8A%B8/"},{"name":"사용자정의함수","slug":"사용자정의함수","link":"/tags/%EC%82%AC%EC%9A%A9%EC%9E%90%EC%A0%95%EC%9D%98%ED%95%A8%EC%88%98/"},{"name":"오류처리","slug":"오류처리","link":"/tags/%EC%98%A4%EB%A5%98%EC%B2%98%EB%A6%AC/"},{"name":"집계성DCL작성","slug":"집계성DCL작성","link":"/tags/%EC%A7%91%EA%B3%84%EC%84%B1DCL%EC%9E%91%EC%84%B1/"},{"name":"데이터표준확인","slug":"데이터표준확인","link":"/tags/%EB%8D%B0%EC%9D%B4%ED%84%B0%ED%91%9C%EC%A4%80%ED%99%95%EC%9D%B8/"},{"name":"인터페이스기능확인","slug":"인터페이스기능확인","link":"/tags/%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4%EA%B8%B0%EB%8A%A5%ED%99%95%EC%9D%B8/"},{"name":"이벤트","slug":"이벤트","link":"/tags/%EC%9D%B4%EB%B2%A4%ED%8A%B8/"},{"name":"관계데이터베이스모델","slug":"관계데이터베이스모델","link":"/tags/%EA%B4%80%EA%B3%84%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EB%AA%A8%EB%8D%B8/"},{"name":"트리거","slug":"트리거","link":"/tags/%ED%8A%B8%EB%A6%AC%EA%B1%B0/"},{"name":"시스템카탈로그와뷰","slug":"시스템카탈로그와뷰","link":"/tags/%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%B9%B4%ED%83%88%EB%A1%9C%EA%B7%B8%EC%99%80%EB%B7%B0/"},{"name":"관계데이터언어","slug":"관계데이터언어","link":"/tags/%EA%B4%80%EA%B3%84%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%96%B8%EC%96%B4/"},{"name":"ER모델","slug":"ER모델","link":"/tags/ER%EB%AA%A8%EB%8D%B8/"},{"name":"논리데이터모델품질검증","slug":"논리데이터모델품질검증","link":"/tags/%EB%85%BC%EB%A6%AC%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%AA%A8%EB%8D%B8%ED%92%88%EC%A7%88%EA%B2%80%EC%A6%9D/"},{"name":"데이터모델개념","slug":"데이터모델개념","link":"/tags/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%AA%A8%EB%8D%B8%EA%B0%9C%EB%85%90/"},{"name":"논리적데이터모델링","slug":"논리적데이터모델링","link":"/tags/%EB%85%BC%EB%A6%AC%EC%A0%81%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%AA%A8%EB%8D%B8%EB%A7%81/"},{"name":"데이터베이스백업","slug":"데이터베이스백업","link":"/tags/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EB%B0%B1%EC%97%85/"},{"name":"데이터베이스용량설계","slug":"데이터베이스용량설계","link":"/tags/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EC%9A%A9%EB%9F%89%EC%84%A4%EA%B3%84/"},{"name":"데이터지역화","slug":"데이터지역화","link":"/tags/%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%A7%80%EC%97%AD%ED%99%94/"},{"name":"데이터베이스정규화","slug":"데이터베이스정규화","link":"/tags/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EC%A0%95%EA%B7%9C%ED%99%94/"},{"name":"클러스터링","slug":"클러스터링","link":"/tags/%ED%81%B4%EB%9F%AC%EC%8A%A4%ED%84%B0%EB%A7%81/"},{"name":"파티셔닝","slug":"파티셔닝","link":"/tags/%ED%8C%8C%ED%8B%B0%EC%85%94%EB%8B%9D/"},{"name":"CRUD분석","slug":"CRUD분석","link":"/tags/CRUD%EB%B6%84%EC%84%9D/"},{"name":"ER다이어그램","slug":"ER다이어그램","link":"/tags/ER%EB%8B%A4%EC%9D%B4%EC%96%B4%EA%B7%B8%EB%9E%A8/"},{"name":"물리데이터모델품질기준","slug":"물리데이터모델품질기준","link":"/tags/%EB%AC%BC%EB%A6%AC%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%AA%A8%EB%8D%B8%ED%92%88%EC%A7%88%EA%B8%B0%EC%A4%80/"},{"name":"반정규화","slug":"반정규화","link":"/tags/%EB%B0%98%EC%A0%95%EA%B7%9C%ED%99%94/"},{"name":"칼럼속성","slug":"칼럼속성","link":"/tags/%EC%B9%BC%EB%9F%BC%EC%86%8D%EC%84%B1/"},{"name":"키종류","slug":"키종류","link":"/tags/%ED%82%A4%EC%A2%85%EB%A5%98/"},{"name":"데이터베이스무결성","slug":"데이터베이스무결성","link":"/tags/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EB%AC%B4%EA%B2%B0%EC%84%B1/"},{"name":"데이터베이스암호화","slug":"데이터베이스암호화","link":"/tags/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EC%95%94%ED%98%B8%ED%99%94/"},{"name":"데이터베이스이중화구성","slug":"데이터베이스이중화구성","link":"/tags/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EC%9D%B4%EC%A4%91%ED%99%94%EA%B5%AC%EC%84%B1/"},{"name":"분산데이터베이스","slug":"분산데이터베이스","link":"/tags/%EB%B6%84%EC%82%B0%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4/"},{"name":"물리요소조사분석","slug":"물리요소조사분석","link":"/tags/%EB%AC%BC%EB%A6%AC%EC%9A%94%EC%86%8C%EC%A1%B0%EC%82%AC%EB%B6%84%EC%84%9D/"},{"name":"초기데이터구축","slug":"초기데이터구축","link":"/tags/%EC%B4%88%EA%B8%B0%EB%8D%B0%EC%9D%B4%ED%84%B0%EA%B5%AC%EC%B6%95/"},{"name":"ETL","slug":"ETL","link":"/tags/ETL/"},{"name":"파일처리기술","slug":"파일처리기술","link":"/tags/%ED%8C%8C%EC%9D%BC%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%88%A0/"},{"name":"데이터검증","slug":"데이터검증","link":"/tags/%EB%8D%B0%EC%9D%B4%ED%84%B0%EA%B2%80%EC%A6%9D/"},{"name":"데이터전환수행계획","slug":"데이터전환수행계획","link":"/tags/%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%A0%84%ED%99%98%EC%88%98%ED%96%89%EA%B3%84%ED%9A%8D/"},{"name":"체크리스트","slug":"체크리스트","link":"/tags/%EC%B2%B4%ED%81%AC%EB%A6%AC%EC%8A%A4%ED%8A%B8/"},{"name":"데이터품질분석","slug":"데이터품질분석","link":"/tags/%EB%8D%B0%EC%9D%B4%ED%84%B0%ED%92%88%EC%A7%88%EB%B6%84%EC%84%9D/"},{"name":"데이터정제","slug":"데이터정제","link":"/tags/%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%A0%95%EC%A0%9C/"},{"name":"개발환경구축","slug":"개발환경구축","link":"/tags/%EA%B0%9C%EB%B0%9C%ED%99%98%EA%B2%BD%EA%B5%AC%EC%B6%95/"},{"name":"서버개발프레임워크","slug":"서버개발프레임워크","link":"/tags/%EC%84%9C%EB%B2%84%EA%B0%9C%EB%B0%9C%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC/"},{"name":"오류데이터측정","slug":"오류데이터측정","link":"/tags/%EC%98%A4%EB%A5%98%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%B8%A1%EC%A0%95/"},{"name":"모델화","slug":"모델화","link":"/tags/%EB%AA%A8%EB%8D%B8%ED%99%94/"},{"name":"재사용","slug":"재사용","link":"/tags/%EC%9E%AC%EC%82%AC%EC%9A%A9/"},{"name":"배치프로그램","slug":"배치프로그램","link":"/tags/%EB%B0%B0%EC%B9%98%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8/"},{"name":"API","slug":"API","link":"/tags/API/"},{"name":"보안취약성식별","slug":"보안취약성식별","link":"/tags/%EB%B3%B4%EC%95%88%EC%B7%A8%EC%95%BD%EC%84%B1%EC%8B%9D%EB%B3%84/"},{"name":"DB서버","slug":"DB서버","link":"/tags/DB%EC%84%9C%EB%B2%84/"},{"name":"웹서버","slug":"웹서버","link":"/tags/%EC%9B%B9%EC%84%9C%EB%B2%84/"},{"name":"패키지","slug":"패키지","link":"/tags/%ED%8C%A8%ED%82%A4%EC%A7%80/"},{"name":"Package","slug":"Package","link":"/tags/Package/"},{"name":"IP","slug":"IP","link":"/tags/IP/"},{"name":"TCP_UDP","slug":"TCP-UDP","link":"/tags/TCP-UDP/"},{"name":"인터넷구성의개념","slug":"인터넷구성의개념","link":"/tags/%EC%9D%B8%ED%84%B0%EB%84%B7%EA%B5%AC%EC%84%B1%EC%9D%98%EA%B0%9C%EB%85%90/"},{"name":"네트워크7계층","slug":"네트워크7계층","link":"/tags/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC7%EA%B3%84%EC%B8%B5/"},{"name":"ShellScript","slug":"ShellScript","link":"/tags/ShellScript/"},{"name":"메모리관리","slug":"메모리관리","link":"/tags/%EB%A9%94%EB%AA%A8%EB%A6%AC%EA%B4%80%EB%A6%AC/"},{"name":"운영체제","slug":"운영체제","link":"/tags/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/"},{"name":"프로세스스케줄링","slug":"프로세스스케줄링","link":"/tags/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81/"},{"name":"환경변수","slug":"환경변수","link":"/tags/%ED%99%98%EA%B2%BD%EB%B3%80%EC%88%98/"},{"name":"변수","slug":"변수","link":"/tags/%EB%B3%80%EC%88%98/"},{"name":"연산자","slug":"연산자","link":"/tags/%EC%97%B0%EC%82%B0%EC%9E%90/"},{"name":"데이터타입","slug":"데이터타입","link":"/tags/%EB%8D%B0%EC%9D%B4%ED%84%B0%ED%83%80%EC%9E%85/"},{"name":"데이터입출력","slug":"데이터입출력","link":"/tags/%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%9E%85%EC%B6%9C%EB%A0%A5/"},{"name":"예외처리","slug":"예외처리","link":"/tags/%EC%98%88%EC%99%B8%EC%B2%98%EB%A6%AC/"},{"name":"라이브러리","slug":"라이브러리","link":"/tags/%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC/"},{"name":"프로토타입","slug":"프로토타입","link":"/tags/%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85/"},{"name":"객체지향프로그래밍언어","slug":"객체지향프로그래밍언어","link":"/tags/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%96%B8%EC%96%B4/"},{"name":"스크립트언어","slug":"스크립트언어","link":"/tags/%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EC%96%B8%EC%96%B4/"},{"name":"절차적프로그래밍언어","slug":"절차적프로그래밍언어","link":"/tags/%EC%A0%88%EC%B0%A8%EC%A0%81%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%96%B8%EC%96%B4/"},{"name":"SW개발방법론","slug":"SW개발방법론","link":"/tags/SW%EA%B0%9C%EB%B0%9C%EB%B0%A9%EB%B2%95%EB%A1%A0/"},{"name":"SW개발방법론선정","slug":"SW개발방법론선정","link":"/tags/SW%EA%B0%9C%EB%B0%9C%EB%B0%A9%EB%B2%95%EB%A1%A0%EC%84%A0%EC%A0%95/"},{"name":"비용산정모델","slug":"비용산정모델","link":"/tags/%EB%B9%84%EC%9A%A9%EC%82%B0%EC%A0%95%EB%AA%A8%EB%8D%B8/"},{"name":"소프트웨어개발프레임워크","slug":"소프트웨어개발프레임워크","link":"/tags/%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4%EA%B0%9C%EB%B0%9C%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC/"},{"name":"요구공학방법론","slug":"요구공학방법론","link":"/tags/%EC%9A%94%EA%B5%AC%EA%B3%B5%ED%95%99%EB%B0%A9%EB%B2%95%EB%A1%A0/"},{"name":"선언형언어","slug":"선언형언어","link":"/tags/%EC%84%A0%EC%96%B8%ED%98%95%EC%96%B8%EC%96%B4/"},{"name":"DB관련신기술","slug":"DB관련신기술","link":"/tags/DB%EA%B4%80%EB%A0%A8%EC%8B%A0%EA%B8%B0%EC%88%A0/"},{"name":"SW개발표준","slug":"SW개발표준","link":"/tags/SW%EA%B0%9C%EB%B0%9C%ED%91%9C%EC%A4%80/"},{"name":"테일러링기준","slug":"테일러링기준","link":"/tags/%ED%85%8C%EC%9D%BC%EB%9F%AC%EB%A7%81%EA%B8%B0%EC%A4%80/"},{"name":"DB관리기능","slug":"DB관리기능","link":"/tags/DB%EA%B4%80%EB%A6%AC%EA%B8%B0%EB%8A%A5/"},{"name":"서버장비운영","slug":"서버장비운영","link":"/tags/%EC%84%9C%EB%B2%84%EC%9E%A5%EB%B9%84%EC%9A%B4%EC%98%81/"},{"name":"DB표준화","slug":"DB표준화","link":"/tags/DB%ED%91%9C%EC%A4%80%ED%99%94/"},{"name":"SW개발보안정책","slug":"SW개발보안정책","link":"/tags/SW%EA%B0%9C%EB%B0%9C%EB%B3%B4%EC%95%88%EC%A0%95%EC%B1%85/"},{"name":"SW관련신기술","slug":"SW관련신기술","link":"/tags/SW%EA%B4%80%EB%A0%A8%EC%8B%A0%EA%B8%B0%EC%88%A0/"},{"name":"네트워크관련신기술","slug":"네트워크관련신기술","link":"/tags/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC%EA%B4%80%EB%A0%A8%EC%8B%A0%EA%B8%B0%EC%88%A0/"},{"name":"네트워크장비","slug":"네트워크장비","link":"/tags/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC%EC%9E%A5%EB%B9%84/"},{"name":"암호알고리즘","slug":"암호알고리즘","link":"/tags/%EC%95%94%ED%98%B8%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"},{"name":"API오용","slug":"API오용","link":"/tags/API%EC%98%A4%EC%9A%A9/"},{"name":"HW관련신기술","slug":"HW관련신기술","link":"/tags/HW%EA%B4%80%EB%A0%A8%EC%8B%A0%EA%B8%B0%EC%88%A0/"},{"name":"캡슐화","slug":"캡슐화","link":"/tags/%EC%BA%A1%EC%8A%90%ED%99%94/"},{"name":"코드오류","slug":"코드오류","link":"/tags/%EC%BD%94%EB%93%9C%EC%98%A4%EB%A5%98/"},{"name":"SDLC","slug":"SDLC","link":"/tags/SDLC/"},{"name":"세션통제","slug":"세션통제","link":"/tags/%EC%84%B8%EC%85%98%ED%86%B5%EC%A0%9C/"},{"name":"입력데이터검증및표현","slug":"입력데이터검증및표현","link":"/tags/%EC%9E%85%EB%A0%A5%EB%8D%B0%EC%9D%B4%ED%84%B0%EA%B2%80%EC%A6%9D%EB%B0%8F%ED%91%9C%ED%98%84/"},{"name":"로그분석","slug":"로그분석","link":"/tags/%EB%A1%9C%EA%B7%B8%EB%B6%84%EC%84%9D/"},{"name":"보안기능","slug":"보안기능","link":"/tags/%EB%B3%B4%EC%95%88%EA%B8%B0%EB%8A%A5/"},{"name":"보안솔루션","slug":"보안솔루션","link":"/tags/%EB%B3%B4%EC%95%88%EC%86%94%EB%A3%A8%EC%85%98/"},{"name":"취약점분석","slug":"취약점분석","link":"/tags/%EC%B7%A8%EC%95%BD%EC%A0%90%EB%B6%84%EC%84%9D/"},{"name":"서버접근통제","slug":"서버접근통제","link":"/tags/%EC%84%9C%EB%B2%84%EC%A0%91%EA%B7%BC%ED%86%B5%EC%A0%9C/"},{"name":"보안아키텍처","slug":"보안아키텍처","link":"/tags/%EB%B3%B4%EC%95%88%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98/"},{"name":"서비스공격유형","slug":"서비스공격유형","link":"/tags/%EC%84%9C%EB%B9%84%EC%8A%A4%EA%B3%B5%EA%B2%A9%EC%9C%A0%ED%98%95/"},{"name":"서버인증","slug":"서버인증","link":"/tags/%EC%84%9C%EB%B2%84%EC%9D%B8%EC%A6%9D/"},{"name":"네트워크침해공격용어","slug":"네트워크침해공격용어","link":"/tags/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC%EC%B9%A8%ED%95%B4%EA%B3%B5%EA%B2%A9%EC%9A%A9%EC%96%B4/"},{"name":"정보보안침해공격용어","slug":"정보보안침해공격용어","link":"/tags/%EC%A0%95%EB%B3%B4%EB%B3%B4%EC%95%88%EC%B9%A8%ED%95%B4%EA%B3%B5%EA%B2%A9%EC%9A%A9%EC%96%B4/"}],"categories":[{"name":"데이터사이언스","slug":"데이터사이언스","link":"/categories/%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%82%AC%EC%9D%B4%EC%96%B8%EC%8A%A4/"},{"name":"데이터분석","slug":"데이터사이언스/데이터분석","link":"/categories/%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%82%AC%EC%9D%B4%EC%96%B8%EC%8A%A4/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B6%84%EC%84%9D/"},{"name":"Error해결","slug":"Error해결","link":"/categories/Error%ED%95%B4%EA%B2%B0/"},{"name":"자연어처리","slug":"자연어처리","link":"/categories/%EC%9E%90%EC%97%B0%EC%96%B4%EC%B2%98%EB%A6%AC/"},{"name":"ChatBot","slug":"자연어처리/ChatBot","link":"/categories/%EC%9E%90%EC%97%B0%EC%96%B4%EC%B2%98%EB%A6%AC/ChatBot/"},{"name":"임베딩","slug":"자연어처리/임베딩","link":"/categories/%EC%9E%90%EC%97%B0%EC%96%B4%EC%B2%98%EB%A6%AC/%EC%9E%84%EB%B2%A0%EB%94%A9/"},{"name":"논문","slug":"논문","link":"/categories/%EB%85%BC%EB%AC%B8/"},{"name":"파이썬","slug":"파이썬","link":"/categories/%ED%8C%8C%EC%9D%B4%EC%8D%AC/"},{"name":"NLP","slug":"자연어처리/NLP","link":"/categories/%EC%9E%90%EC%97%B0%EC%96%B4%EC%B2%98%EB%A6%AC/NLP/"},{"name":"독서","slug":"독서","link":"/categories/%EB%8F%85%EC%84%9C/"},{"name":"Anaconda","slug":"자연어처리/Anaconda","link":"/categories/%EC%9E%90%EC%97%B0%EC%96%B4%EC%B2%98%EB%A6%AC/Anaconda/"},{"name":"문법","slug":"파이썬/문법","link":"/categories/%ED%8C%8C%EC%9D%B4%EC%8D%AC/%EB%AC%B8%EB%B2%95/"},{"name":"정보처리기사","slug":"정보처리기사","link":"/categories/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/"},{"name":"애플리케이션테스트케이스설계","slug":"정보처리기사/애플리케이션테스트케이스설계","link":"/categories/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98%ED%85%8C%EC%8A%A4%ED%8A%B8%EC%BC%80%EC%9D%B4%EC%8A%A4%EC%84%A4%EA%B3%84/"},{"name":"인터페이스설계확인","slug":"정보처리기사/인터페이스설계확인","link":"/categories/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4%EC%84%A4%EA%B3%84%ED%99%95%EC%9D%B8/"},{"name":"절차형SQL","slug":"정보처리기사/절차형SQL","link":"/categories/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/%EC%A0%88%EC%B0%A8%ED%98%95SQL/"},{"name":"논리데이터베이스","slug":"정보처리기사/논리데이터베이스","link":"/categories/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/%EB%85%BC%EB%A6%AC%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4/"},{"name":"물리데이터베이스","slug":"정보처리기사/물리데이터베이스","link":"/categories/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/%EB%AC%BC%EB%A6%AC%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4/"},{"name":"데이터전환","slug":"정보처리기사/데이터전환","link":"/categories/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%A0%84%ED%99%98/"},{"name":"서버프로그램구현","slug":"정보처리기사/서버프로그램구현","link":"/categories/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/%EC%84%9C%EB%B2%84%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8%EA%B5%AC%ED%98%84/"},{"name":"기본개발환경구축","slug":"정보처리기사/기본개발환경구축","link":"/categories/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/%EA%B8%B0%EB%B3%B8%EA%B0%9C%EB%B0%9C%ED%99%98%EA%B2%BD%EA%B5%AC%EC%B6%95/"},{"name":"응용SW기초기술활용","slug":"정보처리기사/응용SW기초기술활용","link":"/categories/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/%EC%9D%91%EC%9A%A9SW%EA%B8%B0%EC%B4%88%EA%B8%B0%EC%88%A0%ED%99%9C%EC%9A%A9/"},{"name":"프로그래밍언어활용","slug":"정보처리기사/프로그래밍언어활용","link":"/categories/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%96%B8%EC%96%B4%ED%99%9C%EC%9A%A9/"},{"name":"SW개발방법론선정","slug":"정보처리기사/SW개발방법론선정","link":"/categories/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/SW%EA%B0%9C%EB%B0%9C%EB%B0%A9%EB%B2%95%EB%A1%A0%EC%84%A0%EC%A0%95/"},{"name":"SW개발방법론테일러링","slug":"정보처리기사/SW개발방법론테일러링","link":"/categories/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/SW%EA%B0%9C%EB%B0%9C%EB%B0%A9%EB%B2%95%EB%A1%A0%ED%85%8C%EC%9D%BC%EB%9F%AC%EB%A7%81/"},{"name":"DB구축관리","slug":"정보처리기사/DB구축관리","link":"/categories/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/DB%EA%B5%AC%EC%B6%95%EA%B4%80%EB%A6%AC/"},{"name":"HW구축관리","slug":"정보처리기사/HW구축관리","link":"/categories/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/HW%EA%B5%AC%EC%B6%95%EA%B4%80%EB%A6%AC/"},{"name":"SW구축관리","slug":"정보처리기사/SW구축관리","link":"/categories/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/SW%EA%B5%AC%EC%B6%95%EA%B4%80%EB%A6%AC/"},{"name":"네트워크구축관리","slug":"정보처리기사/네트워크구축관리","link":"/categories/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC%EA%B5%AC%EC%B6%95%EA%B4%80%EB%A6%AC/"},{"name":"소프트웨어개발보안구현","slug":"정보처리기사/소프트웨어개발보안구현","link":"/categories/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4%EA%B0%9C%EB%B0%9C%EB%B3%B4%EC%95%88%EA%B5%AC%ED%98%84/"},{"name":"소프트웨어개발보안구축","slug":"정보처리기사/소프트웨어개발보안구축","link":"/categories/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4%EA%B0%9C%EB%B0%9C%EB%B3%B4%EC%95%88%EA%B5%AC%EC%B6%95/"},{"name":"시스템보안구축","slug":"정보처리기사/시스템보안구축","link":"/categories/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/%EC%8B%9C%EC%8A%A4%ED%85%9C%EB%B3%B4%EC%95%88%EA%B5%AC%EC%B6%95/"},{"name":"시스템보안설계","slug":"정보처리기사/시스템보안설계","link":"/categories/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/%EC%8B%9C%EC%8A%A4%ED%85%9C%EB%B3%B4%EC%95%88%EC%84%A4%EA%B3%84/"}]}