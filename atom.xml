<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hello Engineering</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://hyeonukdev.github.io/"/>
  <updated>2020-05-18T13:50:19.000Z</updated>
  <id>https://hyeonukdev.github.io/</id>
  
  <author>
    <name>Hyeonukdev</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>절차형SQL - 핵심정리</title>
    <link href="https://hyeonukdev.github.io/2020/05/18/Engineer_Information_Processing/ch10_SQL%EC%9D%91%EC%9A%A9/%EC%A0%88%EC%B0%A8%ED%98%95SQL/%ED%95%B5%EC%8B%AC%EC%A0%95%EB%A6%AC/"/>
    <id>https://hyeonukdev.github.io/2020/05/18/Engineer_Information_Processing/ch10_SQL%EC%9D%91%EC%9A%A9/%EC%A0%88%EC%B0%A8%ED%98%95SQL/%ED%95%B5%EC%8B%AC%EC%A0%95%EB%A6%AC/</id>
    <published>2020-05-18T13:50:19.000Z</published>
    <updated>2020-05-18T13:50:19.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="절차형sql"><a class="markdownIt-Anchor" href="#절차형sql"></a> 절차형SQL</h2><h3 id="1-사용자-정의함수"><a class="markdownIt-Anchor" href="#1-사용자-정의함수"></a> 1. 사용자 정의함수</h3><ul><li>절차형 SQL을 활용하여 일련의 <u>연산 처리 결과를 단일값으로 변환</u></li><li>DBMS에서 제공되는 공통적 함수 이외에 <u>사용자가 직접 정의하고 작성</u></li><li><u>호출을 통해 실행되며, 단일값을 조회 또는 삽입, 수정 작업에 이용</u></li></ul><h3 id="2-트리거"><a class="markdownIt-Anchor" href="#2-트리거"></a> 2. 트리거</h3><ul><li>특정 테이블에 <u>삽입, 수정, 삭제 등의 데이터 변경 이벤트가 발생하면 DBMS에서 자동적으로 실행</u>되도록 구현된 프로그램</li><li>이벤트는 <u>전체 트랜잭션 대상과 각 행에 의해 발생되는 경우 모두를 포함할 수 있으며 테이블과 뷰, DB작업을 대상으로 정의</u></li><li>데이터 제어어 사용 불가</li></ul><h3 id="3-이벤트"><a class="markdownIt-Anchor" href="#3-이벤트"></a> 3. 이벤트</h3><ul><li>특정 시간에 특정한 쿼리, 프로시저, 함수 등을 실행시키는 기능</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;절차형sql&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#절차형sql&quot;&gt;&lt;/a&gt; 절차형SQL&lt;/h2&gt;
&lt;h3 id=&quot;1-사용자-정의함수&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1-사용자-정
      
    
    </summary>
    
    
      <category term="정보처리기사" scheme="https://hyeonukdev.github.io/categories/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/"/>
    
      <category term="절차형SQL" scheme="https://hyeonukdev.github.io/categories/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/%EC%A0%88%EC%B0%A8%ED%98%95SQL/"/>
    
    
      <category term="정보처리기사" scheme="https://hyeonukdev.github.io/tags/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/"/>
    
      <category term="핵심정리" scheme="https://hyeonukdev.github.io/tags/%ED%95%B5%EC%8B%AC%EC%A0%95%EB%A6%AC/"/>
    
  </entry>
  
  <entry>
    <title>절차형SQL - 이벤트</title>
    <link href="https://hyeonukdev.github.io/2020/05/18/Engineer_Information_Processing/ch10_SQL%EC%9D%91%EC%9A%A9/%EC%A0%88%EC%B0%A8%ED%98%95SQL/%EC%9D%B4%EB%B2%A4%ED%8A%B8/"/>
    <id>https://hyeonukdev.github.io/2020/05/18/Engineer_Information_Processing/ch10_SQL%EC%9D%91%EC%9A%A9/%EC%A0%88%EC%B0%A8%ED%98%95SQL/%EC%9D%B4%EB%B2%A4%ED%8A%B8/</id>
    <published>2020-05-18T13:48:16.000Z</published>
    <updated>2020-05-18T13:48:16.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="절차형sql"><a class="markdownIt-Anchor" href="#절차형sql"></a> 절차형SQL</h2><h3 id="이벤트의-개념"><a class="markdownIt-Anchor" href="#이벤트의-개념"></a> 이벤트의 개념</h3><ul><li>특정 시간에 특정한 쿼리, 프로시저, 함수 등을 실행시키는 기능</li></ul><h3 id="이벤트-생성-사례"><a class="markdownIt-Anchor" href="#이벤트-생성-사례"></a> 이벤트 생성 사례</h3><ul><li>MySql의 경우 이벤트를 생성시, mysql.evnet, information_schema, events 테이블에 자동으로 등록</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;절차형sql&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#절차형sql&quot;&gt;&lt;/a&gt; 절차형SQL&lt;/h2&gt;
&lt;h3 id=&quot;이벤트의-개념&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#이벤트의-개념&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="정보처리기사" scheme="https://hyeonukdev.github.io/categories/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/"/>
    
      <category term="절차형SQL" scheme="https://hyeonukdev.github.io/categories/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/%EC%A0%88%EC%B0%A8%ED%98%95SQL/"/>
    
    
      <category term="정보처리기사" scheme="https://hyeonukdev.github.io/tags/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/"/>
    
      <category term="이벤트" scheme="https://hyeonukdev.github.io/tags/%EC%9D%B4%EB%B2%A4%ED%8A%B8/"/>
    
  </entry>
  
  <entry>
    <title>절차형SQL - 트리거</title>
    <link href="https://hyeonukdev.github.io/2020/05/18/Engineer_Information_Processing/ch10_SQL%EC%9D%91%EC%9A%A9/%EC%A0%88%EC%B0%A8%ED%98%95SQL/%ED%8A%B8%EB%A6%AC%EA%B1%B0/"/>
    <id>https://hyeonukdev.github.io/2020/05/18/Engineer_Information_Processing/ch10_SQL%EC%9D%91%EC%9A%A9/%EC%A0%88%EC%B0%A8%ED%98%95SQL/%ED%8A%B8%EB%A6%AC%EA%B1%B0/</id>
    <published>2020-05-18T13:43:41.000Z</published>
    <updated>2020-05-18T13:43:41.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="절차형sql"><a class="markdownIt-Anchor" href="#절차형sql"></a> 절차형SQL</h2><h3 id="트리거의-개념"><a class="markdownIt-Anchor" href="#트리거의-개념"></a> 트리거의 개념</h3><ul><li>특정 테이블에 <u>삽입, 수정, 삭제 등의 데이터 변경 이벤트가 발생하면 DBMS에서 자동적으로 실행</u>되도록 구현된 프로그램</li><li>이벤트는 <u>전체 트랜잭션 대상과 각 행에 의해 발생되는 경우 모두를 포함할 수 있으며 테이블과 뷰, DB작업을 대상으로 정의</u></li></ul><h3 id="트리거의-목적"><a class="markdownIt-Anchor" href="#트리거의-목적"></a> 트리거의 목적</h3><ul><li>특정 테이블에 대한 <u>데이터 변경을 시작점으로 설정하고, 그와 관련된 작업을 자동적으로 수행</u></li><li>일반적으로 이벤트와 관련된 테이블의 데이터 삽입, 추가, 삭제 작업을 <u>DBMS가 자동적으로 실행시키는데 활용</u></li><li><u>데이터 무결성 유지 및 로그 메시지 출력</u>등의 별도 처릴르 위해 트리거 사용</li></ul><h3 id="트리거의-세-가지-구성-요소"><a class="markdownIt-Anchor" href="#트리거의-세-가지-구성-요소"></a> 트리거의 세 가지 구성 요소</h3><ol><li>트리거가 실행될 조건이 되는 문장이나 이벤트</li><li>실행 조건의 제약</li><li>실행될 내용</li></ol><h3 id="트리거-작성시-주의사항"><a class="markdownIt-Anchor" href="#트리거-작성시-주의사항"></a> 트리거 작성시 주의사항</h3><ol><li>데이터 제어어 사용불가<ul><li>트리거 내에 commit, rollback 등 사용 불가</li></ul></li><li>오류에 주의<ul><li>트리거 실행 중 오류가 발생시 트리거 실행의 원인을 제공한 데이터 작업에도 영향</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;절차형sql&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#절차형sql&quot;&gt;&lt;/a&gt; 절차형SQL&lt;/h2&gt;
&lt;h3 id=&quot;트리거의-개념&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#트리거의-개념&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="정보처리기사" scheme="https://hyeonukdev.github.io/categories/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/"/>
    
      <category term="절차형SQL" scheme="https://hyeonukdev.github.io/categories/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/%EC%A0%88%EC%B0%A8%ED%98%95SQL/"/>
    
    
      <category term="정보처리기사" scheme="https://hyeonukdev.github.io/tags/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/"/>
    
      <category term="트리거" scheme="https://hyeonukdev.github.io/tags/%ED%8A%B8%EB%A6%AC%EA%B1%B0/"/>
    
  </entry>
  
  <entry>
    <title>절차형SQL - 사용자 정의함수</title>
    <link href="https://hyeonukdev.github.io/2020/05/18/Engineer_Information_Processing/ch10_SQL%EC%9D%91%EC%9A%A9/%EC%A0%88%EC%B0%A8%ED%98%95SQL/%EC%82%AC%EC%9A%A9%EC%9E%90%EC%A0%95%EC%9D%98%ED%95%A8%EC%88%98/"/>
    <id>https://hyeonukdev.github.io/2020/05/18/Engineer_Information_Processing/ch10_SQL%EC%9D%91%EC%9A%A9/%EC%A0%88%EC%B0%A8%ED%98%95SQL/%EC%82%AC%EC%9A%A9%EC%9E%90%EC%A0%95%EC%9D%98%ED%95%A8%EC%88%98/</id>
    <published>2020-05-18T13:30:40.000Z</published>
    <updated>2020-05-18T13:30:40.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="절차형sql"><a class="markdownIt-Anchor" href="#절차형sql"></a> 절차형SQL</h2><ul><li>반복적으로 사용하는 특정 기능을 수행하기 위해 <u>여러개의 SQL 명령문을 포함하는 프로시저를 작성하고 프로시저 호출문을 작성</u></li><li>일련의 연산 처리 결과가 단일값으로 반환되는 <u>사용자 정의함수를 작성하고 호출하는 쿼리를 작성</u></li><li>하나의 이벤트가 발생하면 관련성이 있는 몇 개의 테이블 간에 연속적으로 <u>데이터 삽입, 삭제, 수정을 할 수 있는 트리거를 작성</u></li></ul><h3 id="사용자-정의함수-개념"><a class="markdownIt-Anchor" href="#사용자-정의함수-개념"></a> 사용자 정의함수 개념</h3><ul><li>절차형 SQL을 활용하여 일련의 <u>연산 처리 결과를 단일값으로 변환</u></li><li>DBMS에서 제공되는 공통적 함수 이외에 <u>사용자가 직접 정의하고 작성</u></li><li><u>호출을 통해 실행되며, 단일값을 조회 또는 삽입, 수정 작업에 이용</u></li></ul><h3 id="사용자-정의함수의-구성"><a class="markdownIt-Anchor" href="#사용자-정의함수의-구성"></a> 사용자 정의함수의 구성</h3><p><img src="/images/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/0518_06.png" alt="사용자 정의함수의 구성" /></p><h3 id="사용자-정의함수-작성-예"><a class="markdownIt-Anchor" href="#사용자-정의함수-작성-예"></a> 사용자 정의함수 작성 예</h3><p><img src="/images/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/0518_07.png" alt="사용자 정의함수의 작성 예시" /></p><h3 id="사용자-정의함수-호출-쿼리-작성"><a class="markdownIt-Anchor" href="#사용자-정의함수-호출-쿼리-작성"></a> 사용자 정의함수 호출 쿼리 작성</h3><p><img src="/images/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/0518_08.png" alt="사용자 정의함수의 호출 쿼리 작성" /></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;절차형sql&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#절차형sql&quot;&gt;&lt;/a&gt; 절차형SQL&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;반복적으로 사용하는 특정 기능을 수행하기 위해 &lt;u&gt;여러개의 SQL 명령문을 포함하는 프로시저를 
      
    
    </summary>
    
    
      <category term="정보처리기사" scheme="https://hyeonukdev.github.io/categories/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/"/>
    
      <category term="절차형SQL" scheme="https://hyeonukdev.github.io/categories/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/%EC%A0%88%EC%B0%A8%ED%98%95SQL/"/>
    
    
      <category term="정보처리기사" scheme="https://hyeonukdev.github.io/tags/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/"/>
    
      <category term="사용자정의함수" scheme="https://hyeonukdev.github.io/tags/%EC%82%AC%EC%9A%A9%EC%9E%90%EC%A0%95%EC%9D%98%ED%95%A8%EC%88%98/"/>
    
  </entry>
  
  <entry>
    <title>물리데이터베이스 - 핵심정리</title>
    <link href="https://hyeonukdev.github.io/2020/05/18/Engineer_Information_Processing/ch13_%EB%AC%BC%EB%A6%AC%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EC%84%A4%EA%B3%84/%EB%AC%BC%EB%A6%AC%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%AA%A8%EB%8D%B8%ED%92%88%EC%A7%88%EA%B2%80%ED%86%A0/%ED%95%B5%EC%8B%AC%EC%A0%95%EB%A6%AC/"/>
    <id>https://hyeonukdev.github.io/2020/05/18/Engineer_Information_Processing/ch13_%EB%AC%BC%EB%A6%AC%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EC%84%A4%EA%B3%84/%EB%AC%BC%EB%A6%AC%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%AA%A8%EB%8D%B8%ED%92%88%EC%A7%88%EA%B2%80%ED%86%A0/%ED%95%B5%EC%8B%AC%EC%A0%95%EB%A6%AC/</id>
    <published>2020-05-18T10:38:39.000Z</published>
    <updated>2020-05-18T10:38:39.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="물리데이터베이스"><a class="markdownIt-Anchor" href="#물리데이터베이스"></a> 물리데이터베이스</h2><h3 id="1-물리-데이터-모델-품질-기준"><a class="markdownIt-Anchor" href="#1-물리-데이터-모델-품질-기준"></a> 1. 물리 데이터 모델 품질 기준</h3><ul><li><u>데이터베이스 성능 향상과 오류 예방</u></li><li>품질 기준<ul><li>정확성</li><li>완전성</li><li>준거성</li><li>최신성</li><li>일관성</li><li>활용성</li></ul></li></ul><h3 id="2-물리-e-r-다이어그램"><a class="markdownIt-Anchor" href="#2-물리-e-r-다이어그램"></a> 2. 물리 E-R 다이어그램</h3><ul><li>논리데이터 모델 물리 데이터 모델 변환<ol><li>단위 엔티티 -&gt; 테이블</li><li>속성 -&gt; 칼럼</li><li>UID -&gt; 기본키</li><li>관계 -&gt; 외래키</li><li>관리 목적의 테이블/칼럼 추가</li><li>칼럼 유형과 길이 정의</li><li>데이터 표준 적용</li></ol></li></ul><h3 id="3-crud-분석"><a class="markdownIt-Anchor" href="#3-crud-분석"></a> 3. CRUD 분석</h3><ul><li>CRUD 매트릭스 분석 개념<ul><li>데이터 프로세스를 행으로 하고 엔티티 목록을 열로 하여 CRUD Matrix를 작성한 후 CRUD Matrix에서 사용되지 않는 프로세스와 엔티티 여부 확인하는 분석 기법</li></ul></li><li>점검사항<ul><li>모든 엔티티 타입에 CRUD가 한 번 이상 표기되었는가?</li><li>모든 엔티티 타입에 C가 한 번 이상 존재하는가?</li><li>모든 엔티티 타입에 R이 한 번 이상 존재하는가?</li><li>모든 단위 프로세스가 하나 이상의 엔티티 타입에 표기가 되는가?</li></ul></li></ul><h3 id="4-sql-성능-튜닝"><a class="markdownIt-Anchor" href="#4-sql-성능-튜닝"></a> 4. SQL 성능 튜닝</h3><ul><li>SQL 성능 튜닝의 정의<ul><li>튜닝 대상이 되는 <u>SQL을 이해하고 정보를 분석하여 성능을 개선</u>하는<br />활동</li></ul></li><li>SQL 성능 튜닝의 순서<ol><li>문제 있는 SQL 식별</li><li>옵티마이저 통계 확인</li><li>실행 계획 검토</li><li>SQL문 재구성</li><li>인덱스 재구성</li><li>실행 계획 유지 관리</li></ol></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;물리데이터베이스&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#물리데이터베이스&quot;&gt;&lt;/a&gt; 물리데이터베이스&lt;/h2&gt;
&lt;h3 id=&quot;1-물리-데이터-모델-품질-기준&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; h
      
    
    </summary>
    
    
      <category term="정보처리기사" scheme="https://hyeonukdev.github.io/categories/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/"/>
    
      <category term="물리데이터베이스" scheme="https://hyeonukdev.github.io/categories/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/%EB%AC%BC%EB%A6%AC%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4/"/>
    
    
      <category term="정보처리기사" scheme="https://hyeonukdev.github.io/tags/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/"/>
    
      <category term="핵심정리" scheme="https://hyeonukdev.github.io/tags/%ED%95%B5%EC%8B%AC%EC%A0%95%EB%A6%AC/"/>
    
  </entry>
  
  <entry>
    <title>물리데이터베이스 - 물리데이터 모델 품질 기준</title>
    <link href="https://hyeonukdev.github.io/2020/05/18/Engineer_Information_Processing/ch13_%EB%AC%BC%EB%A6%AC%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EC%84%A4%EA%B3%84/%EB%AC%BC%EB%A6%AC%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%AA%A8%EB%8D%B8%ED%92%88%EC%A7%88%EA%B2%80%ED%86%A0/SQL%EC%84%B1%EB%8A%A5%ED%8A%9C%EB%8B%9D/"/>
    <id>https://hyeonukdev.github.io/2020/05/18/Engineer_Information_Processing/ch13_%EB%AC%BC%EB%A6%AC%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EC%84%A4%EA%B3%84/%EB%AC%BC%EB%A6%AC%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%AA%A8%EB%8D%B8%ED%92%88%EC%A7%88%EA%B2%80%ED%86%A0/SQL%EC%84%B1%EB%8A%A5%ED%8A%9C%EB%8B%9D/</id>
    <published>2020-05-18T10:01:16.000Z</published>
    <updated>2020-05-18T10:01:16.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="물리데이터베이스"><a class="markdownIt-Anchor" href="#물리데이터베이스"></a> 물리데이터베이스</h2><h3 id="sql-성능-튜닝의-정의"><a class="markdownIt-Anchor" href="#sql-성능-튜닝의-정의"></a> SQL 성능 튜닝의 정의</h3><ul><li>튜닝 대상이 되는 <u>SQL을 이해하고 정보를 분석하여 성능을 개선</u>하는 활동</li><li>최소한의 CPU, I/O, 메모리를 사용하여 최대한 빠른 시간 내에 원하는 작업을 수행하도록 만드는 것</li></ul><h3 id="sql-성능-튜닝의-순서"><a class="markdownIt-Anchor" href="#sql-성능-튜닝의-순서"></a> SQL 성능 튜닝의 순서</h3><ol><li>문제 있는 SQL 식별</li><li>옵티마이저 통계 확인</li><li>실행 계획 검토</li><li>SQL문 재구성</li><li>인덱스 재구성</li><li>실행 계획 유지 관리</li></ol><h3 id="sql-성능-튜닝-순서"><a class="markdownIt-Anchor" href="#sql-성능-튜닝-순서"></a> SQL 성능 튜닝 순서</h3><h4 id="1-문제-있는-sql-식별"><a class="markdownIt-Anchor" href="#1-문제-있는-sql-식별"></a> 1. 문제 있는 SQL 식별</h4><ul><li>애플리케이션의 성능을 관리하거나 모니터링하기 위한 툴인 APM을 활용<ul><li>APM; Application Performance Management</li></ul></li></ul><h3 id="2-옵티마이저-통계확인"><a class="markdownIt-Anchor" href="#2-옵티마이저-통계확인"></a> 2. 옵티마이저 통계확인</h3><ul><li>개발자가 작성한 SQL을 가장 빠르고 효율적으로 수행할 <u>최적의 처리경로를 생성해 주는 데이터베이스 핵심 모듈</u></li><li>Oracle은 CBO와 RBO 모드 지원<ul><li>CBO; Cost Based Optimizer</li><li>RBO; Rule Based Optimizer</li></ul></li></ul><h3 id="3-실행-계획-검토"><a class="markdownIt-Anchor" href="#3-실행-계획-검토"></a> 3. 실행 계획 검토</h3><ul><li>DBMS의 옵티마이저가 수립한 SQL 코드의 실행 절차와 방법을 의미</li><li>요구사항들을 처리하기 위한 연산 순서가 적혀 있으며, 연산에는 조인, 테이블, 검색, 필터, 정렬 등이 있음</li><li>Driving 테이블이 최상의 필터를 가지고 있는지를 중심으로 검토<ul><li>Driving 테이블<ul><li>조인이 발생할 때 첫 번째로 액세스 되는 테이블</li><li>드라이빙 테이블 순서에 따라 데이터를 액세스하는 양이 대폭 늘어나거나 줄어들 수 있기 때문에 어떤 테이블을 먼저 드라이빙 하는지가 매우 중요</li><li>가장 적은 데이터를 추출할 것으로 예상되는 테이블을 먼저 드라이빙</li></ul></li></ul></li><li>처리량이 작은 Table을 Driving 테이블로 지정되었는지 확인</li></ul><h3 id="4-sql문-재구성"><a class="markdownIt-Anchor" href="#4-sql문-재구성"></a> 4. SQL문 재구성</h3><ul><li>WHERE절 사용</li><li>칼럼 변경 연산자 확인</li><li>범위 한정 사용<ul><li><b>서브쿼리에 특정 데이터가 존재하는지 확인할 때는 EXISTS 보다 IN 사용</b></li></ul></li></ul><h3 id="5-인덱스-재구성"><a class="markdownIt-Anchor" href="#5-인덱스-재구성"></a> 5. 인덱스 재구성</h3><ul><li>인덱스 구성</li><li>실행 계획 검토</li><li>관련 SQL 검토</li><li>코드 테이블 확인<ul><li><b>단일 인덱스로 조회만 이루어진 테이블은 IOT로 구성</b></li></ul></li><li>불필요한 인덱스 제거</li></ul><h3 id="6-실행-계획-유지관리"><a class="markdownIt-Anchor" href="#6-실행-계획-유지관리"></a> 6. 실행 계획 유지관리</h3><ul><li><u>실행 계획이 유지되고 있는지 모니터링하고 관리</u></li><li>데이터베이스 버전 업그레이드시</li><li>데이터의 시스템 이동 등 시스템 환경의 변경 사항 발생시</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;물리데이터베이스&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#물리데이터베이스&quot;&gt;&lt;/a&gt; 물리데이터베이스&lt;/h2&gt;
&lt;h3 id=&quot;sql-성능-튜닝의-정의&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=
      
    
    </summary>
    
    
      <category term="정보처리기사" scheme="https://hyeonukdev.github.io/categories/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/"/>
    
      <category term="물리데이터베이스" scheme="https://hyeonukdev.github.io/categories/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/%EB%AC%BC%EB%A6%AC%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4/"/>
    
    
      <category term="정보처리기사" scheme="https://hyeonukdev.github.io/tags/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/"/>
    
      <category term="물리데이터모델품질기준" scheme="https://hyeonukdev.github.io/tags/%EB%AC%BC%EB%A6%AC%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%AA%A8%EB%8D%B8%ED%92%88%EC%A7%88%EA%B8%B0%EC%A4%80/"/>
    
  </entry>
  
  <entry>
    <title>물리데이터베이스 - CRUD분석</title>
    <link href="https://hyeonukdev.github.io/2020/05/18/Engineer_Information_Processing/ch13_%EB%AC%BC%EB%A6%AC%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EC%84%A4%EA%B3%84/%EB%AC%BC%EB%A6%AC%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%AA%A8%EB%8D%B8%ED%92%88%EC%A7%88%EA%B2%80%ED%86%A0/CRUD%EB%B6%84%EC%84%9D/"/>
    <id>https://hyeonukdev.github.io/2020/05/18/Engineer_Information_Processing/ch13_%EB%AC%BC%EB%A6%AC%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EC%84%A4%EA%B3%84/%EB%AC%BC%EB%A6%AC%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%AA%A8%EB%8D%B8%ED%92%88%EC%A7%88%EA%B2%80%ED%86%A0/CRUD%EB%B6%84%EC%84%9D/</id>
    <published>2020-05-18T09:40:14.000Z</published>
    <updated>2020-05-18T09:40:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="물리데이터베이스"><a class="markdownIt-Anchor" href="#물리데이터베이스"></a> 물리데이터베이스</h2><h3 id="crud의-개념"><a class="markdownIt-Anchor" href="#crud의-개념"></a> CRUD의 개념</h3><table><thead><tr><th>구분</th><th>조작</th><th>SQL</th></tr></thead><tbody><tr><td>Create</td><td>생성</td><td>INSERT</td></tr><tr><td>Read</td><td>읽기/인출</td><td>SELECT</td></tr><tr><td>Update</td><td>갱신</td><td>UPDATE</td></tr><tr><td>Delete</td><td>삭제/제거</td><td>DELETE</td></tr></tbody></table><h3 id="crud-분석의-개념"><a class="markdownIt-Anchor" href="#crud-분석의-개념"></a> CRUD 분석의 개념</h3><ul><li>데이터베이스 테이블에 변화를 주는 트랜잭션의 CRUD 연산에 대해 CRUD 매트릭스를 작성하여 분석하는 것</li><li>테이블에 발생하는 <u>트랜잭션의 주기별 발생횟수를 파악하고 연관된 테이블을 분석하면 테이블에 저장되는 데이터의 양을 유추</u>할 수 있고 트랜잭션이 몰리는 테이블 분석 가능</li><li>CRUD 연산의 우선순위<ul><li>C &gt; D &gt; U &gt; R</li><li>활용목적에 따라 모두 적을 수 도 있음</li></ul></li></ul><h3 id="crud-매트릭스-분석-개념"><a class="markdownIt-Anchor" href="#crud-매트릭스-분석-개념"></a> CRUD 매트릭스 분석 개념</h3><ul><li>데이터 프로세스와 엔티티 목록으로 CRUD Matrix 작성<br /><img src="/images/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/0518_05.png" alt="CRUD 매트릭스 분석" /></li></ul><h3 id="crud-매트릭스-점검사항"><a class="markdownIt-Anchor" href="#crud-매트릭스-점검사항"></a> CRUD 매트릭스 점검사항</h3><ul><li>모든 엔티티 타입에 CRUD가 한 번 이상 표기되었는가?</li><li>모든 엔티티 타입에 C가 한 번 이상 존재하는가?</li><li>모든 엔티티 타입에 R이 한 번 이상 존재하는가?</li><li>모든 단위 프로세스가 하나 이상의 엔티티 타입에 표기가 되는가?</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;물리데이터베이스&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#물리데이터베이스&quot;&gt;&lt;/a&gt; 물리데이터베이스&lt;/h2&gt;
&lt;h3 id=&quot;crud의-개념&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#cru
      
    
    </summary>
    
    
      <category term="정보처리기사" scheme="https://hyeonukdev.github.io/categories/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/"/>
    
      <category term="물리데이터베이스" scheme="https://hyeonukdev.github.io/categories/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/%EB%AC%BC%EB%A6%AC%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4/"/>
    
    
      <category term="정보처리기사" scheme="https://hyeonukdev.github.io/tags/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/"/>
    
      <category term="CRUD분석" scheme="https://hyeonukdev.github.io/tags/CRUD%EB%B6%84%EC%84%9D/"/>
    
  </entry>
  
  <entry>
    <title>물리데이터베이스 - E-R 다이어그램</title>
    <link href="https://hyeonukdev.github.io/2020/05/18/Engineer_Information_Processing/ch13_%EB%AC%BC%EB%A6%AC%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EC%84%A4%EA%B3%84/%EB%AC%BC%EB%A6%AC%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%AA%A8%EB%8D%B8%ED%92%88%EC%A7%88%EA%B2%80%ED%86%A0/ER%EB%8B%A4%EC%9D%B4%EC%96%B4%EA%B7%B8%EB%9E%A8/"/>
    <id>https://hyeonukdev.github.io/2020/05/18/Engineer_Information_Processing/ch13_%EB%AC%BC%EB%A6%AC%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EC%84%A4%EA%B3%84/%EB%AC%BC%EB%A6%AC%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%AA%A8%EB%8D%B8%ED%92%88%EC%A7%88%EA%B2%80%ED%86%A0/ER%EB%8B%A4%EC%9D%B4%EC%96%B4%EA%B7%B8%EB%9E%A8/</id>
    <published>2020-05-18T02:45:23.000Z</published>
    <updated>2020-05-18T02:45:23.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="물리데이터베이스"><a class="markdownIt-Anchor" href="#물리데이터베이스"></a> 물리데이터베이스</h2><h3 id="논리-데이터-모델의-물리-데이터-모델-변환"><a class="markdownIt-Anchor" href="#논리-데이터-모델의-물리-데이터-모델-변환"></a> 논리 데이터 모델의 물리 데이터 모델 변환</h3><ul><li>엔티티는 테이블, 속성은 칼럼 등으로 변환</li><li>규칙<table><thead><tr><th>논리적 설계</th><th>물리적 설계</th><th>데이터베이스</th></tr></thead><tbody><tr><td>엔티티 Entity</td><td>테이블 Table</td><td>테이블</td></tr><tr><td>속성 Attribute</td><td>칼럼 Column</td><td>칼럼</td></tr><tr><td>주 식별자 Primary Identifier</td><td>기본 키 Primary Key</td><td>기본 키</td></tr><tr><td>외래 식별자 Foreign Identifier</td><td>외래 키 Foreign Key</td><td>외래 키</td></tr><tr><td>관계 Relationship</td><td>관계 Relationship</td><td>-</td></tr></tbody></table></li></ul><h3 id="논리-데이터-모델-물리-데이터-모델-변환-순서"><a class="markdownIt-Anchor" href="#논리-데이터-모델-물리-데이터-모델-변환-순서"></a> 논리 데이터 모델 물리 데이터 모델 변환 순서</h3><h4 id="1-단위-엔티티를-테이블로-변환"><a class="markdownIt-Anchor" href="#1-단위-엔티티를-테이블로-변환"></a> 1. 단위 엔티티를 테이블로 변환</h4><ul><li>논리 모델에서 정의된 엔티티는 물리 모델에서 테이블로 변환</li><li>엔티티는 한글명, 테이블은 영문명으로 명칭을 동일하게 사용</li><li>메타데이터시스템과 같은 사전에 표준화된 용어가 있을 경우 메타에 등록되어 있는 단어 사용하여 명명<br /><img src="/images/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/0518_01.png" alt="테이블 구성 요소" /></li></ul><h5 id="11-슈퍼-타입-기준-테이블-변환"><a class="markdownIt-Anchor" href="#11-슈퍼-타입-기준-테이블-변환"></a> 1.1 슈퍼 타입 기준 테이블 변환</h5><ul><li>서브타입을 슈퍼 타입에 통합하여 하나의 테이블로 만드는 것</li><li>서브타입에 속성이나 관계가 적을 경우에 적용하는 방법</li><li>하나로 통합된 테이블에는 서브 타입의 모든 속성 포함<br /><img src="/images/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/0518_02.png" alt="슈퍼타입 기준테이블 변환" /></li></ul><h5 id="12-슈퍼-타입-변환-장단점"><a class="markdownIt-Anchor" href="#12-슈퍼-타입-변환-장단점"></a> 1.2 슈퍼 타입 변환 장/단점</h5><ul><li>장점<ul><li>데이터의 액세스가 상대적으로 용이</li><li>뷰를 이용하여 각각의 서브 타입 만을 액세스하거나 수정 가능</li><li>수행 속도 향상</li><li>서브 타입 구분이 없는 임의 집합에 대한 가공 용이</li><li>다수의 서브 타입을 통합하는 경우 조인 감소</li><li>복잡한 처리를 하나의 SQL로 통합 용이</li></ul></li><li>단점<ul><li>특정 서브 타입에 대한 NOT Null 제한이 어려움</li><li>테이블의 칼럼 증가로 디스크 저장 공간 증가</li><li>처리마다 서브 타입에 대한 구분이 필요할 경우가 많이 발생</li><li>인덱스의 크기 증가로 인덱스 효율이 낮아짐</li></ul></li></ul><h5 id="13-서브-타입-기준-테이블-변환"><a class="markdownIt-Anchor" href="#13-서브-타입-기준-테이블-변환"></a> 1.3 서브 타입 기준 테이블 변환</h5><ul><li>슈퍼타입 속성들을 각각의 서브 타입에 추가하여 서브타입들을 개별적인 테이블로 만드는 것</li><li>서브 타입에 속성이나 관계가 많을 경우에 적용<br /><img src="/images/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/0518_03.png" alt="서브타입 기준테이블 변환" /></li></ul><h5 id="14-서브-타입-변환-장단점"><a class="markdownIt-Anchor" href="#14-서브-타입-변환-장단점"></a> 1.4 서브 타입 변환 장/단점</h5><ul><li>장점<ul><li>각 서브 타입 속성들의 선택 사양이 명확한 경우에 유리</li><li>서브 타입 유형에 대한 구분을 처리 마다할 필요가 없음</li><li>여러 개의 테이블로 통합하므로 테이블 당 크기가 감소하여 전체 테이블을 스캔하는 경우 유리</li><li>단위 테이블의 크기 감소</li></ul></li><li>단점<ul><li>서브 타입 구분 없이 데이터를 처리하는 경우 UNION이 발생</li><li>처리 속도 감소가 발생할 가능성이 높아짐</li><li>트랜잭션을 처리하는 경우 다수 테이블을 처리하는 경우가 자주 발생</li><li>복잡한 처리를 하는 SQL의 통합이 어려움</li><li>부분 범위에 대한 처리가 곤란해짐</li><li>여러 테이블을 통합한 경우 뷰로 조회만 가능</li><li>UID의 유지관리가 어려움<ul><li>Unique Identifier, 식별자</li></ul></li></ul></li></ul><h5 id="15-개별-타입-기준-테이블-변환"><a class="markdownIt-Anchor" href="#15-개별-타입-기준-테이블-변환"></a> 1.5 개별 타입 기준 테이블 변환</h5><ul><li>슈퍼 타입과 서브 타입들을 각각의 개별적인 테이블로 변환</li><li>슈퍼 타입과 서브 타입 각각의 테이블 사이에는 1:1 관계 형성<br /><img src="/images/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/0518_04.png" alt="개별타입 기준테이블 변환" /></li></ul><h5 id="16-개별-타입-기준-테이블-변환을-사용하는-경우"><a class="markdownIt-Anchor" href="#16-개별-타입-기준-테이블-변환을-사용하는-경우"></a> 1.6 개별 타입 기준 테이블 변환을 사용하는 경우</h5><ul><li>전체 데이터에 대한 처리가 자주 발생하는 경우</li><li>서브 타입 처리가 대부분 독립적으로 발생하는 경우</li><li>통합하는 테이블의 칼럼 수가 지나치게 많은 경우</li><li>서브 타입 칼럼 수가 다수인 경우</li><li>트랜잭션이 주로 슈퍼 타입에서 발생하는 경우</li><li>슈퍼 타입에서 범위가 넓은 처리가 빈번하게 발생하여 단일 테이블 클러스터링이 필요한 경우</li></ul><h4 id="2-속성을-column-칼럼으로-변환"><a class="markdownIt-Anchor" href="#2-속성을-column-칼럼으로-변환"></a> 2. 속성을 Column 칼럼으로 변환</h4><ul><li>칼럼의 명칭은 속성의 명칭과 반드시 일치할 필요는 없으나, 개발자와 사용자간 의사소통을 위해 가능한 표준화된 약어를 사용</li><li>SQL 예약어 사용은 피해야 함</li><li>SQL 문장의 가독성을 위해 칼럼 명칭은 가능한 짧게</li><li>칼럼명에 복합 단어 사용할 경우 미리 정의된 표준에 의해 명명</li></ul><h4 id="3-uid를-기본키로-변환"><a class="markdownIt-Anchor" href="#3-uid를-기본키로-변환"></a> 3. UID를 기본키로 변환</h4><ul><li>엔티티의 UID는 기본키로 선언</li><li>Not NULL, Unique 등의 제약 조건을 추가적으로 정의</li></ul><h4 id="4-관계를-외래키로-변환"><a class="markdownIt-Anchor" href="#4-관계를-외래키로-변환"></a> 4. 관계를 외래키로 변환</h4><ul><li>1:n 관계에서 1영역에 있는 기본키를 n영역의 외래키로 선언</li><li>외래키명은 1영역의 기본키 이름을 사용하거나 다른 의미를 가질 경우 변경하여 명명</li><li>순환 관계에서 자신의 기본키는 외래키로 정의</li></ul><h4 id="5-관리-목적의-테이블칼럼-추가"><a class="markdownIt-Anchor" href="#5-관리-목적의-테이블칼럼-추가"></a> 5. 관리 목적의 테이블/칼럼 추가</h4><ul><li>논리 모델링에서는 필요가 없으나 관리 또는 데이터베이스를 이용하는 프로그래밍의 수행 속도를 향상을 위해 추가 되는 테이블이나 칼럼</li><li>관리상 필요한 데이터를 등록한 일자, 시스템 번호 등을 의미</li></ul><h4 id="6-칼럼-유형과-길이-정의"><a class="markdownIt-Anchor" href="#6-칼럼-유형과-길이-정의"></a> 6. 칼럼 유형과 길이 정의</h4><ul><li>정의된 각 컬럼에 대해, 적용 DBMS에서 제공하는 데이터 유형 중 적절한 유형 정의</li><li>해당 데이터의 최대 길이를 파악하여 길이 설정</li><li>자주 사용되는 데이터 유형</li></ul><h4 id="7-데이터-표준-적용"><a class="markdownIt-Anchor" href="#7-데이터-표준-적용"></a> 7. 데이터 표준 적용</h4><ul><li>명명 규칙 및 표준 용어 사전을 활용하여 각 객체의 데이터 표준 수행</li><li>표준화 적용대상<ul><li>데이터베이스</li><li>스토리지 그룹</li><li>테이블 스페이스</li><li>테이블</li><li>칼럼</li><li>인덱스</li><li>뷰</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;물리데이터베이스&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#물리데이터베이스&quot;&gt;&lt;/a&gt; 물리데이터베이스&lt;/h2&gt;
&lt;h3 id=&quot;논리-데이터-모델의-물리-데이터-모델-변환&quot;&gt;&lt;a class=&quot;markdownIt-Anc
      
    
    </summary>
    
    
      <category term="정보처리기사" scheme="https://hyeonukdev.github.io/categories/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/"/>
    
      <category term="물리데이터베이스" scheme="https://hyeonukdev.github.io/categories/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/%EB%AC%BC%EB%A6%AC%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4/"/>
    
    
      <category term="정보처리기사" scheme="https://hyeonukdev.github.io/tags/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/"/>
    
      <category term="ER다이어그램" scheme="https://hyeonukdev.github.io/tags/ER%EB%8B%A4%EC%9D%B4%EC%96%B4%EA%B7%B8%EB%9E%A8/"/>
    
  </entry>
  
  <entry>
    <title>물리데이터베이스 - 물리데이터 모델 품질 기준</title>
    <link href="https://hyeonukdev.github.io/2020/05/18/Engineer_Information_Processing/ch13_%EB%AC%BC%EB%A6%AC%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EC%84%A4%EA%B3%84/%EB%AC%BC%EB%A6%AC%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%AA%A8%EB%8D%B8%ED%92%88%EC%A7%88%EA%B2%80%ED%86%A0/%EB%AC%BC%EB%A6%AC%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%AA%A8%EB%8D%B8%ED%92%88%EC%A7%88%EA%B8%B0%EC%A4%80/"/>
    <id>https://hyeonukdev.github.io/2020/05/18/Engineer_Information_Processing/ch13_%EB%AC%BC%EB%A6%AC%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EC%84%A4%EA%B3%84/%EB%AC%BC%EB%A6%AC%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%AA%A8%EB%8D%B8%ED%92%88%EC%A7%88%EA%B2%80%ED%86%A0/%EB%AC%BC%EB%A6%AC%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%AA%A8%EB%8D%B8%ED%92%88%EC%A7%88%EA%B8%B0%EC%A4%80/</id>
    <published>2020-05-18T01:05:02.000Z</published>
    <updated>2020-05-18T01:05:02.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="물리데이터베이스"><a class="markdownIt-Anchor" href="#물리데이터베이스"></a> 물리데이터베이스</h2><ul><li>물리데이터 모델에 대하여 <u>정확성, 완전성, 준거성, 최신성, 일관성, 활용성</u>의 품질기준을 적용</li><li>논리 데이터 모델과 물리 데이터 모델을 비교하여 테이블, 칼럼, 키, 오브젝트 구성 요소의 누락 여부와 일치성을 확인</li><li>논리 데이터베이스 설계에서 <u>엔티티, 속성, 주식별자, 외래식별자를 각각 테이블, 칼럼, 기본 키, 외래 키로 변환하여 표현</u></li><li><u>CRUD 분석과 SQL 성능 튜닝의 개념과 절차</u>를 이해</li></ul><h3 id="물리-데이터-모델-품질-기준"><a class="markdownIt-Anchor" href="#물리-데이터-모델-품질-기준"></a> 물리 데이터 모델 품질 기준</h3><ul><li>물리 데이터 모델을 설계하고 데이터베이스 객체를 생성한 후 개발 단계로 넘어가기 전에 모델러와 이해관계자들이 모여 수행</li><li>시스템 성능에 직접적인 영향을 미치므로 향후 발생할 문제에 대해 면밀히 검토해야 함</li><li><u>데이터베이스 성능 향상과 오류 예방</u></li><li>검토시 모든 이해관계자가 동의하는 검토 기준이 필요</li></ul><h3 id="품질기준"><a class="markdownIt-Anchor" href="#품질기준"></a> 품질기준</h3><ul><li><p>정확성</p><ul><li>데이터 모델이 표기법에 따라 정확하게 표현되었고, 업무영역 또는 요구사항이 정확하게 반영되었음을 의미</li><li>예시<ul><li>사용된 표기법에 따라 데이터 모델이 정확하게 표현되었는가?</li><li>대상 업무 영역의 업무 개념과 내용이 정확하게 표현되었는가?</li><li>요구사항의 내용이 정확하게 반영되었는가?</li><li>업무 규칙이 정확하게 표현되었는가?</li></ul></li></ul></li><li><p>완정성</p><ul><li>데이터 모델의 구성 요소를 정의하는데 있어서 누락을 최소화하고, 요구 사항 및 업무 영역 반영에 있어서 누락이 없음을 의미</li><li>예시<ul><li>물리 데이터 모델 작성 항목의 충실도</li><li>필요한 설명 항목(테이블/칼럼 설명)들의 작성 상태</li><li>물리 모델링 단계에서 결정해야 할 항목들의 작성 성태(칼럼 데이터 타입 및 길이, Null 허용 여부, 서브타입 변환 등 필요에 따라서는 저장공간 지정, 테이블/인덱스 생성 관련 파라미터 결정 사항등까지도 포함)</li><li>요구 사항 반영 및 업무 영역 방녕의 완전성 : 목적하는 업무 영역을 기술한 논리 데이터 모델의 구성 요소(엔티티, 속성, 관계, 식별자)들이 누락없이 물리 데이터 모델로 변환되어 정의된 정도</li></ul></li></ul></li><li><p>준거성</p><ul><li>제반 준수 요건들이 누락 없이 정화하게 준수되었음을 의미</li><li>예시<ul><li>데이터 표준, 규칙 등을 준수하였는가?</li><li>법적 요건을 준수하였는가?</li><li>법적 요건을 준수하기에 충분하도록 도메인이 정의 되었는가?</li></ul></li></ul></li><li><p>최신성</p><ul><li>데이터 모델이 현행시스템의 최신 상태를 반영하고 있고, 이슈 사항들이 지체 없이 반영되고 있음을 의미</li><li>예시<ul><li>엄무상의 변경이나 결정 사항 등이 시의 적절하게 반영되고 있는가?</li><li>최근의 이슈 사항이 반영되었는가?</li><li>현행 데이터 모델의 현행 시스템과 일치하는가?</li></ul></li></ul></li><li><p>일관성</p><ul><li>여러 영역에서 공통 사용되는 데이터 요소가 전사 수준에서 한 번만 정의되고 이를 여러 다른 영역에서 참조/활용되면서, 모델 표현상의 일관성을 유지하고 있음을 의미</li><li>예씨<ul><li>여러 주제 영역에서 공통적으로 사용되는 개체는 일관성 있게 사용되는가?(전사 수준에서 한 번만 정의되고 이를 여러 다른 영역에서 참조/활용한다는 의미에서 통합성이라고하기도 함)</li><li>모델 표현상의 일관성을 유지하고 있는가?</li><li>동일/유사 목적/용도의 칼럼들은 일관성 있게 정의되었는가?</li><li>조인 대상 칼럼들은 일관성있게 정의되었는가?</li></ul></li></ul></li><li><p>활용성</p><ul><li>작성된 모델과 그 설명 내용이 이해관계자에게 의미를 충분하게 전달할 수 있으면서, 업무 변화 시에 설계 변경없이 최소화되도록 유연하게 설계되어 있음을 의미</li><li>예시<ul><li>작성된 설명 내용이나 모델 표기 등이 사용자나 모델을 보는 사람에게 충분히 이해가 될 수 있고, 모델의 작성 의도를 명확하게 이해할 수 있는가(의사소통의 충분성)</li><li>PK, UK 등의 칼럼 구성은 데이터 무결성을 보장하면서 데이터 액세스를 효율화 하기에 충분한가?</li><li>논리 데이터 모델의 유연성이 물리 데이터 모델에도 반영되었는가(오류가 적고 업무 변화에 유연하게 대응하여 데이터 구조의 변경이 최소화 될 수 있는 설계 결과)</li><li>코드화 대상 칼럼에 대한 코드 정의는 업무 지원 및 적용에 충분한가?</li></ul></li></ul></li></ul><h3 id="물리-데이터-모델의-품질-검토-순서"><a class="markdownIt-Anchor" href="#물리-데이터-모델의-품질-검토-순서"></a> 물리 데이터 모델의 품질 검토 순서</h3><ol><li>데이터 품질 <u>정책 및 기준 확인</u></li><li>물리 데이터 품질의 특성에 따라 <u>품질 기준 작성</u></li><li>데이터 품질 기준에 따라 <u>체크리스트 작성</u></li><li><u>논리 데이터 모델과 물리 데이터 모델 비교</u></li><li>각 모델링 단계의 모델러와 이해관계자가 <u>품질 검토 수행</u></li><li>모델러와 이해관계자가 작성한 체크리스트 내용을 종합하여 <u>물리 데이터베이스 모델의 품질 검토 보고서 작성</u></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;물리데이터베이스&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#물리데이터베이스&quot;&gt;&lt;/a&gt; 물리데이터베이스&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;물리데이터 모델에 대하여 &lt;u&gt;정확성, 완전성, 준거성, 최신성, 일관성, 활용성&lt;/u
      
    
    </summary>
    
    
      <category term="정보처리기사" scheme="https://hyeonukdev.github.io/categories/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/"/>
    
      <category term="물리데이터베이스" scheme="https://hyeonukdev.github.io/categories/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/%EB%AC%BC%EB%A6%AC%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4/"/>
    
    
      <category term="정보처리기사" scheme="https://hyeonukdev.github.io/tags/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/"/>
    
      <category term="물리데이터모델품질기준" scheme="https://hyeonukdev.github.io/tags/%EB%AC%BC%EB%A6%AC%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%AA%A8%EB%8D%B8%ED%92%88%EC%A7%88%EA%B8%B0%EC%A4%80/"/>
    
  </entry>
  
  <entry>
    <title>물리데이터베이스 - 핵심정리</title>
    <link href="https://hyeonukdev.github.io/2020/05/17/Engineer_Information_Processing/ch13_%EB%AC%BC%EB%A6%AC%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EC%84%A4%EA%B3%84/%EB%AC%BC%EB%A6%AC%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EB%AA%A8%EB%8D%B8%EB%A7%81/%ED%95%B5%EC%8B%AC%EC%A0%95%EB%A6%AC/"/>
    <id>https://hyeonukdev.github.io/2020/05/17/Engineer_Information_Processing/ch13_%EB%AC%BC%EB%A6%AC%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EC%84%A4%EA%B3%84/%EB%AC%BC%EB%A6%AC%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EB%AA%A8%EB%8D%B8%EB%A7%81/%ED%95%B5%EC%8B%AC%EC%A0%95%EB%A6%AC/</id>
    <published>2020-05-16T17:18:05.000Z</published>
    <updated>2020-05-16T17:18:05.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="물리데이터베이스"><a class="markdownIt-Anchor" href="#물리데이터베이스"></a> 물리데이터베이스</h2><h3 id="1-데이터베이스-무결성"><a class="markdownIt-Anchor" href="#1-데이터베이스-무결성"></a> 1. 데이터베이스 무결성</h3><ul><li>데이터의 정확성을 보장하기 위해 <u>부정확한 자료가 데이터베이스 내에 저장</u>되는 것을 방지 하기 위한 제약 조건임</li><li>무결정의 종류<ul><li>개체 무결성</li><li>도메인 무결성</li><li>참조 무결성</li><li>사용자 정의 무결성</li></ul></li></ul><h3 id="2-칼럼-속성"><a class="markdownIt-Anchor" href="#2-칼럼-속성"></a> 2. 칼럼 속성</h3><ul><li>속성은 데이터베이스를 구성하는 가장 작은 논리적 단위</li><li>파일 구조상의 데이터 항목 또는 데이터 필드에 해당됨</li><li>특성에 따른 분류<ul><li>기본 속성</li><li>설계 속성</li><li>파생 속성</li></ul></li><li>개체 구성 방식에 따른 분류<ul><li>기본키 속성</li><li>외래키 속성</li><li>일반 속성</li></ul></li></ul><h3 id="3-키-종류"><a class="markdownIt-Anchor" href="#3-키-종류"></a> 3. 키 종류</h3><ul><li>데이터베이스에서 조건에 만족하는 튜플을 찾거나 순서대로 정렬할 때 <u>튜플들을 서로 구분할 수 있는 기준</u>이 되는 <u>애트리뷰트</u></li><li>종류<ul><li>슈퍼키</li><li>후보키</li><li>기본키</li><li>대체키</li></ul></li></ul><h3 id="4-반정규화"><a class="markdownIt-Anchor" href="#4-반정규화"></a> 4. 반정규화</h3><ul><li><u>시스템의 성능 향상, 개발 및 운영의 편의성 등을 위해</u> 정규화된 <u>데이터 모델을 통합, 중복, 분리</u>하는 과정으로 의도적으로 <u>정규화 원칙을 위배하는 행위</u></li><li>방법<ul><li>테이블 통합</li><li>테이블 분할</li><li>중복 테이블 추가</li><li>중복 속성 추가</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;물리데이터베이스&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#물리데이터베이스&quot;&gt;&lt;/a&gt; 물리데이터베이스&lt;/h2&gt;
&lt;h3 id=&quot;1-데이터베이스-무결성&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;
      
    
    </summary>
    
    
      <category term="정보처리기사" scheme="https://hyeonukdev.github.io/categories/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/"/>
    
      <category term="물리데이터베이스" scheme="https://hyeonukdev.github.io/categories/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/%EB%AC%BC%EB%A6%AC%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4/"/>
    
    
      <category term="정보처리기사" scheme="https://hyeonukdev.github.io/tags/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/"/>
    
      <category term="핵심정리" scheme="https://hyeonukdev.github.io/tags/%ED%95%B5%EC%8B%AC%EC%A0%95%EB%A6%AC/"/>
    
  </entry>
  
  <entry>
    <title>물리데이터베이스 - 반정규화</title>
    <link href="https://hyeonukdev.github.io/2020/05/17/Engineer_Information_Processing/ch13_%EB%AC%BC%EB%A6%AC%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EC%84%A4%EA%B3%84/%EB%AC%BC%EB%A6%AC%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EB%AA%A8%EB%8D%B8%EB%A7%81/%EB%B0%98%EC%A0%95%EA%B7%9C%ED%99%94/"/>
    <id>https://hyeonukdev.github.io/2020/05/17/Engineer_Information_Processing/ch13_%EB%AC%BC%EB%A6%AC%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EC%84%A4%EA%B3%84/%EB%AC%BC%EB%A6%AC%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EB%AA%A8%EB%8D%B8%EB%A7%81/%EB%B0%98%EC%A0%95%EA%B7%9C%ED%99%94/</id>
    <published>2020-05-16T17:02:53.000Z</published>
    <updated>2020-05-16T17:02:53.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="물리데이터베이스"><a class="markdownIt-Anchor" href="#물리데이터베이스"></a> 물리데이터베이스</h2><h3 id="반정규화-denormalization-개념"><a class="markdownIt-Anchor" href="#반정규화-denormalization-개념"></a> 반정규화 Denormalization 개념</h3><ul><li><u>시스템의 성능 향상, 개발 및 운영의 편의성 등을 위해</u> 정규화된 <u>데이터 모델을 통합, 중복, 분리</u>하는 과정으로 의도적으로 <u>정규화 원칙을 위배하는 행위</u></li><li>반정규화를 수행하면 시스템의 성능이 향상되고 관리 효율성은 증가하지만 <u>데이터의 일관성 및 무결성이 저하</u>될 수 있므</li><li><u>과도한 반정규화는 오히려 성능을 저하</u>시킬 수 있음</li><li>데이터의 일관성과 무결성을 우선으로 할 지, 데이터베이스의 성능과 단순화를 우선으로 할 지를 사전에 결정해야 함</li><li>방법<ul><li>테이블 통합</li><li>테이블 분할</li><li>중복 테이블 추가</li><li>중복 속성 추가</li></ul></li></ul><h3 id="반정규화-방법"><a class="markdownIt-Anchor" href="#반정규화-방법"></a> 반정규화 방법</h3><h4 id="1-테이블-통합"><a class="markdownIt-Anchor" href="#1-테이블-통합"></a> 1. 테이블 통합</h4><ul><li>테이블 조인이 많은 경우 <u>하나의 테이블로 합치는 것이</u> 성능 향상에 유리</li><li>종류<ul><li>1:1 관계 테이블 통합</li><li>1:N 관계 테이블 통합</li><li>수퍼타입/서브타입 테이블 통합</li></ul></li><li>고려사항<ul><li>데이터 검색은 간편하지만, 레코드 증가로 <u>처리량 증가</u></li><li>입력, 수정, 삭제 규칙의 <u>복잡도 증가</u></li></ul></li></ul><h4 id="2-테이블-분할"><a class="markdownIt-Anchor" href="#2-테이블-분할"></a> 2. 테이블 분할</h4><ul><li>테이블에서 특정 레코드나 특정 속성에 집중적으로 접근할 경우 테이블 분할</li><li>종류<ul><li>수평 분할</li><li>수직 분할</li></ul></li></ul><h5 id="21-수평-분할"><a class="markdownIt-Anchor" href="#21-수평-분할"></a> 2.1 수평 분할</h5><ul><li>Record 레코드를 기준으로 테이블을 분할</li><li>레코드별로 사용 빈도의 차이가 큰 경우 사용 빈도에 따라 분할</li></ul><h5 id="22-수직-분할"><a class="markdownIt-Anchor" href="#22-수직-분할"></a> 2.2 수직 분할</h5><ul><li>테이블의 많은 속성 중 특정 속성들만 접근이 잦을 경우 속성을 기준으로 테이블을 분할</li><li><u>갱신 위주의 속성 분할</u><ul><li>데이터 갱신 시 레코드 잠금으로 인해 다른 작업을 수행할 수 없으므로 갱신이 자주 일어나는 속성 분할</li></ul></li><li><u>자주 조회되는 속성 분할</u><ul><li>자주 조회되는 속성이 극히 일부일 경우 자주 사용되는 속성을 수직 분할하여 사용</li></ul></li><li><u>크기가 큰 속성 분할</u><ul><li>이미지나 2GB이상 저장 될 수 있는 텍스트 형식 등으로 된 속성을 수직 분할하여 사용</li></ul></li><li><u>보안을 적용해야 하는 속성 분할</u><ul><li>테이블 내 특정 속성에 대한 보안ㅇ르 적용할 수 없으므로 보안을 적용해야 하는 속성들을 수직분할하여 사용</li></ul></li></ul><h5 id="23-테이블-분할-시-고려사항"><a class="markdownIt-Anchor" href="#23-테이블-분할-시-고려사항"></a> 2.3 테이블 분할 시 고려사항</h5><ul><li><u>기본키의 유일성 관리가 어려움</u></li><li>데이터 양이 적거나 사용 빈도가 낮은 경우 테이블 분할이 필요한지를 고려</li><li>분할된 테이블의 전체 조회 시는 Union을 사용해야하므로 수행 속도가 느려짐</li><li>데이터 검색에 중점을 두어 테이블 부할 여부를 결정해야 함</li></ul><h4 id="3-중복-테이블-추가"><a class="markdownIt-Anchor" href="#3-중복-테이블-추가"></a> 3. 중복 테이블 추가</h4><ul><li>여러 테이블에서 데이터를 추가해서 사용해야 하는 경우</li><li>다른 서버에 저장된 테이블을 이용해야하는 경우</li></ul><h5 id="31-중복-테이블을-추가하는-경우"><a class="markdownIt-Anchor" href="#31-중복-테이블을-추가하는-경우"></a> 3.1 중복 테이블을 추가하는 경우</h5><ul><li>정규화로 인해 수행 <u>속도가 느려지는 경우</u></li><li><u>많은 범위</u>의 데이터를 <u>자추 처리해야</u>하는 경우</li><li><u>특정 범위</u>의 데이터를 <u>자추 처리해야</u>하는 경우</li><li><u>처리 범위를 줄이지 않고는</u> 수행 속도를 개선할 수 없는 경우</li></ul><h6 id="32-중복-테이블-추가하는-방법"><a class="markdownIt-Anchor" href="#32-중복-테이블-추가하는-방법"></a> 3.2 중복 테이블 추가하는 방법</h6><ul><li>집계 테이블 추가<ul><li>SUM, AVG 등 집계 데이터를 위한 테이블을 생성하고, 각 원본 테이블에 트리거를 설정하여 사용하는 것</li></ul></li><li>이력 테이블 추가<ul><li>이력 관리 드으이 목적으로 추가하는 테이블로, 적절한 데이터 양의 유지와 활용도를 제고하기 위해 기본키를 적절히 설정</li></ul></li><li>부분 테이블 추가<ul><li>하나의 테이블의 전체 칼럼 중 자주 이용하는 집중화 된 칼럼들이 있을 때 해당 칼럼들을 모아 놓은 별도의 반정규화된 테이블 생성</li></ul></li></ul><h4 id="4-중복-속성-추가"><a class="markdownIt-Anchor" href="#4-중복-속성-추가"></a> 4. 중복 속성 추가</h4><ul><li>테이블을 조인해서 데이터를 처리할 때 데이터를 조회하는 경로를 단축하기 위해 자주 사용하는 속성을 추가하는 것</li></ul><h5 id="41-중복-속성을-추가하는-경우"><a class="markdownIt-Anchor" href="#41-중복-속성을-추가하는-경우"></a> 4.1 중복 속성을 추가하는 경우</h5><ul><li><u>조인이 자주 발생하는</u> 속성인 경우</li><li><u>접근 경로가 복잡</u>한 속성인 경우</li><li>기본키의 형태가 적절하지 않거나 <u>여러 개의 속성으로 구성</u>된 경우</li></ul><h5 id="42-중복-속성-추가-시-고려사항"><a class="markdownIt-Anchor" href="#42-중복-속성-추가-시-고려사항"></a> 4.2 중복 속성 추가 시 고려사항</h5><ul><li>테이블 중복과 속성의 중복을 고려</li><li>테이블 일관성 및 무결성에 유의</li><li>SQL 그룹 함수를 이용하여 처리할 수 있어야 함</li><li>저장 공간의 지나친 낭비를 고려</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;물리데이터베이스&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#물리데이터베이스&quot;&gt;&lt;/a&gt; 물리데이터베이스&lt;/h2&gt;
&lt;h3 id=&quot;반정규화-denormalization-개념&quot;&gt;&lt;a class=&quot;markdownIt-Anc
      
    
    </summary>
    
    
      <category term="정보처리기사" scheme="https://hyeonukdev.github.io/categories/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/"/>
    
      <category term="물리데이터베이스" scheme="https://hyeonukdev.github.io/categories/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/%EB%AC%BC%EB%A6%AC%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4/"/>
    
    
      <category term="정보처리기사" scheme="https://hyeonukdev.github.io/tags/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/"/>
    
      <category term="반정규화" scheme="https://hyeonukdev.github.io/tags/%EB%B0%98%EC%A0%95%EA%B7%9C%ED%99%94/"/>
    
  </entry>
  
  <entry>
    <title>물리데이터베이스 - 키 종류</title>
    <link href="https://hyeonukdev.github.io/2020/05/17/Engineer_Information_Processing/ch13_%EB%AC%BC%EB%A6%AC%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EC%84%A4%EA%B3%84/%EB%AC%BC%EB%A6%AC%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EB%AA%A8%EB%8D%B8%EB%A7%81/%ED%82%A4%EC%A2%85%EB%A5%98/"/>
    <id>https://hyeonukdev.github.io/2020/05/17/Engineer_Information_Processing/ch13_%EB%AC%BC%EB%A6%AC%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EC%84%A4%EA%B3%84/%EB%AC%BC%EB%A6%AC%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EB%AA%A8%EB%8D%B8%EB%A7%81/%ED%82%A4%EC%A2%85%EB%A5%98/</id>
    <published>2020-05-16T16:37:45.000Z</published>
    <updated>2020-05-16T16:37:45.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="물리데이터베이스"><a class="markdownIt-Anchor" href="#물리데이터베이스"></a> 물리데이터베이스</h2><h3 id="키의-개념"><a class="markdownIt-Anchor" href="#키의-개념"></a> 키의 개념</h3><ul><li>데이터베이스에서 조건에 만족하는 튜플을 찾거나 순서대로 정렬할 때 <u>튜플들을 서로 구분할 수 있는 기준</u>이 되는 <u>애트리뷰트</u></li><li>종류<ul><li>슈퍼키</li><li>후보키</li><li>기본키</li><li>대체키</li></ul></li></ul><h3 id="키의-특징"><a class="markdownIt-Anchor" href="#키의-특징"></a> 키의 특징</h3><ul><li>Uniqueness 유일성<ul><li>하나의 키 값으로 하나의 튜플만을 유일하게 식별할 수 있어야 함</li></ul></li><li>Minimality 최소성<ul><li>릴레이션의 모든 튜플을 유일하게 식별하기 위해 꼭 필요한 속성만으로 구성</li></ul></li></ul><h3 id="키의-종류-개념도"><a class="markdownIt-Anchor" href="#키의-종류-개념도"></a> 키의 종류 개념도</h3><p><img src="/images/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/0517_01.png" alt="키의 종류" /></p><ul><li>슈퍼키 &gt; 후보키 &gt; 대체키 &gt; 기본키</li><li>후보키 = 기본키 + 대체키</li><li>기본키 = 후보키 - 대체키</li></ul><h3 id="키의-종류-상세"><a class="markdownIt-Anchor" href="#키의-종류-상세"></a> 키의 종류 상세</h3><ul><li>슈퍼키 Super Key<ul><li>한 릴레이션 내의 속성들의 집합으로 구성된 키</li><li>릴레이션을 구성하는 모든 튜플에 대해 유일성은 만족시키지만 최소성은 만족시키지 못함</li><li>ex) 학번+주민번호</li></ul></li><li>후보키 Candidate Key<ul><li>릴레이션을 구성하는 속성들 중에서 튜플을 유일하게 식별할 수 있는 하나 또는 몇 개의 속성의 집합</li><li>릴레이션의 모든 튜플에 대해 유일성과 최소성 모두 만족</li></ul></li><li>기본키 Primary Key<ul><li>릴레이션에서 튜플ㅇ르 구별할 수 있는 유일한 식별자</li><li>후보키 중에서 선정된 키로 유일성과 최소성 만족</li><li>기본키는 Null값을 가질 수 없고 중복값을 가질 수 없음</li></ul></li><li>대체키 Primary Key<ul><li>후보키가 둘 이상인 경우 기본키로 선택되지 못한 후보들키를 보조키라고도 함</li></ul></li><li>외래키 Foreign Key<ul><li>참조되는 릴레이션의 기본키와 대응되어 릴레이션 간에 참조관계 표현</li><li>참조 릴레이션의 기본키에 없는 값은 입력할 수 없음</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;물리데이터베이스&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#물리데이터베이스&quot;&gt;&lt;/a&gt; 물리데이터베이스&lt;/h2&gt;
&lt;h3 id=&quot;키의-개념&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#키의-개념&quot;
      
    
    </summary>
    
    
      <category term="정보처리기사" scheme="https://hyeonukdev.github.io/categories/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/"/>
    
      <category term="물리데이터베이스" scheme="https://hyeonukdev.github.io/categories/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/%EB%AC%BC%EB%A6%AC%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4/"/>
    
    
      <category term="정보처리기사" scheme="https://hyeonukdev.github.io/tags/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/"/>
    
      <category term="키종류" scheme="https://hyeonukdev.github.io/tags/%ED%82%A4%EC%A2%85%EB%A5%98/"/>
    
  </entry>
  
  <entry>
    <title>물리데이터베이스 - 칼럼 속성</title>
    <link href="https://hyeonukdev.github.io/2020/05/17/Engineer_Information_Processing/ch13_%EB%AC%BC%EB%A6%AC%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EC%84%A4%EA%B3%84/%EB%AC%BC%EB%A6%AC%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EB%AA%A8%EB%8D%B8%EB%A7%81/%EC%B9%BC%EB%9F%BC%EC%86%8D%EC%84%B1/"/>
    <id>https://hyeonukdev.github.io/2020/05/17/Engineer_Information_Processing/ch13_%EB%AC%BC%EB%A6%AC%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EC%84%A4%EA%B3%84/%EB%AC%BC%EB%A6%AC%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EB%AA%A8%EB%8D%B8%EB%A7%81/%EC%B9%BC%EB%9F%BC%EC%86%8D%EC%84%B1/</id>
    <published>2020-05-16T16:31:58.000Z</published>
    <updated>2020-05-16T16:31:58.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="물리데이터베이스"><a class="markdownIt-Anchor" href="#물리데이터베이스"></a> 물리데이터베이스</h2><h3 id="칼럼-속성의-정의-및-특징"><a class="markdownIt-Anchor" href="#칼럼-속성의-정의-및-특징"></a> 칼럼 속성의 정의 및 특징</h3><ul><li>속성은 데이터베이스를 구성하는 가장 작은 논리적 단위</li><li>파일 구조상의 데이터 항목 또는 데이터 필드에 해당됨</li><li>속성은 개체의 구성 항목이며 특성을 기술</li><li>속성의 수는 Degree 또는 차수라고 함</li></ul><h3 id="속성의-특성에-따른-분류"><a class="markdownIt-Anchor" href="#속성의-특성에-따른-분류"></a> 속성의 특성에 따른 분류</h3><ul><li>기본 속성 Basic Attribute<ul><li>업무 분석을 통해 정의한 속성</li><li>개체 타입에 가장 일반적이고 많은 속성을 차지</li><li>업무로부터 분석한 속성이라도 이미 업무상 코드로 정의한 속성은 기본 속성에서 제외</li></ul></li><li>설계 속성 Designed Attribute<ul><li>원래 업무에는 존재하지 않지만 설계를 하면서 도출하는 속성</li><li>업무의 필요에 의해 새로 만들거나 변형하여 정의한 속성</li></ul></li><li>파생 속성 Derived Attribute<ul><li>다른 속성으로부터 계산이나 변형되어 생성되는 속성</li><li>다른 속성의 영향을 받기 때문에 정합성 유지를 위해 가급적 파생 속성을 적게 정의하는 것이 좋음</li></ul></li></ul><h3 id="개체-구성-방식에-따른-분류"><a class="markdownIt-Anchor" href="#개체-구성-방식에-따른-분류"></a> 개체 구성 방식에 따른 분류</h3><ul><li>기본키 속성<ul><li>개체를 식별할 수 있는 속성</li></ul></li><li>외래키 속성<ul><li>다른 개체와의 관계에서 포함된 속성</li></ul></li><li>일반 속성<ul><li>개체에 포함되어 있고 기본 키, 외래 키에 포함되지 않은 속성</li></ul></li></ul><h3 id="속성-후보-선정-원칙"><a class="markdownIt-Anchor" href="#속성-후보-선정-원칙"></a> 속성 후보 선정 원칙</h3><ul><li>원시 속성으로 보이는 후보는 버리지 않음</li><li>소그룹별로 후보군을 만들고 가장 근접한 개체에 할당</li></ul><h3 id="속성명-지정-원치"><a class="markdownIt-Anchor" href="#속성명-지정-원치"></a> 속성명 지정 원치</h3><ul><li>해당 업무에서 사용하는 이름을 부여</li><li>서술식 속성명은 사용하지 않음</li><li>약어 사용은 가급적 자제</li><li>개체 타입명은 속성명으로 사용해서는 안됨</li><li>개체타입에서 유일하게 식별 가능하도록 지정</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;물리데이터베이스&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#물리데이터베이스&quot;&gt;&lt;/a&gt; 물리데이터베이스&lt;/h2&gt;
&lt;h3 id=&quot;칼럼-속성의-정의-및-특징&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href
      
    
    </summary>
    
    
      <category term="정보처리기사" scheme="https://hyeonukdev.github.io/categories/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/"/>
    
      <category term="물리데이터베이스" scheme="https://hyeonukdev.github.io/categories/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/%EB%AC%BC%EB%A6%AC%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4/"/>
    
    
      <category term="정보처리기사" scheme="https://hyeonukdev.github.io/tags/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/"/>
    
      <category term="칼럼속성" scheme="https://hyeonukdev.github.io/tags/%EC%B9%BC%EB%9F%BC%EC%86%8D%EC%84%B1/"/>
    
  </entry>
  
  <entry>
    <title>물리데이터베이스 - 데이터베이스 무결성</title>
    <link href="https://hyeonukdev.github.io/2020/05/16/Engineer_Information_Processing/ch13_%EB%AC%BC%EB%A6%AC%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EC%84%A4%EA%B3%84/%EB%AC%BC%EB%A6%AC%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EB%AA%A8%EB%8D%B8%EB%A7%81/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EB%AC%B4%EA%B2%B0%EC%84%B1/"/>
    <id>https://hyeonukdev.github.io/2020/05/16/Engineer_Information_Processing/ch13_%EB%AC%BC%EB%A6%AC%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EC%84%A4%EA%B3%84/%EB%AC%BC%EB%A6%AC%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EB%AA%A8%EB%8D%B8%EB%A7%81/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EB%AC%B4%EA%B2%B0%EC%84%B1/</id>
    <published>2020-05-16T14:43:31.000Z</published>
    <updated>2020-05-16T14:43:31.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="물리데이터베이스"><a class="markdownIt-Anchor" href="#물리데이터베이스"></a> 물리데이터베이스</h2><ul><li>데이터베이스 무결성과 칼럼 속성 및 키 종류에 대해 이해</li><li>테이블 간의 조인을 줄이기 위한 칼럼 반정규화, 정규화에서 나눈 테이블을 하나의 테이블로 통합, 하나의 테이블을 여러 개 테이블로 분리, 요약 테이블을 생성의 방법으로 반정규화를 수행</li><li>반정규화에 따른 영향도를 조사하여 적절한 조치를 하고, 반정규화가 적용된 물리 데이터베이스 설계서를 작성</li></ul><h3 id="데이터베이스-무결성-integrity-개념"><a class="markdownIt-Anchor" href="#데이터베이스-무결성-integrity-개념"></a> 데이터베이스 무결성 Integrity 개념</h3><ul><li>데이터의 <u>정확성, 일관성, 유효성, 신뢰성 등과 무효 갱신으로부터 데이터 보호</u> 등을 위해 필요</li><li>무결성 제약 조건은 데이터베이스에 들어 있는 데이터의 정확성을 보장하기 위해 <u>부정확한 자료가 데이터베이스 내에 저장</u>되는 것을 방지 하기 위한 제약 조건임</li><li>무결정의 종류<ul><li>개체 무결성</li><li>도메인 무결성</li><li>참조 무결성</li><li>사용자 정의 무결성</li></ul></li></ul><h3 id="무결성의-종류"><a class="markdownIt-Anchor" href="#무결성의-종류"></a> 무결성의 종류</h3><h4 id="1-entity-integrity-개체-무결성-실체-무결성"><a class="markdownIt-Anchor" href="#1-entity-integrity-개체-무결성-실체-무결성"></a> 1. Entity Integrity 개체 무결성, 실체 무결성</h4><ul><li><u>개체의 유일성</u>을 보장하기 위한 무결성</li><li>데이터베이스 테이블은 기본 키로 설정된 속성은 null 값이나 중복 값을 가질 수 없음</li></ul><h4 id="2-domain-integrity-도메인-무결성-영역-무결성"><a class="markdownIt-Anchor" href="#2-domain-integrity-도메인-무결성-영역-무결성"></a> 2. Domain Integrity 도메인 무결성, 영역 무결성</h4><ul><li><u>특정 속성 값이 미리 정의</u>된 도메인 범위에 속해야 함</li><li>도메인은 하나의 애트리뷰트가 취할 수 있는 같은 타입의 원자값의 집합</li></ul><h4 id="3-referential-integrity-참조-무결성"><a class="markdownIt-Anchor" href="#3-referential-integrity-참조-무결성"></a> 3. Referential Integrity 참조 무결성</h4><ul><li>릴레이션은 참조할 수 없는 외래키 값을 가질 수 없음</li><li><u>외래키 값은 Null이거나 참조하는 릴레이션의 기본 키 값이어야 함</u></li></ul><h4 id="4-user-defined-integrity-사용자-정의-무결성"><a class="markdownIt-Anchor" href="#4-user-defined-integrity-사용자-정의-무결성"></a> 4. User Defined Integrity 사용자 정의 무결성</h4><ul><li>모든 데이터는 사용자가 정의한 제약 조건인 업무 규칙 Business Rule을 준수해야 함</li></ul><h3 id="데이터-무결성-강화-개념"><a class="markdownIt-Anchor" href="#데이터-무결성-강화-개념"></a> 데이터 무결성 강화 개념</h3><ul><li><u>데이터 품질</u>에 직접적인 영향을 주며, 데이터의 품질을 확보하고 유지하기 위해서는 데이터베이싀 구축 과정에서 <u>적정한 무결성 방안을 확보 해야 함</u></li><li>프로그램이 완성되고 데이터가 축척된 상태에서 무결성을 정의할 경우 많은 비용 발생</li><li>데이터베이스에서 모두 이뤄질 수 없으므로 복잡한 규칙을 기반으로 데이터 상호 간 유지해야할 정합성은 어플리케이션 내에서 처리</li></ul><h3 id="데이터-무결성-강화-방법"><a class="markdownIt-Anchor" href="#데이터-무결성-강화-방법"></a> 데이터 무결성 강화 방법</h3><h4 id="1-애플리케이션"><a class="markdownIt-Anchor" href="#1-애플리케이션"></a> 1. 애플리케이션</h4><ul><li>데이터를 조작하는 프로그램 내에 데이터 생성, 수정, 삭제 시 무결성 조건을 <u>검증 하는 코드를 추가</u></li><li>장점<ul><li>사용자 정의 같은 <u>복잡한 무결성 조건을 구현</u></li></ul></li><li>단점<ul><li>소스코드에 분산되어 <u>관리의 어려움이 있음</u></li><li>개별적으로 시행되므로 <u>적정성 검토에 어려움</u></li></ul></li></ul><h4 id="2-데이터베이스-트리거"><a class="markdownIt-Anchor" href="#2-데이터베이스-트리거"></a> 2. 데이터베이스 트리거</h4><ul><li><u>트리거 이벤트</u>시 저장 SQL을 실행하여 무결성 조건을 실행</li><li>장점<ul><li>통합 관리가 가능함</li><li>복잡한 요건 구현 가능</li></ul></li></ul><h4 id="3-제약-조건"><a class="markdownIt-Anchor" href="#3-제약-조건"></a> 3. 제약 조건</h4><ul><li><u>데이터베이스 제약 조건 기능</u>을 선언하여 무결성을 유지</li><li>장점<ul><li>통합 관리가 가능함, 간단한 선언으로 구현 가능</li><li>변경이 용이하고, 유효/무효 상태 변경이 가능</li><li>원칙적으로 잘못된 데이터 발생을 막을 수 있음</li></ul></li><li>단점<ul><li>복잡한 제약 조건 구현이 불가능, 예외적인 처리가 불가능</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;물리데이터베이스&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#물리데이터베이스&quot;&gt;&lt;/a&gt; 물리데이터베이스&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;데이터베이스 무결성과 칼럼 속성 및 키 종류에 대해 이해&lt;/li&gt;
&lt;li&gt;테이블 간의 
      
    
    </summary>
    
    
      <category term="정보처리기사" scheme="https://hyeonukdev.github.io/categories/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/"/>
    
      <category term="물리데이터베이스" scheme="https://hyeonukdev.github.io/categories/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/%EB%AC%BC%EB%A6%AC%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4/"/>
    
    
      <category term="정보처리기사" scheme="https://hyeonukdev.github.io/tags/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/"/>
    
      <category term="데이터베이스무결성" scheme="https://hyeonukdev.github.io/tags/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EB%AC%B4%EA%B2%B0%EC%84%B1/"/>
    
  </entry>
  
  <entry>
    <title>물리데이터베이스 - 핵심정리</title>
    <link href="https://hyeonukdev.github.io/2020/05/15/Engineer_Information_Processing/ch13_%EB%AC%BC%EB%A6%AC%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EC%84%A4%EA%B3%84/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EB%AC%BC%EB%A6%AC%EC%86%8D%EC%84%B1%EC%84%A4%EA%B3%84/%ED%95%B5%EC%8B%AC%EC%A0%95%EB%A6%AC/"/>
    <id>https://hyeonukdev.github.io/2020/05/15/Engineer_Information_Processing/ch13_%EB%AC%BC%EB%A6%AC%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EC%84%A4%EA%B3%84/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EB%AC%BC%EB%A6%AC%EC%86%8D%EC%84%B1%EC%84%A4%EA%B3%84/%ED%95%B5%EC%8B%AC%EC%A0%95%EB%A6%AC/</id>
    <published>2020-05-15T07:22:16.000Z</published>
    <updated>2020-05-15T07:22:16.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="물리데이터베이스"><a class="markdownIt-Anchor" href="#물리데이터베이스"></a> 물리데이터베이스</h2><h3 id="1-파티셔닝"><a class="markdownIt-Anchor" href="#1-파티셔닝"></a> 1. 파티셔닝</h3><ul><li>데이터베이스에서 파티션은 <u>대용량의 테이블이나 인덱스를 작은 논리적 단위인 파티션으로 나누는 것 </u></li><li>장점<ul><li>데이터 접근 시 액세스 범위를 줄여 <u>쿼리 성능이 향상됨</u></li><li>파티션별로 <u>데이터가 분산되어 저장되므로 디스크의 성능이 향상됨</u></li><li>파티션별로 백업 및 복구를 수행하므로 <u>속도가 빠름</u></li><li>시스템 장애 시 <u>데이터 손상 정도를 최소화</u></li><li>데이터 가용성이 향상됨</li><li>파티션 단위로 <u>입/출력을 분산</u>시킬 수 있음</li></ul></li><li>단점<ul><li>하나의 테이블을 세분화하여 관리하므로 세심한 관리가 요구됨</li><li>테이블간 조인에 대한 <u>비용이 증가함</u></li><li><u>용량이 작은 테이블에 파티셔닝을 수행하면 오히려 성능이 저하됨</u></li></ul></li><li>종류<ul><li>범위 분할</li><li>해시 분할</li><li>조합 분할</li></ul></li></ul><h3 id="2-클러스터링"><a class="markdownIt-Anchor" href="#2-클러스터링"></a> 2. 클러스터링</h3><ul><li>데이터 저장시 데이터 액세스 효율을 향상시키기 위해 동일한 성격의 데이터를 동일한 데이터 블록에 저장하는 물리적 저장 방법</li><li>클러스터 대상 테이블<ul><li>분포도가 넓은 테이블</li><li>대량의 범위를 자주 조회하는 테이블</li><li>입력, 수정, 삭제가 자주 발생하지 않는 테이블</li><li>자주 조인되어 사용되는 테이블</li><li>ORDER BY, GROUP BY, UNION이 빈번한 테이블</li></ul></li></ul><h3 id="3-데이터베이스-백업"><a class="markdownIt-Anchor" href="#3-데이터베이스-백업"></a> 3. 데이터베이스 백업</h3><ul><li>데이터베이스 백업은 전산 장비의 장애에 대비하여 데이터베이스에 저장된 데이터를 보호하고 복구하기 위한 작업</li><li>로그 파일<ul><li>데이터베이스의 처리 내용이나 이용 상황 등 상태 변화를 시간의 흐름에 따라 모두 기록한 파일</li></ul></li><li>데이터베이스 복구 알고리즘<ul><li>NO-UNDO/REDO</li><li>UNDO/NO-REDO</li><li>UNDO/REDO</li><li>NO-UNDO/NO-REDO</li></ul></li><li>백업 종류<ul><li>물리 백업</li><li>논리 백업</li></ul></li></ul><h3 id="4-데이터베이스-용량-설계"><a class="markdownIt-Anchor" href="#4-데이터베이스-용량-설계"></a> 4. 데이터베이스 용량 설계</h3><ul><li>데이터베이스 용량을 설계할 때는 테이블에 저장할 데이터양과 인덱스, 클러스터 등이 차지하는 공간 등을 예측하여 반영함</li><li>데이터베이스의 용량을 정확히 산정하여 디스크의 저장공간을 효과적으로 사용하고 확장성 및 가용성을 높임</li><li>테이블스페이스 설계 시 고려사항<ul><li>테이블스페이스는 업무별로 구분하여 지정</li><li>대용량 테이블은 하나의 테이블스페이스에 독립적으로 저장</li><li>테이블과 인덱스는 분리하여 저장</li><li>LOB(Large Object)타입의 데이터는 독립적인 공간으로 지정</li></ul></li></ul><h3 id="5-데이터-지역화-locality"><a class="markdownIt-Anchor" href="#5-데이터-지역화-locality"></a> 5. 데이터 지역화 Locality</h3><ul><li>데이터베이스의 저장 데이터를 효율적으로 이용할 수 있도록 저장하는 방법</li><li>물리적 데이터베이스 설계, 보조 기억 장치의 역할, 디스크 상의 파일의 배치를 지역화 관점에서 검토</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;물리데이터베이스&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#물리데이터베이스&quot;&gt;&lt;/a&gt; 물리데이터베이스&lt;/h2&gt;
&lt;h3 id=&quot;1-파티셔닝&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1-파티셔
      
    
    </summary>
    
    
      <category term="정보처리기사" scheme="https://hyeonukdev.github.io/categories/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/"/>
    
      <category term="물리데이터베이스" scheme="https://hyeonukdev.github.io/categories/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/%EB%AC%BC%EB%A6%AC%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4/"/>
    
    
      <category term="정보처리기사" scheme="https://hyeonukdev.github.io/tags/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/"/>
    
      <category term="핵심정리" scheme="https://hyeonukdev.github.io/tags/%ED%95%B5%EC%8B%AC%EC%A0%95%EB%A6%AC/"/>
    
  </entry>
  
  <entry>
    <title>물리데이터베이스 - 데이터지역화</title>
    <link href="https://hyeonukdev.github.io/2020/05/15/Engineer_Information_Processing/ch13_%EB%AC%BC%EB%A6%AC%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EC%84%A4%EA%B3%84/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EB%AC%BC%EB%A6%AC%EC%86%8D%EC%84%B1%EC%84%A4%EA%B3%84/%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%A7%80%EC%97%AD%ED%99%94/"/>
    <id>https://hyeonukdev.github.io/2020/05/15/Engineer_Information_Processing/ch13_%EB%AC%BC%EB%A6%AC%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EC%84%A4%EA%B3%84/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EB%AC%BC%EB%A6%AC%EC%86%8D%EC%84%B1%EC%84%A4%EA%B3%84/%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%A7%80%EC%97%AD%ED%99%94/</id>
    <published>2020-05-15T07:15:49.000Z</published>
    <updated>2020-05-15T07:15:49.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="물리데이터베이스"><a class="markdownIt-Anchor" href="#물리데이터베이스"></a> 물리데이터베이스</h2><h3 id="데이터-지역화-data-locality-개념"><a class="markdownIt-Anchor" href="#데이터-지역화-data-locality-개념"></a> 데이터 지역화 Data Locality 개념</h3><ul><li>데이터베이스의 <u>저장 데이터를 효율적으로 이용할 수 있도록 저장</u>하는 방법</li><li>물리적 데이터베이스 셀계에서 <u>데이터 지역화를 고려한 보조 저장장치의 설계가 중요</u>함</li><li>물리적 데이터베이스 설계, 보조 기억 장치의 역할, 디스크 상의 파일의 배치를 지역화 관점에서 검토</li></ul><h3 id="물리적-데이터베이스-설계"><a class="markdownIt-Anchor" href="#물리적-데이터베이스-설계"></a> 물리적 데이터베이스 설계</h3><ul><li><u>논리적 설계의 데이터 구조</u>를 <u>보조 기억 장치상의 파일</u>(물리적 데이터 모델)로 매핑</li><li>하나의 파일에 여러 릴레이션이 저장될 수 있음</li><li>예상 빈도를 포함하여 데이터베이스 질의와 트랜잭션을 분석</li><li><u>데이터에 대한 효율적인 접근을 제공</u>하기 위하여 저장 구조와 접근 방법들을 고려함</li><li>질의를 효율적으로 지원하기 위해 <u>인덱스 구조를 적절히 사용함</u></li></ul><h3 id="보조-기억-장치의-역할"><a class="markdownIt-Anchor" href="#보조-기억-장치의-역할"></a> 보조 기억 장치의 역할</h3><ul><li><u>각 파일은 고정된 크기의 블록</u>들로 나누어져 저장됨</li><li>여러 개의 블록들에 파일의 데이터가 분산되어 저장됨</li><li>디스크는 데이터베이스를 장기간 보관하는 주된 보조 기억장치</li></ul><h3 id="디스크상에서-파일의-레코드-배치"><a class="markdownIt-Anchor" href="#디스크상에서-파일의-레코드-배치"></a> 디스크상에서 파일의 레코드 배치</h3><ul><li>릴레이션의 속성은 고정 길이 또는 가변 길이의 필드로 표현됨</li><li>연관된 필드들이 모여서 고정 길이 또는 가변 길이의 레코드가 됨</li><li><u>한 릴레이션을 구성하는 레코드들의 모임은 파일</u>이라고 부르는 블록들의 모임에 저장</li><li>한 파일에 속하는 블록들의 위치가 반드시 인접해 있을 필요는 없음</li><li>인접한 블록들을 읽는 경우 탐구 시간과 회전 지연 시간이 들지 않기 때문에 <u>입출력 속도가 빠르므로 블록들이 인접하도록 파일의 블록들을 재조직</u>함</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;물리데이터베이스&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#물리데이터베이스&quot;&gt;&lt;/a&gt; 물리데이터베이스&lt;/h2&gt;
&lt;h3 id=&quot;데이터-지역화-data-locality-개념&quot;&gt;&lt;a class=&quot;markdownIt-An
      
    
    </summary>
    
    
      <category term="정보처리기사" scheme="https://hyeonukdev.github.io/categories/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/"/>
    
      <category term="물리데이터베이스" scheme="https://hyeonukdev.github.io/categories/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/%EB%AC%BC%EB%A6%AC%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4/"/>
    
    
      <category term="정보처리기사" scheme="https://hyeonukdev.github.io/tags/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/"/>
    
      <category term="데이터지역화" scheme="https://hyeonukdev.github.io/tags/%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%A7%80%EC%97%AD%ED%99%94/"/>
    
  </entry>
  
  <entry>
    <title>물리데이터베이스 - 데이터베이스 용량 설계</title>
    <link href="https://hyeonukdev.github.io/2020/05/15/Engineer_Information_Processing/ch13_%EB%AC%BC%EB%A6%AC%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EC%84%A4%EA%B3%84/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EB%AC%BC%EB%A6%AC%EC%86%8D%EC%84%B1%EC%84%A4%EA%B3%84/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EC%9A%A9%EB%9F%89%EC%84%A4%EA%B3%84/"/>
    <id>https://hyeonukdev.github.io/2020/05/15/Engineer_Information_Processing/ch13_%EB%AC%BC%EB%A6%AC%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EC%84%A4%EA%B3%84/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EB%AC%BC%EB%A6%AC%EC%86%8D%EC%84%B1%EC%84%A4%EA%B3%84/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EC%9A%A9%EB%9F%89%EC%84%A4%EA%B3%84/</id>
    <published>2020-05-15T06:58:35.000Z</published>
    <updated>2020-05-15T06:58:35.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="물리데이터베이스"><a class="markdownIt-Anchor" href="#물리데이터베이스"></a> 물리데이터베이스</h2><h3 id="데이터베이스-용량-설계-개념"><a class="markdownIt-Anchor" href="#데이터베이스-용량-설계-개념"></a> 데이터베이스 용량 설계 개념</h3><ul><li>데이터베이스 용량 설계는 데이터가 저장될 공간을 정의</li><li>데이터베이스 용량을 설계할 때는 테이블에 저장할 데이터양과 인덱스, 클러스터 등이 차지하는 공간 등을 예측하여 반영함</li><li><b>설계과정에서 수행</b></li></ul><h3 id="tablespace-테이블-스페이스"><a class="markdownIt-Anchor" href="#tablespace-테이블-스페이스"></a> Tablespace 테이블 스페이스</h3><ul><li><u>테이블이 저장되는 논리적인 영역</u>으로, 하나의 테이블스페이스에 하나 또는 그 이상의 테이블 저장 가능</li><li>테이블을 저장하면 논리적으로는 테이블스페이스에 저장되고, <u>물리적</u>으로는 해당 테이블스페이스와 연관된 <u>데이터 파일에 저장</u></li><li>데이터베이스를 테이블, 테이블스페이스, 데이터 파일로 나눠 관리하면 <u>논리적 구성이 물리적 구성에 종속되지 않아 투명성이 보장됨</u></li><li>테이블스페이스는 데이터베이스에 저장되는 내용에 따라 테이블, 인덱스, 임시(Temporary) 등의 용도로 구분하여 설계</li><li>테이블스페이스 설계 시 고려사항<ul><li>테이블스페이스는 업무별로 구분하여 지정</li><li>대용량 테이블은 하나의 테이블스페이스에 독립적으로 저장</li><li>테이블과 인덱스는 분리하여 저장</li><li>LOB(Large Object)타입의 데이터는 독립적인 공간으로 지정</li></ul></li></ul><h3 id="데이터베이스-용량-설계-목적"><a class="markdownIt-Anchor" href="#데이터베이스-용량-설계-목적"></a> 데이터베이스 용량 설계 목적</h3><ul><li>데이터베이스의 용량을 정확히 산정하여 <u>디스크의 저장 공간을 효과적으로 사용하고 확장성 및 가용성을 높임</u></li><li>디스크의 특성을 고려하여 설계함으로써 <u>디스크의 입/출력 부하를 분산시키고 채널의 병목 현상을 최소화</u></li><li><u>디스크에 대한 입/출력 경합이 최소화</u>되도록 설계함으로써 <b>데이터 접근성 향상</b><ul><li>테이블과 인덱스의 테이블스페이스를 분리 구성</li><li>테이블스페이스와 임시 테이블스페이스를 분리 구성</li><li>테이블을 마스터 테이블과 트랜잭션 테이블로 분류</li></ul></li><li>데이터베이스의 기본 용량이 모두 찼을 경우 추가적으로 공간이 할당되는 익스텐트(Extent) 발생을 <b>최소화</b>하여 성능 향상</li><li>데이터베이스 용량을 정확히 분석하여 테이블과 인덱스에 적합한 저장 옵션 지정</li></ul><h3 id="데이터베이스-용량-분석-절차"><a class="markdownIt-Anchor" href="#데이터베이스-용량-분석-절차"></a> 데이터베이스 용량 분석 절차</h3><ol><li>데이터 예상 건수, Row 길이, 보존 기간, 증가율 등 기초 자료를 수집하여 용량을 분석</li><li>분석된 자료를 바탕으로 DBMS에 이용될 테이블, 인덱스 등 오브젝트별 용량을 산정</li><li>테이블과 인덱스의 테이블스페이스 용량을 산정</li><li>데이터베이스에 저장될 모든 데이터 용량과 데이터베이스 설치 및 관리를 위한 시스템 용량을 합해 디스크 용량을 산정</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;물리데이터베이스&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#물리데이터베이스&quot;&gt;&lt;/a&gt; 물리데이터베이스&lt;/h2&gt;
&lt;h3 id=&quot;데이터베이스-용량-설계-개념&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; hre
      
    
    </summary>
    
    
      <category term="정보처리기사" scheme="https://hyeonukdev.github.io/categories/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/"/>
    
      <category term="물리데이터베이스" scheme="https://hyeonukdev.github.io/categories/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/%EB%AC%BC%EB%A6%AC%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4/"/>
    
    
      <category term="정보처리기사" scheme="https://hyeonukdev.github.io/tags/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/"/>
    
      <category term="데이터베이스용량설계" scheme="https://hyeonukdev.github.io/tags/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EC%9A%A9%EB%9F%89%EC%84%A4%EA%B3%84/"/>
    
  </entry>
  
  <entry>
    <title>물리데이터베이스 - 데이터베이스백업</title>
    <link href="https://hyeonukdev.github.io/2020/05/15/Engineer_Information_Processing/ch13_%EB%AC%BC%EB%A6%AC%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EC%84%A4%EA%B3%84/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EB%AC%BC%EB%A6%AC%EC%86%8D%EC%84%B1%EC%84%A4%EA%B3%84/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EB%B0%B1%EC%97%85/"/>
    <id>https://hyeonukdev.github.io/2020/05/15/Engineer_Information_Processing/ch13_%EB%AC%BC%EB%A6%AC%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EC%84%A4%EA%B3%84/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EB%AC%BC%EB%A6%AC%EC%86%8D%EC%84%B1%EC%84%A4%EA%B3%84/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EB%B0%B1%EC%97%85/</id>
    <published>2020-05-15T06:15:44.000Z</published>
    <updated>2020-05-15T06:15:44.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="물리데이터베이스"><a class="markdownIt-Anchor" href="#물리데이터베이스"></a> 물리데이터베이스</h2><h3 id="데이터베이스-백업-개념"><a class="markdownIt-Anchor" href="#데이터베이스-백업-개념"></a> 데이터베이스 백업 개념</h3><ul><li>데이터베이스 백업은 <u>전산 장비의 장애에 대비</u> 하여 <u>데이터베이스에 저장된 데이터를 보호하고 복구</u>하기 위한 작업</li><li>치명적인 데이터 손실을 막기 위해서는 데이터베이스를 <u>정기적으로 백업</u></li><li>데이터베이스 관리 시스템은 데이터베이스 파괴 및 실행 중단이 발생하면 이를 복구할 수 있는 기능을 제공함</li></ul><h3 id="데이터베이스-장애-유형"><a class="markdownIt-Anchor" href="#데이터베이스-장애-유형"></a> 데이터베이스 장애 유형</h3><ul><li>사용자 실수<ul><li>사용자 실수로 인해 테이블이 삭제되거나 잘못된 트랜잭션이 처리된 경우</li></ul></li><li>미디어 장애<ul><li>CPU, 메모리, 디스크 등 하드웨어 장애나 데이터가 파손</li></ul></li><li>구문 장애<ul><li>프로그램 오류나 사용 공간의 부족으로 인해 발생하는 장애</li></ul></li><li>사용자 프로세스 장애<ul><li>프로그램이 비정상적으로 종료되거나 네트워크 이상으로 세션이 종료되어 발생하는 오류</li></ul></li><li>인스턴스 장애<ul><li>하드웨어 장애, 정전, 시스템 파일 파손 등 비정상적인 요인으로 인해 메모리나 데이터베이스 서버의 프로세스가 중단</li></ul></li></ul><h3 id="로그-파일"><a class="markdownIt-Anchor" href="#로그-파일"></a> 로그 파일</h3><ul><li>로그 파일은 <u>데이터베이스의 처리 내용이나 이용 상황</u> 등 <u>상태 변화를 <b>시간의 흐름</b>에 따라 모두 기록</u>한 파일</li><li>데이터베이스 복구를 위해 필요한 가장 기본적인 자료</li><li>로그 파일을 기반으로 데이터베이스를 과거 상태로 복귀(UNDO)시키거나 현재 상태로 재생(REDO)시켜 데이터베이스 상태를 일관성 있게 유지</li><li>로그 파일은 <u>트랜잭션 시작 시점, Rollback 시점, 데이터 입력, 수정, 삭제 시점 등에서 기록 </u></li><li><u>로그 파일 내용</u><ul><li>트랜잭션이 작업한 모든 내용, 트랜잭션 식별, 트랜잭션 레코드, 데이터 식별자, 갱신 이전 값(Before Image), 갱신 이후 값(After Image) 등</li></ul></li></ul><h3 id="데이터베이스-복구-알고리즘"><a class="markdownIt-Anchor" href="#데이터베이스-복구-알고리즘"></a> 데이터베이스 복구 알고리즘</h3><h4 id="1-no-undoredo"><a class="markdownIt-Anchor" href="#1-no-undoredo"></a> 1. NO-UNDO/REDO</h4><ul><li>데이터베이스 버퍼의 내용을 비동기적으로 갱신한 경우의 복구 알고리즘</li><li>NO-UNDO : 트랜잭션 완료 전에는 변경 내용이 데이터베이스에 기록되지 않으므로 취소할 필요가 없음</li><li>REDO : 트랜잭션 완료 후 데이터베이스 버퍼에는 기록되어 있고, 저장매체에는 기록되지 않으므로 트랜잭션을 다시 실행</li></ul><h4 id="2-undono-redo"><a class="markdownIt-Anchor" href="#2-undono-redo"></a> 2. UNDO/NO-REDO</h4><ul><li>데이터베이스 버퍼의 내용을 동기적으로 갱신한 경우의 복구 알고리즘</li><li>UNDO : 트랜잭션 완료 전에 시스템이 파손되었다면 변경된 내용 취소</li><li>NO-REDO : 트랜잭션 완료 전에 데이터베이스 버퍼 내용을 이미 저장매체에 기록했으므로 트랜잭션 내용을 다시 실행하지 않음</li></ul><h4 id="3-undoredo"><a class="markdownIt-Anchor" href="#3-undoredo"></a> 3. UNDO/REDO</h4><ul><li>데이터베이스 버퍼의 내용을 동기/비동기적으로 갱신한 경우의 복구 알고리즘</li><li>데이터베이스 기록 전에 트랜잭션이 완료될 수 있으므로 완료된 트랜잭션이 데이터베이스에 기록되지 못했다면 다시 실행</li></ul><h4 id="4-no-undono-redo"><a class="markdownIt-Anchor" href="#4-no-undono-redo"></a> 4. NO-UNDO/NO-REDO</h4><ul><li>데이터베이스 버퍼의 내용을 동기적으로 저장 매체에 기록하지만 데이터베이스와는 다른 영역에 기록한 경우의 복구 알고리즘</li><li>NO-UNDO : 변경 내용은 데이터베이스와 다른 영역에 기록되어 있으므로 취소할 필요가 없음</li><li>NO-REDO : 다른 영역에 이미 기록되어 있으므로 트랜잭션을 다시 실행할 필요 없음</li></ul><h3 id="백업종류"><a class="markdownIt-Anchor" href="#백업종류"></a> 백업종류</h3><h4 id="1-물리-백업"><a class="markdownIt-Anchor" href="#1-물리-백업"></a> 1. 물리 백업</h4><ul><li>데이터베이스 파일을 백업하는 방법</li><li>백업 속도가 빠르고 작업이 단순하지만 문제 발생시 원인 파악 및 문제 해결이 어려움</li><li><b>완전 복구 가능</b></li></ul><h4 id="2-논리-백업"><a class="markdownIt-Anchor" href="#2-논리-백업"></a> 2. 논리 백업</h4><ul><li>DB 내의 논리적 객체들을 백업하는 방법</li><li>복원 시 데이터 손상을 막고 문제 발생 시 원인 파악 및 해결이 수월하지만 백업/복원 시 시간이 많이 소요됨</li></ul><table><thead><tr><th>구분</th><th>설명</th><th>복구수준</th></tr></thead><tbody><tr><td>물리백업</td><td>로그 파일 백업 실시</td><td>완전 복구</td></tr><tr><td>물리백업</td><td>로그 파일 백업 없음</td><td>백업 시점까지 복구</td></tr><tr><td>논리 백업</td><td>DBMS 유틸리티</td><td>백업 시점까지 복구</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;물리데이터베이스&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#물리데이터베이스&quot;&gt;&lt;/a&gt; 물리데이터베이스&lt;/h2&gt;
&lt;h3 id=&quot;데이터베이스-백업-개념&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;
      
    
    </summary>
    
    
      <category term="정보처리기사" scheme="https://hyeonukdev.github.io/categories/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/"/>
    
      <category term="물리데이터베이스" scheme="https://hyeonukdev.github.io/categories/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/%EB%AC%BC%EB%A6%AC%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4/"/>
    
    
      <category term="정보처리기사" scheme="https://hyeonukdev.github.io/tags/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/"/>
    
      <category term="데이터베이스백업" scheme="https://hyeonukdev.github.io/tags/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EB%B0%B1%EC%97%85/"/>
    
  </entry>
  
  <entry>
    <title>물리데이터베이스 - 클러스터링</title>
    <link href="https://hyeonukdev.github.io/2020/05/15/Engineer_Information_Processing/ch13_%EB%AC%BC%EB%A6%AC%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EC%84%A4%EA%B3%84/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EB%AC%BC%EB%A6%AC%EC%86%8D%EC%84%B1%EC%84%A4%EA%B3%84/%ED%81%B4%EB%9F%AC%EC%8A%A4%ED%84%B0%EB%A7%81/"/>
    <id>https://hyeonukdev.github.io/2020/05/15/Engineer_Information_Processing/ch13_%EB%AC%BC%EB%A6%AC%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EC%84%A4%EA%B3%84/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EB%AC%BC%EB%A6%AC%EC%86%8D%EC%84%B1%EC%84%A4%EA%B3%84/%ED%81%B4%EB%9F%AC%EC%8A%A4%ED%84%B0%EB%A7%81/</id>
    <published>2020-05-15T06:08:43.000Z</published>
    <updated>2020-05-15T06:08:43.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="물리데이터베이스"><a class="markdownIt-Anchor" href="#물리데이터베이스"></a> 물리데이터베이스</h2><h3 id="cluster-클러스터의-개념"><a class="markdownIt-Anchor" href="#cluster-클러스터의-개념"></a> Cluster 클러스터의 개념</h3><ul><li>데이터 저장시 <u>데이터 액세스 효율을 향상</u>시키기 위해 <u>동일한 성격의 데이터를 동일한 데이터 블록에 저장</u>하는 물리적 저장 방법</li><li><u>클러스터링키</u>로 지정된 컬럼 값의 순서대로 저장되고, <u>여러 개의 테이블이 하나의 클러스터에 저장됨</u></li></ul><h3 id="클러스터의-특징"><a class="markdownIt-Anchor" href="#클러스터의-특징"></a> 클러스터의 특징</h3><ul><li>클러스터링 된 테이블은 데이터 <u>조회 속도</u>는 향상시키지만 데이터 입력, 수정, 삭제에 대한 성능은 저하됨</li><li>클러스터는 <u>데이터의 분포도가 넓을수록 유리함</u></li><li>데이터 분포도가 넓은 테이블을 클러스터링 하면 <u>저장 공간을 절약</u>할 수 있음</li><li><u>대용량을 처리하는 트랜잭션은 전체 테이블을 스캔</u>하는 일이 자주 발생하므로 <u>클러스터링을 하지 않는 것이 좋음</u></li><li></u>처리 범위가 넓은 경우에는 단일 테이블 클러스터링을, 조인이 많이 발생하는 경우는 다중 테이블 클러스터링을 사용</u></li><li><u><b>파티셔닝된 테이블에는 클러스터링 불가</b></u></li><li><u>클러스터링된 테이블에 클러스터드 인덱스를 생성하면 접근 성능 향상</u></li></ul><h3 id="클러스터-대상-테이블"><a class="markdownIt-Anchor" href="#클러스터-대상-테이블"></a> 클러스터 대상 테이블</h3><ul><li>분포도가 <b>넓은</b> 테이블</li><li>대량의 범위를 자주 조회하는 테이블</li><li>입력, 수정, 삭제가 자주 발생하지 않는 테이블</li><li><b>자주 조인</b>되어 사용되는 테이블</li><li>ORDER BY, GROUP BY, UNION이 빈번한 테이블</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;물리데이터베이스&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#물리데이터베이스&quot;&gt;&lt;/a&gt; 물리데이터베이스&lt;/h2&gt;
&lt;h3 id=&quot;cluster-클러스터의-개념&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; hr
      
    
    </summary>
    
    
      <category term="정보처리기사" scheme="https://hyeonukdev.github.io/categories/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/"/>
    
      <category term="물리데이터베이스" scheme="https://hyeonukdev.github.io/categories/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/%EB%AC%BC%EB%A6%AC%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4/"/>
    
    
      <category term="정보처리기사" scheme="https://hyeonukdev.github.io/tags/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/"/>
    
      <category term="클러스터링" scheme="https://hyeonukdev.github.io/tags/%ED%81%B4%EB%9F%AC%EC%8A%A4%ED%84%B0%EB%A7%81/"/>
    
  </entry>
  
  <entry>
    <title>물리데이터베이스 - 파티셔닝</title>
    <link href="https://hyeonukdev.github.io/2020/05/15/Engineer_Information_Processing/ch13_%EB%AC%BC%EB%A6%AC%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EC%84%A4%EA%B3%84/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EB%AC%BC%EB%A6%AC%EC%86%8D%EC%84%B1%EC%84%A4%EA%B3%84/%ED%8C%8C%ED%8B%B0%EC%85%94%EB%8B%9D/"/>
    <id>https://hyeonukdev.github.io/2020/05/15/Engineer_Information_Processing/ch13_%EB%AC%BC%EB%A6%AC%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EC%84%A4%EA%B3%84/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EB%AC%BC%EB%A6%AC%EC%86%8D%EC%84%B1%EC%84%A4%EA%B3%84/%ED%8C%8C%ED%8B%B0%EC%85%94%EB%8B%9D/</id>
    <published>2020-05-15T04:55:27.000Z</published>
    <updated>2020-05-15T04:55:27.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="물리데이터베이스"><a class="markdownIt-Anchor" href="#물리데이터베이스"></a> 물리데이터베이스</h2><ul><li><p>식별된 오브젝트의 데이터 타입, 사이즈, 증가 용량을 고려하여 저장 공간을 산출하고, 해당 오브젝트에 대한 테이블 스페이스를 할당</p></li><li><p>할당된 테이블 스페이스 용량을 기반으로 디스크 저장 용량을 산정하고, 데이터베이스 백업 주기, 방식에 따른 별도 저장 공간 용량을 산정</p></li><li><p>분산위치, 엔티티명, 테이블명, 테이블 스페이스명, 테이블 스페이스 용량, 데이터 파일명, 파티셔닝, 클러스터링 정보, 보안정보에 대한 물리 데이터베이스 설계서를 작성</p></li></ul><h3 id="partition-파티션-개념"><a class="markdownIt-Anchor" href="#partition-파티션-개념"></a> Partition 파티션 개념</h3><ul><li>데이터베이스에서 파티션은 <u>대용량의 테이블이나 인덱스를 작은 논리적 단위인 파티션으로 나누는 것 </u><ul><li>대용량 데이터베이스의 경우 중요한 몇 개의 테이블에만 집중되어 데이터가 증가되므로 이런 테이블을 작은 단위로 나눠 분산시키면 <u>성능 저하를 방지와 데이터 관리가 쉬워짐</u></li><li>테이블이나 인덱스를 파티셔닝하면 파티션키 또는 인덱스키에 따라 <u>물리적으로 별도의 공간에 데이터가 저장됨</u></li><li><u>데이터 처리는 테이블 단위로 이뤄지고 데이터 저장은 파티션별로 수행</u></li></ul></li></ul><h3 id="파티션-장단점"><a class="markdownIt-Anchor" href="#파티션-장단점"></a> 파티션 장/단점</h3><ul><li>장점<ul><li>데이터 접근 시 액세스 범위를 줄여 <u>쿼리 성능이 향상됨</u></li><li>파티션별로 <u>데이터가 분산되어 저장되므로 디스크의 성능이 향상됨</u></li><li>파티션별로 백업 및 복구를 수행하므로 <u>속도가 빠름</u></li><li>시스템 장애 시 <u>데이터 손상 정도를 최소화</u></li><li>데이터 가용성이 향상됨</li><li>파티션 단위로 <u>입/출력을 분산</u>시킬 수 있음</li></ul></li><li>단점<ul><li>하나의 테이블을 세분화하여 관리하므로 세심한 관리가 요구됨</li><li>테이블간 조인에 대한 <u>비용이 증가함</u></li><li><u>용량이 작은 테이블에 파티셔닝을 수행하면 오히려 성능이 저하됨</u></li></ul></li></ul><h3 id="파티션의-종류"><a class="markdownIt-Anchor" href="#파티션의-종류"></a> 파티션의 종류</h3><h4 id="1-range-partitioning-범위-분할"><a class="markdownIt-Anchor" href="#1-range-partitioning-범위-분할"></a> 1. Range Partitioning 범위 분할</h4><ul><li>지정한 열의 값을 기준을 분할<ul><li>일별, 월별, 분기별</li></ul></li></ul><h4 id="2-hash-partitioning-해시-분할"><a class="markdownIt-Anchor" href="#2-hash-partitioning-해시-분할"></a> 2. Hash Partitioning 해시 분할</h4><ul><li><u>해시 함수를 적용한 결과 값에 따라 데이터를 분할</u></li><li>특정 파티션에 데이터가 집중되는 범위 분할의 단점을 보완한 것으로 <u>데이터를 고르게 분산할 때 유용함</u></li><li>특정 데이터가 어디에 있는지 판단할 수 없음</li><li>고객번호, 주민번호 등과 같이 데이터가 고른 컬럼에 효과적임</li></ul><h4 id="3-composite-partitoning-조합-분할"><a class="markdownIt-Anchor" href="#3-composite-partitoning-조합-분할"></a> 3. Composite Partitoning 조합 분할</h4><ul><li>범위 분할로 분할한 다음 해시 함수를 적용하여 다시 분할하는 방식</li><li>범위 분할한 파티션이 너무 커서 관리가 어려울 때 유용함</li></ul><h3 id="파티션키-선정시-고려사항"><a class="markdownIt-Anchor" href="#파티션키-선정시-고려사항"></a> 파티션키 선정시 고려사항</h3><ul><li>파티션키는 <u>테이블 접근 유형</u>에 따라 파티셔닝이 이뤄지도록 선정</li><li>데이터 관리의 용이성을 위해 <u>이력성 데이터</u>는 파티션 생성주기와 소멸주기를 일치</li><li><u>매일 생성되는 날짜 컬럼, 백업의 기준이 되는 날짜 컬럼, 파티션 간 이동이 없는 컬럼, I/O 병목을 줄일 수 있는 데이터 분포가 양호한 컬럼</u> 등을 파티션키로 선정</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;물리데이터베이스&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#물리데이터베이스&quot;&gt;&lt;/a&gt; 물리데이터베이스&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;식별된 오브젝트의 데이터 타입, 사이즈, 증가 용량을 고려하여 저장 공간을 산출
      
    
    </summary>
    
    
      <category term="정보처리기사" scheme="https://hyeonukdev.github.io/categories/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/"/>
    
      <category term="물리데이터베이스" scheme="https://hyeonukdev.github.io/categories/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/%EB%AC%BC%EB%A6%AC%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4/"/>
    
    
      <category term="정보처리기사" scheme="https://hyeonukdev.github.io/tags/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/"/>
    
      <category term="파티셔닝" scheme="https://hyeonukdev.github.io/tags/%ED%8C%8C%ED%8B%B0%EC%85%94%EB%8B%9D/"/>
    
  </entry>
  
</feed>
